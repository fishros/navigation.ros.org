# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020
# This file is distributed under the same license as the Navigation 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Navigation 2 latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-18 21:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:4
msgid "Adding a New Nav2 Task Server"
msgstr "添加一个新的Nav2任务服务器"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:6
msgid "A nav2 task server consists of server side logic to complete different types of requests, usually called by the autonomy system or through the Behavior Tree Navigator. In this guide, we will discuss the core components needed to add a new task server to Nav2 (ex. Controller, Behavior, Smoother, Planner Servers). Namely, how to set up your new Lifecycle-Component Node for launch and state management and the communication of semantically meaningful error codes (if necessary)."
msgstr "nav2任务服务器包括完成不同类型请求的服务器端逻辑，通常由自主系统或通过行为树导航器调用。在本指南中，我们将讨论将新的任务服务器添加到Nav2所需的核心组件（例如控制器、行为、平滑器、规划器服务器）。特别是如何设置新的生命周期组件节点以进行启动和状态管理，以及语义上有意义的错误代码的通信（如果需要）。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:8
msgid "While this tutorial does not cover how to add the complementary Behavior Tree Node to interact with this new Task Server, that is covered at length in :ref:`writing_new_nbt_plugin` so this Task Server can be invoked in the BTs in BT Navigator."
msgstr "尽管本教程不涵盖如何添加与该新任务服务器交互的补充行为树节点，但在:ref:`writing_new_nbt_plugin`中详细介绍了该内容，因此可以在BT Navigator中调用该任务服务器。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:10
msgid "If you've created a new Task Server that may have general reuse for the community, consider contacting the maintainers to add it to the Nav2 project! Nav2 gets better by contributions by users like you!"
msgstr "如果您创建了一个可能对社区有普遍重用价值的新任务服务器，请考虑联系维护人员将其添加到Nav2项目中！Nav2通过像您这样的用户的贡献而变得更好！"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:15
msgid "Lifecycle Nodes"
msgstr "生命周期节点"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:17
msgid "The Lifecycle node is the first key component of a nav2 task server. Lifecycle nodes were introduced in ROS 2 to systematically manage the bringup and shutdown of the different nodes involved in the robot's operation. The use of Lifecycle nodes ensures that all nodes are successfully instantiated before they begin their execution and Nav2 shuts down all nodes if there is any unresponsive node."
msgstr "Lifecycle节点是nav2任务服务器的首要关键组件。Lifecycle节点在ROS 2中引入，用于系统地管理参与机器人操作的不同节点的启动和关闭。使用Lifecycle节点可以确保在节点开始执行之前，所有节点都成功实例化，并且如果有任何无响应的节点，Nav2会关闭所有节点。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:20
msgid "Lifecycle nodes contain state machine transitions that enable deterministic behavior in ROS 2 servers. The Lifecycle node transitions in Nav2 are handled by the ``Lifecycle Manager``. The Lifecycle Manager transitions the states of the Lifecycle nodes and provides greater control over the state of a system."
msgstr "生命周期节点包含状态机转换，以实现ROS 2服务器中的确定性行为。Nav2中的生命周期节点转换由``Lifecycle Manager``处理。Lifecycle Manager转换生命周期节点的状态，并对系统的状态提供更大的控制。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:23
msgid "The primary states of a Lifecycle node are ``Unconfigured``, ``Inactive``, ``Active``, and ``Finalized``. A Lifecycle node starts in an ``Unconfigured`` state after being instantiated. The Lifecycle Manager transitions a node from ``Unconfigured`` to ``Inactive`` by implementing the ``Configurating`` transition. The ``Configurating`` transition sets up all configuration parameters and prepares any required setup such as memory allocation and the set up of the static publication and subscription topics. A node in the ``Inactive`` state is allowed to reconfigure its parameters and but cannot perform any processing. From the ``Inactive`` state, the Lifecyle Manager implements the ``Activating`` transition state to transition the node from ``Inactive`` to ``Active``, which is the main state. A node in the ``Active`` state is allowed to perform any processing operation. In case a node crashes, the Lifecycle Manager shuts down the system to prevent any critical failures. On shutdown, the necessary cleanup operations are performed and the nodes are transitioned to the ``Finalized`` state via ``Deactivating``, ``CleaningUp``, and ``ShuttingDown`` transition states."
msgstr "Lifecycle节点的主要状态有``Unconfigured``、``Inactive``、``Active``和``Finalized``。Lifecycle节点在实例化后以``Unconfigured``状态启动。Lifecycle管理器通过实现``Configurating``转换将节点从``Unconfigured``转换为``Inactive``。``Configurating``转换设置所有配置参数并准备任何必需的设置，如内存分配以及静态发布和订阅主题的设置。处于``Inactive``状态的节点可以重新配置其参数，但无法执行任何处理。从``Inactive``状态开始，Lifecycle管理器实现``Activating``转换状态，将节点从``Inactive``转换为主状态``Active``。处于``Active``状态的节点可以执行任何处理操作。如果节点崩溃，Lifecycle管理器将关闭系统以防止任何关键故障。关闭时，执行必要的清理操作，并通过``Deactivating``、``CleaningUp``和``ShuttingDown``转换状态将节点转换为``Finalized``状态。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:26
msgid "For more information on Lifecycle management, see the article on `Managed Nodes <https://design.ros2.org/articles/node_lifecycle.html>`_."
msgstr "有关生命周期管理的更多信息，请参阅`Managed Nodes的文章<https://design.ros2.org/articles/node_lifecycle.html>`_。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:28
msgid "You may wish to integrate your own nodes into the Nav2 framework or add new lifecycle nodes to your system. As an example, we will add a new notional lifecycle node ``sensor_driver``, and have it be controlled via the Nav2 Lifecycle Manager to ensure sensor feeds are available before activating navigation. You can do so by adding a ``sensor_driver`` node in your launch file and adding it to the list of nodes to be activated by the ``lifecycle_manager`` before navigation, as shown in the example below."
msgstr "您可能希望将自己的节点集成到Nav2框架中，或向系统添加新的生命周期节点。作为示例，我们将添加一个名为``sensor_driver``的新的虚构生命周期节点，并通过Nav2 Lifecycle管理器对其进行控制，以确保在激活导航之前传感器数据可用。您可以通过在启动文件中添加一个``sensor_driver``节点，并将其添加到在导航之前由``lifecycle_manager``激活的节点列表中，如下面的示例所示。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:59
msgid "In the snippet above, the nodes to be handled by the Lifecycle Manager are set using the ``node_names`` parameter. The ``node_names`` parameter takes in an ordered list of nodes to bringup through the Lifecycle transition. As shown in the snippet, the ``node_names`` parameter takes in ``lifecycle_nodes`` which contains the list of nodes to be added to the Lifecycle Manager. The Lifecycle Manager implements bringup transitions (``Configuring`` and ``Activating``) to the nodes one-by-one and in order, while the nodes are processed in reverse order for shutdown transitions. Hence, the ``sensor_driver`` is listed first before the other navigation servers so that the sensor data is available before the navigation servers are activated."
msgstr "在上面的片段中，使用``node_names``参数设置要由Lifecycle Manager处理的节点。``node_names``参数接受一个有序列表，通过生命周期转换将节点启动。如示例中所示，``node_names``参数接受包含要添加到Lifecycle Manager的节点列表的``lifecycle_nodes``。Lifecycle Manager按顺序逐个实现启动转换（``Configuring``和``Activating``）以及按相反顺序处理节点的关闭转换。因此，``sensor_driver``在其他导航服务器之前列出，以便导航服务器激活之前传感器数据可用。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:63
msgid "Two other parameters of the Lifecycle Manager are ``autostart`` and ``bond_timeout``. Set ``autostart`` to ``true`` if you want to set the transition nodes to the ``Active`` state on startup. Otherwise, you will need to manually trigger Lifecycle Manager to transition up the system. The ``bond_timeout`` sets the waiting time to decide when to transition down all of the nodes if a node is not responding."
msgstr "Lifecycle管理器的另外两个参数是``autostart``和``bond_timeout``。如果要在启动时将转换节点设置为``Active``状态，请将``autostart``设置为``true``。否则，您将需要手动触发Lifecycle管理器来进行系统转换。``bond_timeout``设置等待时间，以决定何时转换所有节点的状态，如果一个节点没有响应。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:66
msgid "More information on Lifecycle Manager parameters can be found in the `Configuration Guide of Lifecycle Manager <https://navigation.ros.org/configuration/packages/configuring-lifecycle.html>`_"
msgstr "有关Lifecycle Manager参数的更多信息，请参阅`Lifecycle Manager配置指南<https://navigation.ros.org/configuration/packages/configuring-lifecycle.html>`_。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:70
msgid "Composition"
msgstr "组合"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:72
msgid "Composition is the second key component nav2 task servers that was introduced to reduce the memory and CPU resources by putting multiple nodes in a single process. In Nav2, Composition can be used to compose all Nav2 nodes in a single process instead of launching them separately. This is useful for deployment on embedded systems where developers need to optimize resource usage."
msgstr "Composition 是 nav2 任务服务器的第二个关键组件，通过将多个节点放在单个进程中来减少内存和 CPU 资源的使用。在 Nav2 中，可以使用 Composition 将所有 Nav2 节点组合到单个进程中，而不是分别启动它们。这在嵌入式系统上部署时非常有用，开发人员需要优化资源使用情况。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:75
msgid "More information on Composition can be found `here <https://docs.ros.org/en/rolling/Tutorials/Intermediate/Composition.html>`_."
msgstr "有关组合的更多信息可以在`这里 <https://docs.ros.org/en/rolling/Tutorials/Intermediate/Composition.html>`_ 找到。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:77
msgid "In the following section, we give an example on how to add a new Nav2 server, which we notionally call the ``route_server``, to our system."
msgstr "在下一部分中，我们将给出一个示例，说明如何向我们的系统中添加一个新的 Nav2 服务器，我们暂时称之为 ``route_server``。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:80
msgid "We make use of the launch files to compose different servers into a single process. The process is established by the ``ComposableNodeContainer`` container that is populated with composition nodes via ``ComposableNode``. This container can then be launched and used the same as any other Nav2 node."
msgstr "我们使用启动文件将不同的服务器组合成一个单一进程。该进程由``ComposableNodeContainer``容器建立，通过``ComposableNode``添加组合节点。然后可以像其他Nav2节点一样启动和使用此容器。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:82
msgid "Add a new ``ComposableNode()`` instance in your launch file pointing to the component container of your choice."
msgstr "在您的 launch 文件中添加一个新的 ``ComposableNode()`` 实例，指向您选择的组件容器。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:101
msgid "See example in composition demo's `composition_demo.launch.py <https://github.com/ros2/demos/blob/master/composition/launch/composition_demo.launch.py>`_."
msgstr "请参考组合演示的示例`composition_demo.launch.py <https://github.com/ros2/demos/blob/master/composition/launch/composition_demo.launch.py>`_。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:103
msgid "Add the package containing the server to your ``package.xml`` file."
msgstr "将包含服务器的包添加到您的 ``package.xml`` 文件中。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:111
msgid "Error codes"
msgstr "错误代码"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:113
msgid "Your nav2 task server may also wish to return a 'error_code' in its action response (though not required). If there are semantically meaningful and actionable types of failures for your system, this is a systemic way to communicate those failures which may be automatically aggregated into the responses of the navigation system to your application."
msgstr "您的 nav2 任务服务器可能还希望在其操作响应中返回一个 'error_code'（尽管不是必需的）。如果对于您的系统而言有语义上有意义且可执行的失败类型，这是一种系统化的方式来传达这些失败，这些失败可能会自动聚合到导航系统对您的应用程序的响应中。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:115
msgid "It is important to note that error codes from 0-9999 are reserved for internal nav2 servers with each server offset by 100 while external servers start at 10000 and end at 65535. The table below shows the current servers along with the expected error code structure."
msgstr "需要注意的是，0-9999的错误代码保留给内部nav2服务器，每个服务器的偏移量为100，而外部服务器的错误代码从10000开始，到65535结束。下表显示了当前的服务器以及预期的错误代码结构。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:121
msgid "Server Name"
msgstr "服务器名称"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:121
msgid "Reserved"
msgstr "保留"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:121
msgid "RANGE"
msgstr "RANGE"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:123 ../../tutorials/docs/adding_a_nav2_task_server.rst:131 ../../tutorials/docs/adding_a_nav2_task_server.rst:139 ../../tutorials/docs/adding_a_nav2_task_server.rst:145
msgid "..."
msgstr "..."


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:123
msgid "NONE=0, UNKNOWN=1"
msgstr "NONE=0，UNKNOWN=1"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:123
msgid "2-99"
msgstr "2-99"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:125
msgid "`Controller Server`_"
msgstr "`控制器服务器`_"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:125
msgid "NONE=0, UNKNOWN=100"
msgstr "NONE=0，UNKNOWN=100"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:125
msgid "101-199"
msgstr "101-199"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:127
msgid "`Planner Server`_ (compute_path_to_pose)"
msgstr "`计划器服务器`_ (计算路径到姿态)"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:127
msgid "NONE=0, UNKNOWN=200"
msgstr "NONE=0，UNKNOWN=200"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:127
msgid "201-299"
msgstr "201-299"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:129
msgid "`Planner Server`_ (compute_path_through_poses)"
msgstr "`规划器服务器`_（计算路径通过姿态）"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:129
msgid "NONE=0, UNKNOWN=300"
msgstr "NONE=0, UNKNOWN=300"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:129
msgid "301-399"
msgstr "301-399"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:133
msgid "`Smoother Server`_"
msgstr "`平滑器服务器`_"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:133
msgid "NONE=0, UNKNOWN=500"
msgstr "NONE=0，UNKNOWN=500"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:133
msgid "501-599"
msgstr "501-599"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:135
msgid "`Waypoint Follower Server`_"
msgstr "`路径点跟随服务器`_"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:135
msgid "NONE=0, UNKNOWN=600"
msgstr "NONE=0, UNKNOWN=600"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:135
msgid "601-699"
msgstr "601-699"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:137
msgid "`Behavior Server`_"
msgstr "`行为服务器`_"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:137
msgid "NONE=0"
msgstr "NONE=0"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:137
msgid "701-799"
msgstr "701 - 799"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:141
msgid "Last Nav2 Server"
msgstr "上一个 Nav2 服务器"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:141
msgid "NONE=0, UNKNOWN=9900"
msgstr "NONE = 0，UNKNOWN = 9900"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:141
msgid "9901-9999"
msgstr "9901-9999"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:143
msgid "First External Server"
msgstr "第一个外部服务器"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:143
msgid "NONE=0, UNKNOWN=10000"
msgstr "NONE=0，UNKNOWN=10000"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:143
msgid "10001-10099"
msgstr "10001 - 10099"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:154
msgid "Error codes are attached to the response of the action message. An example can be seen below for the route server. Note that by convention we set the error code field within the message definition to ``error_code``."
msgstr "错误码附加在动作消息的响应中。下面是一个路由服务器的示例。请注意，根据约定，我们在消息定义中将错误码字段设置为 ``error_code``。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:180
msgid "As stated in the message, the priority order of the errors should match the message order, 0 is reserved for NONE and the first error code in the sequence is reserved for UNKNOWN. Since the the route server is a external server, the errors codes start at 10000 and go up to 10099."
msgstr "如消息中所述，错误的优先级顺序应与消息顺序匹配，0 保留为NONE，序列中的第一个错误代码保留为UNKNOWN。由于路由服务器是外部服务器，错误代码从10000开始，一直增加到10099。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:183
msgid "In order to propigate your server's error code to the rest of the system it must be added to the nav2_params.yaml file. The `error_code_id_names` inside of the BT Navigator define what error codes to look for on the blackboard by the server. The lowest error code of the sequence is then returned - whereas the code enums increase the higher up in the software stack - giving higher priority to lower-level failures."
msgstr "为了将服务器的错误代码传播到系统的其他部分，必须将其添加到nav2_params.yaml文件中。BT导航器中的`error_code_id_names`定义了服务器在黑板上要查找的错误代码。然后返回序列中最低的错误代码 - 而代码枚举会随着软件堆栈的增加而增加 - 为较低级别的故障提供更高的优先级。"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:196
msgid "Conclusion"
msgstr "结论"


#: ../../tutorials/docs/adding_a_nav2_task_server.rst:198
msgid "In this section of the guide, we have discussed Lifecycle Nodes, Composition and Error Codes which are new and important concepts in ROS 2. We also showed how to implement Lifecycle Nodes, Composition and Error Codes to your newly created nodes/servers with Nav2. These three concepts are helpful to efficiently run your system and therefore are encouraged to be used throughout Nav2."
msgstr "在本指南的这个部分中，我们讨论了ROS 2中的生命周期节点、组合和错误代码，这些是新的重要概念。我们还展示了如何将生命周期节点、组合和错误代码应用于使用Nav2创建的新节点/服务器。这三个概念有助于有效地运行您的系统，因此鼓励在Nav2中广泛使用它们。"


#: ../../tutorials/docs/adding_smoother.rst:4
msgid "Adding a Smoother to a BT"
msgstr "向BT添加平滑器"


#: ../../tutorials/docs/adding_smoother.rst:6 ../../tutorials/docs/camera_calibration.rst:6 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:6 ../../tutorials/docs/get_backtrace.rst:6 ../../tutorials/docs/get_profile.rst:7 ../../tutorials/docs/navigation2_dynamic_point_following.rst:6 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:6 ../../tutorials/docs/navigation2_with_keepout_filter.rst:6 ../../tutorials/docs/navigation2_with_slam.rst:6 ../../tutorials/docs/navigation2_with_speed_filter.rst:6 ../../tutorials/docs/navigation2_with_stvl.rst:6 ../../tutorials/docs/using_collision_monitor.rst:6 ../../tutorials/docs/using_groot.rst:10 ../../tutorials/docs/using_shim_controller.rst:7
msgid "`Overview`_"
msgstr "`概述`_"


#: ../../tutorials/docs/adding_smoother.rst:7 ../../tutorials/docs/camera_calibration.rst:7 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:7 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:7 ../../tutorials/docs/navigation2_with_keepout_filter.rst:7 ../../tutorials/docs/navigation2_with_slam.rst:7 ../../tutorials/docs/navigation2_with_speed_filter.rst:7 ../../tutorials/docs/using_collision_monitor.rst:7
msgid "`Requirements`_"
msgstr "`要求`_"


#: ../../tutorials/docs/adding_smoother.rst:8 ../../tutorials/docs/camera_calibration.rst:8 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:8 ../../tutorials/docs/navigation2_dynamic_point_following.rst:7 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:8 ../../tutorials/docs/navigation2_with_keepout_filter.rst:8 ../../tutorials/docs/navigation2_with_slam.rst:8 ../../tutorials/docs/navigation2_with_speed_filter.rst:8 ../../tutorials/docs/navigation2_with_stvl.rst:8
msgid "`Tutorial Steps`_"
msgstr "`教程步骤`_"


#: ../../tutorials/docs/adding_smoother.rst:15 ../../tutorials/docs/camera_calibration.rst:12 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:15 ../../tutorials/docs/get_backtrace.rst:14 ../../tutorials/docs/get_profile.rst:14 ../../tutorials/docs/navigation2_dynamic_point_following.rst:18 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:19 ../../tutorials/docs/navigation2_with_keepout_filter.rst:19 ../../tutorials/docs/navigation2_with_slam.rst:11 ../../tutorials/docs/navigation2_with_speed_filter.rst:19 ../../tutorials/docs/navigation2_with_stvl.rst:19 ../../tutorials/docs/using_collision_monitor.rst:16 ../../tutorials/docs/using_groot.rst:16 ../../tutorials/docs/using_shim_controller.rst:14
msgid "Overview"
msgstr "概述"


#: ../../tutorials/docs/adding_smoother.rst:17
msgid "This tutorial shows how to add a smoother to your behavior tree to smooth output paths from a path planner. Before completing this tutorials, completing :ref:`getting_started` is highly recommended especially if you are new to ROS and Nav2."
msgstr "本教程展示了如何向行为树添加平滑器，以平滑路径规划器的输出路径。在完成本教程之前，强烈建议先完成 :ref:`getting_started`，尤其是如果您对ROS和Nav2不熟悉的话。"


#: ../../tutorials/docs/adding_smoother.rst:21 ../../tutorials/docs/camera_calibration.rst:17 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:21 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:28 ../../tutorials/docs/navigation2_with_keepout_filter.rst:24 ../../tutorials/docs/navigation2_with_slam.rst:23 ../../tutorials/docs/navigation2_with_speed_filter.rst:24 ../../tutorials/docs/using_collision_monitor.rst:21
msgid "Requirements"
msgstr "要求"


#: ../../tutorials/docs/adding_smoother.rst:23
msgid "You must install Nav2, Turtlebot3. If you don't have them installed, please follow :ref:`getting_started`. You must also have a working behavior tree, such as those provided by the Nav2 BT Navigator package, for editing. You should also have a copy of the ``nav2_params.yaml`` file for your system to edit as well."
msgstr "您必须安装Nav2和Turtlebot3。如果您尚未安装它们，请参照：ref:`getting_started` 进行安装。您还必须拥有一个工作的行为树，例如Nav2 BT Navigator包提供的行为树，以供编辑。您还应该有一个 ``nav2_params.yaml`` 文件的副本，用于编辑您的系统。"


#: ../../tutorials/docs/adding_smoother.rst:29 ../../tutorials/docs/camera_calibration.rst:42 ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:26 ../../tutorials/docs/navigation2_dynamic_point_following.rst:49 ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:34 ../../tutorials/docs/navigation2_with_keepout_filter.rst:29 ../../tutorials/docs/navigation2_with_slam.rst:38 ../../tutorials/docs/navigation2_with_speed_filter.rst:29 ../../tutorials/docs/navigation2_with_stvl.rst:50
msgid "Tutorial Steps"
msgstr "`教程步骤`"


#: ../../tutorials/docs/adding_smoother.rst:32
msgid "0- Familiarization with the Smoother BT Node"
msgstr "0- 熟悉平滑器BT节点"


#: ../../tutorials/docs/adding_smoother.rst:34
msgid "The :ref:`bt_smooth_action` BT node is a behavior tree node that interacts with the smoother task server similar to that which you may expect to find for the planner or controller servers. It contains the action client to call the server and specifies its arguments and return types as BT ports. It too calls the server via an action interface that may be seperately interacted with via other servers and client library languages."
msgstr " :ref:`bt_smooth_action` BT节点是一个行为树节点，与规划器或控制器服务器类似地与平滑器任务服务器进行交互。它包含调用服务器的动作客户端，并将其参数和返回类型指定为BT端口。它也通过动作接口调用服务器，可以通过其他服务器和客户端库语言单独与之交互。"


#: ../../tutorials/docs/adding_smoother.rst:36
msgid "Please see the BT node's configuration page to familiarize yourself with all aspects, but the core ports to note are the ``unsmoothed_path`` input port and the ``smoothed_path`` output port. The first takes in a raw path from a planning algorithm and the latter will set the value of the smoothed output path post-smoothing. Other ports are available that fully implements the Smoother Server's action API."
msgstr "请参阅BT节点的配置页面，以熟悉所有方面，但要注意的核心端口是 ``unsmoothed_path`` 输入端口和 ``smoothed_path`` 输出端口。前者接收来自规划算法的原始路径，后者设置平滑后输出路径的值。还提供了其他端口，完全实现了平滑器服务器的操作API。"


#: ../../tutorials/docs/adding_smoother.rst:39
msgid "1- Specifying a Smoother Plugin"
msgstr "1- 指定平滑器插件"


#: ../../tutorials/docs/adding_smoother.rst:41
msgid "In order to use a smoother in your BT node, you must first configure the smoother server itself to contain the smoother plugins of interest. These plugins implement the specific algorithms that you would like to use."
msgstr "为了在BT节点中使用平滑器，首先必须配置平滑器服务器本身，以包含感兴趣的平滑器插件。这些插件实现了您想要使用的特定算法。"


#: ../../tutorials/docs/adding_smoother.rst:43
msgid "For each smoother plugin you would like to use, a name must be given to it (e.g. ``simple_smoother``, ``curvature_smoother``). This name is its ``smoother_id`` for other servers to interact with this algorithm from a request to the Smoother Server's action interface."
msgstr "对于每个您想使用的平滑器插件，必须为其指定一个名称（例如 ``simple_smoother``，``curvature_smoother``）。这个名称是其他服务器通过请求与平滑器服务器的动作接口交互时使用的 ``smoother_id``。"


#: ../../tutorials/docs/adding_smoother.rst:45
msgid "Under each name, the parameters for that particular algorithm must be specified along with the ``plugin`` name for pluginlib to load a given algorithm's library. An example configuration of 2 smoother plugins is shown below that could be used in the ``nav2_params.yaml`` for your robot."
msgstr "在每个名称下，必须指定特定算法的参数，以及用于加载给定算法库的 ``plugin`` 名称。下面显示了一个示例配置，其中包含两个平滑器插件，可用于您机器人的 ``nav2_params.yaml``。"


#: ../../tutorials/docs/adding_smoother.rst:65
msgid "2- Modifying your BT XML"
msgstr "2- 修改您的BT XML"


#: ../../tutorials/docs/adding_smoother.rst:67
msgid "Now that you have selected and configured the smoother server for your given plugin(s), it is time to use those smoother(s) in your behavior tree for navigation behavior. While there are many places / ways to use this in a BT, what is shown below is probably the most likely situation you would want to use the smoother in (to smooth a path returned by the path planner and then using that smoothed path for path tracking)."
msgstr "现在，您已经选择并配置了给定插件的平滑服务器，是时候在导航行为的行为树中使用这些平滑器了。虽然在BT中有许多使用平滑器的地方/方法，但下面显示的可能是您最有可能使用平滑器的情况（平滑路径规划返回的路径，然后使用平滑后的路径进行路径跟踪）。"


#: ../../tutorials/docs/adding_smoother.rst:69
msgid "Note: If you use only a single type of smoothing algorithm, there is no need to specify the ``smoother_id`` in the BT XML entry. Since there is only a single option, that will be used for any request that does not specifically request a smoother plugin. However, if you leverage multiple smoother plugins, you **must** populate the ``smoother_id`` XML port."
msgstr "注意：如果您只使用一种类型的平滑算法，则无需在BT XML条目中指定 ``smoother_id``。由于只有一个选项，对于未明确请求平滑器插件的任何请求，都将使用该选项。但是，如果您使用多个平滑器插件，则**必须**填充 ``smoother_id`` XML端口。"


#: ../../tutorials/docs/adding_smoother.rst:71
msgid "A given behavior tree will have a line:"
msgstr "给定的行为树将有一行："


#: ../../tutorials/docs/adding_smoother.rst:77
msgid "This line calls the planner server and return a path to the ``path`` blackboard variable in the behavior tree. We are  going to replace that line with the following to compute the path, smooth the path, and finally replace the ``path`` blackboard variable with the new smoothed path that the system will now interact with:"
msgstr "这行代码调用规划器服务器并将路径返回到行为树的 ``path`` 黑板变量中。我们将使用以下代码替换该行，以计算路径、平滑路径，并最后用新的平滑路径替换系统将要与之交互的 ``path`` 黑板变量："


#: ../../tutorials/docs/adding_smoother.rst:86
msgid "If you wish to have recoveries for the smoother error codes, such as triggering the system recoveries branch of a behavior tree:"
msgstr "如果您希望对平滑器错误代码进行恢复，例如触发行为树的系统恢复分支："


#: ../../tutorials/docs/adding_smoother.rst:96
msgid "And its as simple as that! You can now compile or use this behavior tree in your system and see that the plans are now smoothed and the controllers are now tracking this smoothed path. The image at the top of the tutorial shows the unsmoothed path from NavFn (red) and the smoothed path (black). Note the smoother approach to goal, turns, and transitions in the straight-line segments."
msgstr "就是这么简单！您现在可以在系统中编译或使用这个行为树，并观察到计划路径已经平滑，控制器现在正在跟踪这条平滑路径。教程顶部的图像显示了来自NavFn的未平滑路径（红色）和平滑路径（黑色）。请注意在直线段中朝目标、转弯和过渡方面的平滑性。"


#: ../../tutorials/docs/adding_smoother.rst:98
msgid "If you wish to see the difference, but not track the smoothed path, you may wish to remove the ``smoothed_path=\"{path}\"`` portion to compute the smoothed path, but not replace the original path with it. Instead, the topic ``/smoothed_path`` contains this information published by the smoother server for visualization or use by other parts of the system. You may also remap the smoothed path to another blackboard variable to interact with it in other parts of the behavior tree (e.g. ``smoothed_path=\"{smoothed_path}\"``)."
msgstr "如果您希望看到差异，但不跟踪平滑后的路径，您可能希望删除``smoothed_path=\"{path}\"``部分以计算平滑后的路径，但不用它替换原始路径。相反，主题``/smoothed_path``包含由平滑服务器发布的此信息，用于可视化或系统的其他部分使用。您还可以将平滑路径重新映射到另一个黑板变量，以在行为树的其他部分与其交互（例如``smoothed_path=\"{smoothed_path}\"``）。"


#: ../../tutorials/docs/camera_calibration.rst:4
msgid "Camera Calibration"
msgstr "相机校准"


#: ../../tutorials/docs/camera_calibration.rst:14
msgid "This tutorial shows how to obtain calibration parameters for monocular camera."
msgstr "本教程演示了如何获取单目相机的校准参数。"


#: ../../tutorials/docs/camera_calibration.rst:19
msgid "1- Install Camera Calibration Parser, Camera Info Manager and Launch Testing Ament Cmake using operating system’s package manager:"
msgstr "1- 使用操作系统的软件包管理器安装相机校准解析器、相机信息管理器和启动测试 Ament Cmake："


#: ../../tutorials/docs/camera_calibration.rst:21
msgid "``sudo apt install ros-<ros2-distro>-camera-calibration-parsers``"
msgstr "``sudo apt install ros-<ros2-distro>-camera-calibration-parsers``"


#: ../../tutorials/docs/camera_calibration.rst:23
msgid "``sudo apt install ros-<ros2-distro>-camera-info-manager``"
msgstr "``sudo apt install ros-<ros2-distro>-camera-info-manager``"


#: ../../tutorials/docs/camera_calibration.rst:25
msgid "``sudo apt install ros-<ros2-distro>-launch-testing-ament-cmake``"
msgstr "``sudo apt install ros-<ros2-distro>-launch-testing-ament-cmake``"


#: ../../tutorials/docs/camera_calibration.rst:28
msgid "2- Image Pipeline need to be built from source in your workspace with:"
msgstr "2- 需要从源代码在你的工作空间中构建图像处理管线："


#: ../../tutorials/docs/camera_calibration.rst:30
msgid "``git clone – b <ros2-distro> git@github.com:ros-perception/image_pipeline.git``"
msgstr "``git clone – b <ros2-distro> git@github.com:ros-perception/image_pipeline.git``"


#: ../../tutorials/docs/camera_calibration.rst:33
msgid "**Also, make sure you have the following:**"
msgstr "**另外，请确保你有以下内容：**"


#: ../../tutorials/docs/camera_calibration.rst:35
msgid "A large checkerboard with known dimensions. This tutorial uses a 7x9 checkerboard with 20mm squares. **Calibration uses the interior vertex points of the checkerboard, so an \"8x10\" board uses the interior vertex parameter \"7x9\" as in the example below.** The checkerboard with set dimensions can be downloaded from `here <https://calib.io/pages/camera-calibration-pattern-generator>`_."
msgstr "具有已知尺寸的大型棋盘。本教程使用一个边长为7x9、每个方格尺寸为20mm的棋盘。**校准使用棋盘的内部顶点，因此\"8x10\"棋盘使用下面示例中的内部顶点参数\"7x9\"。** 可以从`此处 <https://calib.io/pages/camera-calibration-pattern-generator>`_ 下载具有指定尺寸的棋盘。"


#: ../../tutorials/docs/camera_calibration.rst:36
msgid "A well-lit area clear of obstructions and other check board patterns"
msgstr "一个光线充足、没有遮挡物和其他棋盘图案的区域"


#: ../../tutorials/docs/camera_calibration.rst:38
msgid "A monocular camera publishing images over ROS"
msgstr "通过ROS发布图像的单目摄像头"


#: ../../tutorials/docs/camera_calibration.rst:44
msgid "1- Start a terminal in your GUI"
msgstr "1- 在图形用户界面中启动终端"


#: ../../tutorials/docs/camera_calibration.rst:46
msgid "2- Launch the ROS driver for your specific camera."
msgstr "2- 为您特定的摄像头启动ROS驱动程序。"


#: ../../tutorials/docs/camera_calibration.rst:48
msgid "3- Make sure camera is publishing images over ROS. This can be tested by running:"
msgstr "3- 确保相机通过ROS发布图像。可以通过运行以下命令进行测试："


#: ../../tutorials/docs/camera_calibration.rst:50
msgid "``ros2 topic list``"
msgstr "``ros2 topic list``"


#: ../../tutorials/docs/camera_calibration.rst:52
msgid "4- This will show you all the topics published make sure that there is an image_raw topic /camera/image_raw. To confirm that its a real topic and actually publishing check topic hz:"
msgstr "4- 这将显示所有发布的主题，请确保存在一个图像主题 /camera/image_raw。为确认其为真实主题并正在发布，请检查主题的频率："


#: ../../tutorials/docs/camera_calibration.rst:54
msgid "``ros2 topic hz /camera/image_raw``"
msgstr "``ros2 topic hz /camera/image_raw``"


#: ../../tutorials/docs/camera_calibration.rst:65
msgid "5- Start the camera calibration node"
msgstr "5- 启动相机标定节点"


#: ../../tutorials/docs/camera_calibration.rst:67
msgid "``ros2 run camera_calibration cameracalibrator --size 7x9 --square 0.02 --ros-args -r image:=/my_camera/image_raw -p camera:=/my_camera``"
msgstr "``ros2 run camera_calibration cameracalibrator --size 7x9 --square 0.02 --ros-args -r image:=/my_camera/image_raw -p camera:=/my_camera``"


#: ../../tutorials/docs/camera_calibration.rst:125
msgid "6- In order to get a good calibration you will need to move the checkerboard around in the camera frame such that:"
msgstr "6- 为了获得良好的标定结果，您需要在相机视野中移动棋盘格，使其满足以下要求："


#: ../../tutorials/docs/camera_calibration.rst:132
msgid "checkerboard on the camera's left, right, top and bottom of field of view"
msgstr "相机的左侧、右侧、顶部和底部的棋盘格视野"


#: ../../tutorials/docs/camera_calibration.rst:128
msgid "◦ X bar - left/right in field of view"
msgstr "◦ X 轴移动 - 在视野中左右移动"


#: ../../tutorials/docs/camera_calibration.rst:130
msgid "◦ Y bar - top/bottom in field of view"
msgstr "◦ Y bar - 视野顶部/底部"


#: ../../tutorials/docs/camera_calibration.rst:132
msgid "◦ Size bar - toward/away and tilt from the camera"
msgstr "◦ 大小调整 - 从相机方向上向前/向后倾斜"


#: ../../tutorials/docs/camera_calibration.rst:134
msgid "checkerboard filling the whole field of view"
msgstr "填满整个视野的棋盘格"


#: ../../tutorials/docs/camera_calibration.rst:135
msgid "checkerboard tilted to the left, right, top and bottom (Skew)"
msgstr "棋盘格向左、向右、向上和向下倾斜（倾斜度）"


#: ../../tutorials/docs/camera_calibration.rst:146
msgid "7- As the checkerboard is moved around the 4 bars on the calibration sidebar increases in length. When all then the 4 bars are green and enough data is available for calibration the CALIBRATE button will light up. Click it to see the results. It takes around the minute for calibration to take place."
msgstr "7- 当棋盘格在校准边栏上移动时，4个条形图的长度会增加。当所有4个条形图变为绿色且有足够的数据进行校准时，校准按钮将亮起。点击它查看结果。校准需要大约一分钟的时间。"


#: ../../tutorials/docs/camera_calibration.rst:160
msgid "8- After the calibration is completed the save and commit buttons light up. And you can also see the result in terminal."
msgstr "8- 完成校准后，保存和提交按钮会亮起。您也可以在终端中看到结果。"


#: ../../tutorials/docs/camera_calibration.rst:181
msgid "9-Press the save button to see the result. Data is saved to  \"/tmp/calibrationdata.tar.gz\""
msgstr "9- 点击保存按钮查看结果。数据将保存到\"/tmp/calibrationdata.tar.gz\""


#: ../../tutorials/docs/camera_calibration.rst:184
msgid "10-To use the the calibration file unzip the calibration.tar.gz"
msgstr "10- 要使用校准文件，需要解压缩calibration.tar.gz文件。"


#: ../../tutorials/docs/camera_calibration.rst:184
msgid "``tar -xvf calibration.tar.gz``"
msgstr "``tar -xvf calibration.tar.gz``"


#: ../../tutorials/docs/camera_calibration.rst:186
msgid "11-In the folder images used for calibration are available and also “**ost.yaml**” and “**ost.txt**”. You can use the yaml file which contains the calibration parameters as directed by the camera driver."
msgstr "11- 在用于校准的文件夹中，有可用的图像，还有“**ost.yaml**”和“**ost.txt**”文件。您可以按照相机驱动程序的指示使用包含校准参数的yaml文件。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:4
msgid "Filtering of Noise-Induced Obstacles"
msgstr "过滤噪声引起的障碍物"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:9
msgid "`How it works`_"
msgstr "`工作原理`_"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:17
msgid "Noisy sensor measurements can cause to errors in ``Voxel Layer`` or ``Obstacle Layer``. As a result, salt and pepper noise may appear on the costmap. This noise creates false obstacles that prevent the robot from finding the best path on the map. While the images above show both salt and pepper noise as well as error due to mislocalization, this layer will only remove sensor noise, not mislocalized artifacts misaligned with the static map. This tutorial shows how to configure filtering of false obstacles caused by noise. This functionality is provided by the ``DenoiseLayer`` costmap layer plugin which will be enabled and used in this document."
msgstr "嘈杂的传感器测量可能导致``Voxel Layer``或``Obstacle Layer``中的错误。结果是，在代价地图上可能出现椒盐噪声。这种噪声会产生虚假障碍物，阻止机器人在地图上找到最佳路径。尽管上面的图像显示了盐和胡椒噪声以及由于错误定位引起的错误，但此图层仅会去除传感器噪声，而不会去除与静态地图不对齐的错误定位伪影。本教程展示了如何配置用于过滤由噪声引起的虚假障碍物。这个功能由``DenoiseLayer``代价地图图层插件提供，将在本文档中启用和使用。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:23 ../../tutorials/docs/navigation2_with_keepout_filter.rst:26
msgid "It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made in :ref:`build-instructions`."
msgstr "假设已安装或本地构建了ROS 2、Gazebo和TurtleBot3软件包。请确保Nav2项目也在本地构建，就像在:ref:`build-instructions`中所述一样。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:29
msgid "1. Enable Denoise Layer"
msgstr "1. 启用去噪图层"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:31
msgid "Denoise Layer is Costmap2D plugin. You can enable the ``DenoiseLayer`` plugin in Costmap2D by adding ``denoise_layer`` to the ``plugins`` parameter in ``nav2_params.yaml``. You can place it in the ``global_costmap`` and (or) ``local_costmap`` to filter noise on a global or local map. The DenoiseLayer plugin should have the following parameter defined:"
msgstr "Denoise Layer是Costmap2D插件。您可以通过在``nav2_params.yaml``的``plugins``参数中添加``denoise_layer``来启用``DenoiseLayer``插件。您可以将其放置在``global_costmap``和/或``local_costmap``中以在全局或局部地图上过滤噪声。DenoiseLayer插件应定义以下参数："


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:33
msgid "``plugin``: type of plugin. In our case ``nav2_costmap_2d::DenoiseLayer``."
msgstr "``plugin``: 插件类型。在我们的情况下是 ``nav2_costmap_2d::DenoiseLayer``。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:35
msgid "Full list of parameters supported by ``DenoiseLayer`` are listed at :ref:`denoise` page."
msgstr "支持``DenoiseLayer``的完整参数列表列在 :ref:`denoise` 页面上。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:37
msgid "It is important to note that ``DenoiseLayer`` typically should be placed before the inflation layer. This is required to prevent inflation from noise-induced obstacles. Moreover, ``DenoiseLayer`` processes only obstacle information in the costmap. Values ``INSCRIBED_INFLATED_OBSTACLE``, ``LETHAL_OBSTACLE`` and optionally ``NO_INFORMATION`` will be interpreted as obstacle cell. Cells with any other values will be interpreted as ``FREE_SPACE`` when processed (won't be distorted in the cost map). If a cell with an obstacle is recognized as noise, it will be replaced by ``FREE_SPACE`` after processing."
msgstr "值得注意的是，通常应将 ``DenoiseLayer`` 放在膨胀图层之前。这是为了防止噪声引起的障碍物膨胀。此外，``DenoiseLayer`` 仅处理代价地图中的障碍物信息。``INSCRIBED_INFLATED_OBSTACLE``、``LETHAL_OBSTACLE``和可选的``NO_INFORMATION``将被解释为障碍物单元。在处理时，具有其他任何值的单元将被解释为``FREE_SPACE``（在代价地图中不会失真）。如果将障碍物单元识别为噪声，则在处理后将其替换为``FREE_SPACE``。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:44
msgid "To enable ``DenoiseLayer`` for both global and local costmaps, use the following configuration:"
msgstr "要为全局和局部代价地图同时启用``DenoiseLayer``，请使用以下配置："


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:70
msgid "The key to success in filtering noise is to understand its type and choose the right ``DenoiseLayer`` parameters. The default parameters are focused on fast removal of standalone obstacles. More formally, an obstacle is discarded if there are no obstacles among the adjacent eight cells. This should be sufficient in typical cases."
msgstr "在过滤噪声方面成功的关键是了解噪声的类型并选择正确的“DenoiseLayer”参数。默认参数专注于快速移除独立的障碍物。更正式地说，如果相邻的八个单元中没有障碍物，则会丢弃一个障碍物。这在典型情况下应该足够了。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:75
msgid "If some sensor generates intercorrelated noise-induced obstacles and small obstacles in the world are unlikely, small groups of obstacles can be removed. To configure the ``DenoiseLayer`` to such cases and understand how it works, refer to the section `How it works`_."
msgstr "如果某个传感器生成了相互关联的噪声引起的障碍物，并且世界上的小障碍物不太可能存在，可以删除小组障碍物。要配置``DenoiseLayer``以处理此类情况并了解其工作原理，请参阅``How it works``部分。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:79
msgid "Use this plugin to filter the global costmap with caution. It introduces potential performance issues. For example in case of typically-high-range lidars (20+ meters) update window can be massive making processing time unacceptably long. It is worth taking this into account as an application designer."
msgstr "谨慎使用此插件来过滤全局costmap，因为它可能引入潜在的性能问题。例如，在通常具有较高范围的激光雷达（20米以上）的情况下，更新窗口可能非常大，导致处理时间不可接受地长。作为应用程序设计者，考虑到这一点是值得的。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:84
msgid "2. Run Nav2 stack"
msgstr "2. 运行Nav2 stack"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:86
msgid "After Denoise Layer was enabled for global/local costmaps, run Nav2 stack as written in :ref:`getting_started`:"
msgstr "在为全局/局部costmap启用Denoise Layer后，按照:ref:`getting_started`中的指示运行Nav2 stack："


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:92
msgid "And check that filter is working properly: with the default parameters, no standalone obstacles should remain on the cost map. This can be checked, for example, in RViz main window displaying local and global costmaps after removing unnecessary particles (illustrated at the top of this tutorial)."
msgstr "并检查过滤器是否正常工作：使用默认参数，在代价地图上不应保留任何独立的障碍物。例如，可以在移除不必要的粒子后，在RViz主窗口中显示局部和全局代价地图来进行检查（如本教程顶部所示）。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:97
msgid "How it works"
msgstr "工作原理"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:99
msgid "The plugin is based on two algorithms."
msgstr "该插件基于两种算法。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:101
msgid "When parameter ``minimal_group_size`` = 2, the first algorithm turns on. It apply `erosion <https://docs.opencv.org/3.4/db/df6/tutorial_erosion_dilatation.html>`_ function with kernel from image below (left if ``group_connectivity_type`` = 4 or right if ``group_connectivity_type`` = 8) to the costmap. White color of the kernel pixel means to use the value, black means to ignore it."
msgstr "当参数“minimal_group_size”= 2时，第一个算法启动。它将`erosion <https://docs.opencv.org/3.4/db/df6/tutorial_erosion_dilatation.html>`_ 函数应用于下方图片中的内核（如果“group_connectivity_type”= 4，则使用左侧内核；如果“group_connectivity_type”= 8，则使用右侧内核），作用于costmap上。内核像素的白色表示使用该值，黑色表示忽略该值。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:108
msgid "As a result of erosion function the neighbors image is created. Each possible position of the kernel on the costmap corresponds to one pixel of the neighbors image. The pixel value of this image is equal to the maximum of 4/8 costmap pixels corresponding to the white pixels of the mask. In other words, the pixel of the neighbors image is equal to the obstacle code if there is an obstacle nearby, the free space code in other case. After that, obstacles corresponding to free space code on neighbors image are removed."
msgstr "通过腐蚀函数生成了邻居图像。内核在代价图上的每个可能位置对应于邻居图像的一个像素。该图像的像素值等于与掩码的白色像素对应的4/8个代价图像素的最大值。换句话说，如果附近有障碍物，则邻居图像的像素等于障碍物代码；否则为自由空间代码。然后，将邻居图像上对应自由空间代码的障碍物移除。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:112
msgid "This process is illustrated below. On the left side of the image is a costmap, on the right is a neighbors image. White pixels are free space, black pixels are obstacles, ``group_connectivity_type`` = 4. Obstacles marked at the end of the animation will be removed."
msgstr "该过程如下图所示。图像的左侧是costmap，右侧是邻居图像。白色像素表示自由空间，黑色像素表示障碍物，“group_connectivity_type”= 4。动画结束时标记的障碍物将被移除。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:118
msgid "When parameter ``minimal_group_size`` > 2, the second algorithm is executed. This is a generalized solution that allows you to remove groups of adjacent obstacles if their total number is less than ``minimal_group_size``. To select groups of adjacent obstacles, the algorithm performs their segmentation. The type of cell connectivity in one segment is determined by the parameter ``group_connectivity_type``. Next, the size of each segment is calculated. Obstacles segments with size less than the ``minimal_group_size`` are replaced with empty cells. This algorithm is about 10 times slower than first, so use it with caution and only when necessary. Its execution time depends on the size of the processed map fragment (and not depend on the value of ``minimal_group_size``)."
msgstr "当参数``minimal_group_size`` > 2时，执行第二种算法。这是一种通用解决方案，可以删除邻近障碍物组，如果它们的总数小于``minimal_group_size``。为了选择相邻障碍物组，算法执行它们的分割。一个段中的细胞连接类型由参数``group_connectivity_type``确定。然后计算每个段的大小。大小小于``minimal_group_size``的障碍物段将被替换为空细胞。该算法比第一种算法慢大约10倍，因此请谨慎使用，仅在必要时使用。它的执行时间取决于处理地图片段的大小（而不取决于``minimal_group_size``的值）。"


#: ../../tutorials/docs/filtering_of_noise-induced_obstacles.rst:127
msgid "This algorithm is illustrated in the animation below (``group_connectivity_type`` = 8). Obstacles marked at the end of the animation will be removed (groups that size less 3)."
msgstr "该算法如下动画所示（“group_connectivity_type”= 8）。动画结束时标记的障碍物将被移除（大小小于3的组）。"


#: ../../tutorials/docs/get_backtrace.rst:4
msgid "Get Backtrace in ROS 2 / Nav2"
msgstr "在ROS 2 / Nav2中获取回溯"


#: ../../tutorials/docs/get_backtrace.rst:7 ../../tutorials/docs/get_profile.rst:8
msgid "`Preliminaries`_"
msgstr "`准备工作`_"


#: ../../tutorials/docs/get_backtrace.rst:8
msgid "`From a Node`_"
msgstr "`从节点`_"


#: ../../tutorials/docs/get_backtrace.rst:9
msgid "`From a Launch File`_"
msgstr "`来自启动文件`_"


#: ../../tutorials/docs/get_backtrace.rst:10 ../../tutorials/docs/get_profile.rst:11
msgid "`From Nav2 Bringup`_"
msgstr "`从Nav2启动`_"


#: ../../tutorials/docs/get_backtrace.rst:11
msgid "`Automatic backtrace on crash`_"
msgstr "`崩溃时自动回溯`_"


#: ../../tutorials/docs/get_backtrace.rst:16
msgid "This document explains one set of methods for getting backtraces for ROS 2 and Nav2. There are many ways to accomplish this, but this is a good starting point for new C++ developers without GDB experience."
msgstr "本文档介绍了在ROS 2和Nav2中获取回溯的一组方法。有许多实现此目标的方法，但对于没有GDB经验的新C++开发人员来说，这是一个很好的起点。"


#: ../../tutorials/docs/get_backtrace.rst:19
msgid "The following steps show ROS 2 users how to modify the Nav2 stack to get traces from specific servers when they encounter a problem. This tutorial applies to both simulated and physical robots."
msgstr "以下步骤向ROS 2用户展示如何修改Nav2堆栈，以便在遇到问题时从特定服务器获取跟踪信息。本教程适用于仿真和物理机器人。"


#: ../../tutorials/docs/get_backtrace.rst:22
msgid "This will cover how to get a backtrace from a specific node using ``ros2 run``, from a launch file representing a single node using ``ros2 launch``, and from a more complex orchestration of nodes. By the end of this tutorial, you should be able to get a backtrace when you notice a server crashing in ROS 2."
msgstr "本教程将介绍如何使用``ros2 run``从特定节点获取回溯信息，如何使用代表单个节点的启动文件``ros2 launch``，以及如何从更复杂的节点编排中获取回溯信息。通过完成本教程，您应该能够在注意到ROS 2中的服务器崩溃时获取回溯信息。"


#: ../../tutorials/docs/get_backtrace.rst:26 ../../tutorials/docs/get_profile.rst:21
msgid "Preliminaries"
msgstr "准备工作"


#: ../../tutorials/docs/get_backtrace.rst:28
msgid "GDB is the most popular debugger for C++ on Unix systems. It can be used to determine the reason for a crash and track threads. It may also be used to add breakpoints in your code to check values in memory a particular points in your software."
msgstr "GDB是Unix系统上最流行的C++调试器。它可用于确定崩溃的原因并跟踪线程。它还可以在代码中添加断点，以便在软件中特定位置检查内存中的值。"


#: ../../tutorials/docs/get_backtrace.rst:32
msgid "Using GDB is a critical skill for all software developers working on C/C++. Many IDEs will have some kind of debugger or profiler built in, but with ROS, there are few IDEs to choose. Therefore it's important to understand how to use these raw tools you have available rather than relying on an IDE to provide them. Further, understanding these tools is a fundamental skill of C/C++ development and leaving it up to your IDE can be problematic if you change roles and no longer have access to it or are doing development on the fly through an ssh session to a remote asset."
msgstr "使用GDB是所有在C/C++上工作的软件开发人员的关键技能。许多集成开发环境（IDE）都内置了一些调试器或性能分析工具，但是在ROS中，可供选择的IDE很少。因此，重要的是了解如何使用这些可用的原始工具，而不是依赖IDE来提供它们。此外，了解这些工具是C/C++开发的基本技能，如果您改变角色并且不再可以访问IDE，或者通过ssh会话到远程资源进行开发，依赖IDE可能会带来问题。"


#: ../../tutorials/docs/get_backtrace.rst:37
msgid "Using GDB luckily is fairly simple after you have the basics under your belt. The first step is to add ``-g`` to your compiler flags for the ROS package you want to profile / debug. This flag builds debug symbols that GDB and valgrind can read to tell you specific lines of code in your project are failing and why. If you do not set this flag, you can still get backtraces but it will not provide line numbers for failures. Be sure to remove this flag after debugging, it will slow down performance at run-time."
msgstr "幸运的是，一旦掌握了基础知识，使用GDB相当简单。第一步是在要分析/调试的ROS软件包的编译器标志中添加``-g``。此标志会构建调试符号，供GDB和valgrind读取，以告诉您项目中的具体代码行失败的原因。如果不设置此标志，仍然可以获取回溯信息，但不会提供失败的行号。在调试完成后，务必删除此标志，否则会降低运行时性能。"


#: ../../tutorials/docs/get_backtrace.rst:43
msgid "Adding the following line to your ``CMakeLists.txt`` for your project should do the trick. If your project already has a ``add_compile_options()``, you can simply add ``-g`` to it. Then simply rebuild your workspace with this package ``colcon build --packages-select <package-name>``. It may take a little longer than usual to compile."
msgstr "将以下行添加到项目的``CMakeLists.txt``文件中应该就可以解决问题。如果您的项目已经有一个``add_compile_options()``，您只需添加``-g``即可。然后使用此包重新构建工作空间``colcon build --packages-select <package-name>``。编译过程可能比平常稍长一些。"


#: ../../tutorials/docs/get_backtrace.rst:52
msgid "Now you're ready to debug your code! If this was a non-ROS project, at this point you might do something like below. Here we're launching a GDB session and telling our program to immediately run. Once your program crashes, it will return a gdb session prompt denoted by ``(gdb)``. At this prompt you can access the information you're interested in. However, since this is a ROS project with lots of node configurations and other things going on, this isn't a great option for beginners or those that don't like tons of commandline work and understanding the filesystem."
msgstr "现在，您已经准备好调试代码了！如果这是一个非ROS项目，此时您可能会执行以下操作。这里我们启动了一个GDB会话，并告诉我们的程序立即运行。一旦程序崩溃，它将返回一个以 ``(gdb)`` 标识的gdb会话提示符。在此提示符下，您可以访问您感兴趣的信息。然而，由于这是一个涉及大量节点配置和其他操作的ROS项目，对于初学者或不喜欢大量命令行操作和理解文件系统的人来说，这不是一个很好的选择。"


#: ../../tutorials/docs/get_backtrace.rst:63
msgid "Below are sections to describe the 3 major situations you could run into with ROS 2-based systems. Read the section that best describes the problem you're attempting to solve."
msgstr "下面是描述使用基于ROS 2的系统可能遇到的三种主要情况的部分。请阅读最能描述你尝试解决的问题的部分。"


#: ../../tutorials/docs/get_backtrace.rst:67
msgid "From a Node"
msgstr "从一个节点开始"


#: ../../tutorials/docs/get_backtrace.rst:69
msgid "Just as in our non-ROS example, we need to setup a GDB session before launching our ROS 2 node. While we could set this up through the commandline with some knowledge of the ROS 2 file system, we can instead use the launch ``--prefix`` option the kind folks at Open Robotics provided for us."
msgstr "就像在我们的非ROS示例中一样，我们需要在启动ROS 2节点之前设置一个GDB会话。虽然我们可以通过命令行和对ROS 2文件系统的一些了解来设置这个会话，但我们可以使用Open Robotics提供的launch ``--prefix``选项。"


#: ../../tutorials/docs/get_backtrace.rst:72
msgid "``--prefix`` will execute some bits of code before our ``ros2`` command allowing us to insert some information. If you attempted to do ``gdb ex run --args ros2 run <pkg> <node>`` as analog to our example in the preliminaries, you'd find that it couldn't find the ``ros2`` command. If you're even more clever, you'd find that trying to source your workspace would also fail for similar reasons."
msgstr "``--prefix``将在我们的``ros2``命令之前执行一些代码，以便插入一些信息。如果您尝试执行类似于我们在前言中的示例的``gdb ex run --args ros2 run <pkg> <node>``，您会发现它找不到``ros2``命令。如果您更聪明一些，您会发现尝试源化您的工作空间也会因类似的原因而失败。"


#: ../../tutorials/docs/get_backtrace.rst:76
msgid "Rather than having to revert to finding the install path of the executable and typing it all out, we can instead use ``--prefix``. This allows us to use the same ``ros2 run`` syntax you're used to without having to worry about some of the GDB details."
msgstr "我们不必回到查找可执行文件的安装路径并将其全部输入的状态，而可以使用``--prefix``。这样我们就可以使用你熟悉的``ros2 run``语法，而不必担心一些GDB的细节。"


#: ../../tutorials/docs/get_backtrace.rst:83
msgid "Just as before, this prefix will launch a GDB session and run the node you requested with all the additional commandline arguments. You should now have your node running and should be chugging along with some debug printing."
msgstr "与之前一样，此前缀将启动一个GDB会话，并使用所有附加的命令行参数运行您请求的节点。现在，您的节点应该正在运行，并且应该带有一些调试输出。"


#: ../../tutorials/docs/get_backtrace.rst:86
msgid "Once your server crashes, you'll see a prompt like below. At this point you can now get a backtrace."
msgstr "一旦你的服务器崩溃，你会看到下面这样的提示。此时你现在可以获得一个回溯。"


#: ../../tutorials/docs/get_backtrace.rst:92
msgid "In this session, type ``backtrace`` and it will provide you with a backtrace. Copy this for your needs. For example:"
msgstr "在这个会话中，输入``backtrace``，它会为您提供一个回溯。根据您的需要进行复制。例如："


#: ../../tutorials/docs/get_backtrace.rst:115
msgid "In this example you should read this in the following way, starting at the bottom:"
msgstr "在这个例子中，你应该按以下方式阅读，从底部开始："


#: ../../tutorials/docs/get_backtrace.rst:117
msgid "In the main function, on line 25 we call a function VectorCrash."
msgstr "在主函数中，第25行我们调用了一个名为VectorCrash的函数。"


#: ../../tutorials/docs/get_backtrace.rst:119
msgid "In VectorCrash, on line 44, we crashed in the Vector's ``at()`` method with input ``100``."
msgstr "在VectorCrash中，第44行，我们在Vector的``at()``方法中以输入``100``崩溃。"


#: ../../tutorials/docs/get_backtrace.rst:121
msgid "It crashed in ``at()`` on STL vector line 1091 after throwing an exception from a range check failure."
msgstr "在STL向量的第1091行的``at()``函数中发生了崩溃，并在范围检查失败后抛出了异常。"


#: ../../tutorials/docs/get_backtrace.rst:123 ../../tutorials/docs/get_backtrace.rst:168 ../../tutorials/docs/get_backtrace.rst:217 ../../tutorials/docs/get_backtrace.rst:246
msgid "These traces take some time to get used to reading, but in general, start at the bottom and follow it up the stack until you see the line it crashed on. Then you can deduce why it crashed. When you are done with GDB, type ``quit`` and it will exit the session and kill any processes still up. It may ask you if you want to kill some threads at the end, say yes."
msgstr "这些追踪需要一些时间来适应阅读，但一般来说，从底部开始，沿着堆栈向上查看，直到看到崩溃的那一行。然后你可以推断出为什么会崩溃。当你完成GDB操作后，输入``quit``，它将退出会话并关闭任何仍在运行的进程。最后可能会询问是否要终止一些线程，选择是。"


#: ../../tutorials/docs/get_backtrace.rst:129
msgid "From a Launch File"
msgstr "从启动文件"


#: ../../tutorials/docs/get_backtrace.rst:131
msgid "Just as in our non-ROS example, we need to setup a GDB session before launching our ROS 2 launch file. While we could set this up through the commandline, we can instead make use of the same mechanics that we did in the ``ros2 run`` node example, now using a launch file."
msgstr "与我们非ROS示例一样，在启动ROS 2启动文件之前，我们需要设置一个GDB会话。虽然我们可以通过命令行设置，但我们可以利用与``ros2 run``节点示例中相同的机制来实现，现在使用一个启动文件。"


#: ../../tutorials/docs/get_backtrace.rst:134
msgid "In your launch file, find the node that you're interested in debugging. For this section, we assume that your launch file contains only a single node (and potentially other information as well). The ``Node`` function used in the ``launch_ros`` package will take in a field ``prefix`` taking a list of prefix arguments. We will insert the GDB snippet here with one change from our node example, use of ``xterm``. ``xterm`` will pop up a new terminal window to show and interact with GDB. We do this because of issues handling ``stdin`` on launch files (e.g. if you hit control+C, are you talking to GDB or launch?). See `this ticket <https://github.com/ros2/launch_ros/issues/165>`_ for more information. See below for an example debugging SLAM Toolbox."
msgstr "在您的启动文件中，找到您想要调试的节点。在本节中，我们假设您的启动文件只包含一个单独的节点（以及其他可能的信息）。``launch_ros``包中使用的``Node``函数将接受一个名为``prefix``的字段，它需要一个前缀参数的列表。我们将在此处插入包含 GDB 代码片段的示例，与我们的节点示例相比有一个变化，即使用``xterm``。``xterm``将弹出一个新的终端窗口，用于显示和与 GDB 交互。我们之所以这样做，是因为处理启动文件上的``stdin``存在问题（例如，如果您按下Ctrl+C，您是在与GDB 还是启动进行交互？）。有关更多信息，请参阅`此票证<https://github.com/ros2/launch_ros/issues/165>`_。以下是一个关于调试 SLAM 工具箱的示例："


#: ../../tutorials/docs/get_backtrace.rst:156
msgid "Just as before, this prefix will launch a GDB session, now in ``xterm`` and run the launch file you requested with all the additional launch arguments defined."
msgstr "与之前一样，此前缀将启动一个GDB会话，现在使用``xterm``并运行您请求的启动文件以及所有定义的附加启动参数。"


#: ../../tutorials/docs/get_backtrace.rst:158
msgid "Once your server crashes, you'll see a prompt like below, now in the ``xterm`` session. At this point you can now get a backtrace."
msgstr "一旦服务器崩溃，您会在``xterm``会话中看到如下提示。此时，您可以获取一个回溯。"


#: ../../tutorials/docs/get_backtrace.rst:164 ../../tutorials/docs/get_backtrace.rst:213 ../../tutorials/docs/get_backtrace.rst:242
msgid "In this session, type ``backtrace`` and it will provide you with a backtrace. Copy this for your needs. See the example trace in the section above for an example."
msgstr "在此会话中，键入``backtrace``，它将为您提供一个回溯。根据您的需求进行复制。请参考上面的示例跟踪。"


#: ../../tutorials/docs/get_backtrace.rst:174
msgid "From Large Project"
msgstr "从大型项目"


#: ../../tutorials/docs/get_backtrace.rst:176
msgid "Working with launch files with multiple nodes is a little different so you can interact with your GDB session without being bogged down by other logging in the same terminal. For this reason, when working with larger launch files, its good to pull out the specific server you're interested in and launching it seperately. These instructions are targeting Nav2, but are applicable to any large project with many nodes of any type in a series of launch file(s)."
msgstr "使用包含多个节点的启动文件的工作方式有所不同，这样您就可以在同一个终端中进行GDB会话而不受其他日志的干扰。因此，在使用较大的启动文件时，最好将您感兴趣的特定服务器提取出来并单独启动。这些说明针对Nav2，但适用于任何具有多个节点类型的大型项目的一系列启动文件。"


#: ../../tutorials/docs/get_backtrace.rst:180
msgid "As such, for this case, when you see a crash you'd like to investigate, its beneficial to separate this server from the others."
msgstr "因此，在这种情况下，当您遇到需要调查的崩溃时，最好将此服务器与其他服务器分开。"


#: ../../tutorials/docs/get_backtrace.rst:182
msgid "If your server of interest is being launched from a nested launch file (e.g. an included launch file) you may want to do the following:"
msgstr "如果您感兴趣的服务器是从嵌套的启动文件（例如，一个包含的启动文件）启动的，您可能需要执行以下操作："


#: ../../tutorials/docs/get_backtrace.rst:184
msgid "Comment out the launch file inclusion from the parent launch file"
msgstr "将父启动文件中的启动文件包含部分注释掉。"


#: ../../tutorials/docs/get_backtrace.rst:186 ../../tutorials/docs/get_backtrace.rst:196
msgid "Recompile the package of interest with ``-g`` flag for debug symbols"
msgstr "使用``-g``标志为调试符号重新编译感兴趣的软件包。"


#: ../../tutorials/docs/get_backtrace.rst:188 ../../tutorials/docs/get_backtrace.rst:198
msgid "Launch the parent launch file in a terminal"
msgstr "在终端中启动父启动文件。"


#: ../../tutorials/docs/get_backtrace.rst:190
msgid "Launch the server's launch file in another terminal following the instructions in `From a Launch File`_."
msgstr "在另一个终端中按照`从启动文件启动`_中的说明启动服务器的启动文件。"


#: ../../tutorials/docs/get_backtrace.rst:192
msgid "Alternatively, if you server of interest is being launched in these files directly (e.g. you see a ``Node``, ``LifecycleNode``, or inside a ``ComponentContainer``), you will need to seperate this from the others:"
msgstr "或者，如果您感兴趣的服务器是直接在这些文件中启动的（例如，您看到一个``Node``、``LifecycleNode``或者在``ComponentContainer``内部），您需要将其与其他服务器分开："


#: ../../tutorials/docs/get_backtrace.rst:194
msgid "Comment out the node's inclusion from the parent launch file"
msgstr "将节点在父启动文件中注释掉"


#: ../../tutorials/docs/get_backtrace.rst:200
msgid "Launch the server's node in another terminal following the instructions in `From a Node`_."
msgstr "按照`从节点启动`_中的说明，在另一个终端中启动服务器的节点。"


#: ../../tutorials/docs/get_backtrace.rst:203
msgid "Note that in this case, you may need to remap or provide parameter files to this node if it was previously provided by the launch file. Using ``--ros-args`` you can give it the path to the new parameters file, remaps, or names. See `this ROS 2 tutorial <https://docs.ros.org/en/rolling/Guides/Node-arguments.html>`_ for the commandline arguments required."
msgstr "请注意，如果该节点以前是由启动文件提供的，您可能需要重新映射或提供参数文件给该节点。使用 ``--ros-args`` 您可以给它提供新参数文件、重映射或名称的路径。有关所需的命令行参数，请参阅 `ROS 2 教程 <https://docs.ros.org/en/rolling/Guides/Node-arguments.html>`_。"


#: ../../tutorials/docs/get_backtrace.rst:205
msgid "We understand this can be a pain, so it might encourage you to rather have each node possible as a separately included launch file to make debugging easier. An example set of arguments might be ``--ros-args -r __node:=<node_name> --params-file /absolute/path/to/params.yaml`` (as a template)."
msgstr "我们理解这可能会让您感到困扰，所以您可能更倾向于将每个可能的节点作为单独的启动文件进行包含，以便更容易进行调试。一个示例的参数集合可能是``--ros-args -r __node:=<node_name> --params-file /absolute/path/to/params.yaml``（作为模板）。"


#: ../../tutorials/docs/get_backtrace.rst:207
msgid "Once your server crashes, you'll see a prompt like below in the specific server's terminal. At this point you can now get a backtrace."
msgstr "一旦服务器崩溃，您将在特定服务器的终端中看到如下提示。此时，您可以获取回溯信息。"


#: ../../tutorials/docs/get_backtrace.rst:223 ../../tutorials/docs/get_profile.rst:106
msgid "From Nav2 Bringup"
msgstr "来自Nav2 Bringup"


#: ../../tutorials/docs/get_backtrace.rst:225
msgid "To debug directly from the nav2 bringup launch files you may want to do the following:"
msgstr "要直接从 nav2 的启动文件中进行调试，您可以执行以下操作："


#: ../../tutorials/docs/get_backtrace.rst:227
msgid "Add ``prefix=['xterm -e gdb -ex run --args']`` to the non-composed node in the appropriate launch file."
msgstr "在适当的启动文件中，将``prefix=['xterm -e gdb -ex run --args']``添加到非组合节点中。"


#: ../../tutorials/docs/get_backtrace.rst:229
msgid "Recompile the package of interest with ``-g`` flag for debug symbols."
msgstr "使用 ``-g`` 标志重新编译要调试的软件包以获取调试符号。"


#: ../../tutorials/docs/get_backtrace.rst:231
msgid "Launch normally with ``ros2 launch nav2_bringup tb3_simulation_launch.py use_composition:=False``. A seperate xterm window will open with the proccess of intrest running in gdb."
msgstr "使用``ros2 launch nav2_bringup tb3_simulation_launch.py use_composition:=False``正常启动。一个单独的 xterm 窗口将打开，其中运行着感兴趣的进程。"


#: ../../tutorials/docs/get_backtrace.rst:234
msgid "Turning off composition has serious performance impacts. If this is important to you please follow \"From Large Project\"."
msgstr "关闭组合会严重影响性能。如果这对您很重要，请参考\"从大型项目\"。"


#: ../../tutorials/docs/get_backtrace.rst:236
msgid "Once your server crashes, you'll see a prompt like below in the xterm window. At this point you can now get a backtrace."
msgstr "一旦服务器崩溃，您将在 xterm 窗口中看到如下提示。此时，您现在可以获取回溯。"


#: ../../tutorials/docs/get_backtrace.rst:252
msgid "Automatic backtrace on crash"
msgstr "崩溃时自动获取回溯信息"


#: ../../tutorials/docs/get_backtrace.rst:254
msgid "The `backward-cpp <https://github.com/bombela/backward-cpp>`_ library provides beautiful stack traces, and the `backward_ros <https://github.com/pal-robotics/backward_ros/tree/foxy-devel>`_ wrapper simplifies its integration."
msgstr "``backward-cpp <https://github.com/bombela/backward-cpp>``库提供了美观的堆栈跟踪，而``backward_ros <https://github.com/pal-robotics/backward_ros/tree/foxy-devel>``包装器简化了其集成。"


#: ../../tutorials/docs/get_backtrace.rst:256
msgid "Just add it as a dependency and `find_package` it in your CMakeLists and the backward libraries will be injected in all your executables and libraries."
msgstr "只需将其作为依赖项添加，并在您的CMakeLists中使用`find_package`，然后后向库将被注入到所有可执行文件和库中。"


#: ../../tutorials/docs/get_profile.rst:4
msgid "Profiling in ROS 2 / Nav2"
msgstr "在 ROS 2 / Nav2 中进行性能分析"


#: ../../tutorials/docs/get_profile.rst:9
msgid "`Profile from a Node`_"
msgstr "`来自节点的配置文件`_"


#: ../../tutorials/docs/get_profile.rst:10
msgid "`Profile from a Launch File`_"
msgstr "从启动文件进行性能分析_"


#: ../../tutorials/docs/get_profile.rst:16
msgid "This document explains one method for profiling applications in ROS 2 / Nav2. The aim of profiling is to generate files that can be analyzed to see where compute time and resources are spent during the execution of a program. This can be useful to determine where the bottlenecks in your program exist and where things might be able to be improved."
msgstr "本文档介绍了在ROS 2 / Nav2中对应用程序进行分析的一种方法。分析的目的是生成可以分析的文件，以查看程序执行过程中计算时间和资源的使用情况。这对于确定程序中的瓶颈所在以及可能需要改进的地方非常有用。"


#: ../../tutorials/docs/get_profile.rst:18
msgid "The following steps show ROS 2 users how to modify the Nav2 stack to get profiling information about a particular server / algorithm when they encounter a situation they'd like to understand better. This tutorial applies to both simulated and physical robots."
msgstr "以下步骤向 ROS 2 用户展示如何修改 Nav2 栈以获取关于特定服务器/算法的性能分析信息，以便更好地理解他们遇到的情况。本教程适用于仿真和物理机器人。"


#: ../../tutorials/docs/get_profile.rst:23
msgid "This tutorial makes use of two tools, callgrind from the ``Valgrind`` set of tools and ``kcachegrind``. Valgrind is used to get the profiling information about the program and kcachegrind is the visualization engine used to interprete this information to do useful work."
msgstr "本教程使用了两个工具，即``Valgrind``工具集中的callgrind和``kcachegrind``。Valgrind用于获取程序的分析信息，而kcachegrind则是用于解释这些信息并进行有用工作的可视化引擎。"


#: ../../tutorials/docs/get_profile.rst:25
msgid "Thus, we must install them."
msgstr "因此，我们必须安装它们。"


#: ../../tutorials/docs/get_profile.rst:31
msgid "More information can be found in the `Valgrind manual <https://valgrind.org/docs/manual/cl-manual.html>`_ including additional valgrind arguments that can be used to specify more information."
msgstr "有关更多信息，请参阅`Valgrind手册<https://valgrind.org/docs/manual/cl-manual.html>`_，其中包括可以用于指定更多信息的其他valgrind参数。"


#: ../../tutorials/docs/get_profile.rst:33
msgid "Generally speaking, to use valgrind we need to compile with debugging information. This can be done by passing ``-g`` as a compiling option or compile ``CMAKE_BUILD_TYPE`` as ``Debug`` or ``RelWithDebInfo``. Then, we run our program using valgrind to capture the run-time statistics for later analysis. These are stored in ``callgrind.out.XXX`` files, where the suffix is the PID of the process. kcachegrind is used to visualize and analyze the results of the program execution."
msgstr "一般而言，要使用Valgrind，我们需要在编译时加入调试信息。可以通过将``-g``作为编译选项传递或将``CMAKE_BUILD_TYPE``设置为``Debug``或``RelWithDebInfo``来完成。然后，我们使用Valgrind运行程序，以便捕获运行时统计信息以供后续分析。这些信息存储在名为``callgrind.out.XXX``的文件中，其中后缀是进程的PID。使用kcachegrind可视化和分析程序执行的结果。"


#: ../../tutorials/docs/get_profile.rst:51
msgid "Profile from a Node"
msgstr "来自节点的配置文件"


#: ../../tutorials/docs/get_profile.rst:53
msgid "As in our generic example, for a given node, we need to compile with debug flags to capture the information for profiling with Valgrind. This can be done easily from the commandline. Note that we use ``--packages-select`` to only compile with this flag for the packages we want to profile nodes within."
msgstr "与我们的通用示例一样，对于给定的节点，我们需要使用调试标志进行编译，以便捕获用于使用Valgrind进行分析的信息。这可以很容易地通过命令行完成。请注意，我们使用``--packages-select``仅对我们想要在节点内进行分析的软件包使用此标志进行编译。"


#: ../../tutorials/docs/get_profile.rst:59
msgid "Optionally, you may add the following line to the ``CMakeLists.txt`` of the package you're looking to profile. This may be preferable when you have a workspace with many packages but would like to only compile a subset with debug information using a single ``colcon build`` invokation."
msgstr "可选地，您可以将以下行添加到要分析的软件包的``CMakeLists.txt``中。当您有一个包含许多软件包的工作空间，但只想使用单个``colcon build``调用编译带有调试信息的子集时，这可能更可取。"


#: ../../tutorials/docs/get_profile.rst:61
msgid "It is important that this should be added to both the host server and plugin packages(s) if you would like the results of a plugin's run-time profile."
msgstr "如果您想要插件的运行时分析结果，这一点对主机服务器和插件软件包都很重要。"


#: ../../tutorials/docs/get_profile.rst:67
msgid "After either compiling method, this node should be run in its own terminal to isolate it from the rest of your system. Thus, this should not be composed in the same process as other nodes. To run a ROS 2 node with valgrind, this can be done from the commandline via:"
msgstr "在编译完任一种方法后，应该在独立的终端中运行此节点，以使其与系统的其他部分隔离开来。因此，不应该在与其他节点相同的进程中组合使用。要使用valgrind运行ROS 2节点，可以通过以下命令行完成："


#: ../../tutorials/docs/get_profile.rst:73
msgid "An example of this might be used for profiling the controller server with a particular controller plugin loaded. Both ``nav2_controller`` and the plugin package of interest are compiled with debug flags. In the example below, we are running a ROS 2 node with remapped topics and a path to its parameter file:"
msgstr "一个例子是使用特定的控制器插件加载对控制器服务器进行分析。``nav2_controller``和所需的插件软件包都使用调试标志进行编译。在下面的示例中，我们正在运行一个具有重新映射主题和参数文件路径的ROS 2节点："


#: ../../tutorials/docs/get_profile.rst:79 ../../tutorials/docs/get_profile.rst:103
msgid "Once sufficient data has been collected, cleanly exit the process with Control+C."
msgstr "在收集足够的数据后，使用Control+C干净地退出进程。"


#: ../../tutorials/docs/get_profile.rst:82
msgid "Profile from a Launch File"
msgstr "从启动文件中进行分析"


#: ../../tutorials/docs/get_profile.rst:84
msgid "Just as in the Node example, we must also compile with debug flags when profiling a node from launch. We can complete the same valgrind call as from the commandline as within a launch file using launch prefixes."
msgstr "与节点示例中一样，当从launch文件对节点进行性能分析时，我们还必须使用调试标志进行编译。我们可以使用与命令行相同的valgrind调用方式，也可以在launch文件中使用launch前缀完成。"


#: ../../tutorials/docs/get_profile.rst:86
msgid "As our example before, this is how we'd launch the ``controller_server`` node from inside a launch file."
msgstr "与我们之前的示例一样，这是我们如何在启动文件中启动``controller_server``节点。"


#: ../../tutorials/docs/get_profile.rst:101
msgid "Note that just like before, we should isolate this process from others. So this should not be run with any other nodes in this launch file nor use node composition when profiling a particular node."
msgstr "请注意，与以前一样，我们应该将此进程与其他进程隔离开来。因此，在对特定节点进行性能分析时，不应该在此launch文件中与任何其他节点一起运行，也不应该使用节点组合。"


#: ../../tutorials/docs/get_profile.rst:108
msgid "Because Nav2 bringup has more than one node per launch file (and in the case ``use_composition=true``, more than one per process), it is necessary to separate out a particular node that you're interested in profiling from the rest of the system. As previously described, once they're isolated in either a launch file or as a node to be launched on the commandline, they can easily be run to collect the callgrind information."
msgstr "由于Nav2的引导过程中每个启动文件都有多个节点（并且在``use_composition=true``的情况下，每个进程还有多个节点），因此需要从整个系统中分离出您感兴趣的特定节点进行性能分析。如前所述，一旦它们被隔离在启动文件或作为要在命令行上启动的节点中，就可以轻松运行它们以收集callgrind信息。"


#: ../../tutorials/docs/get_profile.rst:110
msgid "The steps within Nav2 are as follows:"
msgstr "在Nav2中的步骤如下："


#: ../../tutorials/docs/get_profile.rst:112
msgid "Remove server node from the ``navigation_launch.py``, ensuring to remove from both composed and non-composed options within the file"
msgstr "从``navigation_launch.py``中删除服务器节点，并确保从文件中的组合和非组合选项中删除该节点"


#: ../../tutorials/docs/get_profile.rst:113
msgid "In a separate launch file or using ``ros2 run`` CLI, start up the node you'd like to profile using the instructions above"
msgstr "在单独的launch文件中或使用``ros2 run``命令行界面，按照上述说明启动要进行性能分析的节点"


#: ../../tutorials/docs/get_profile.rst:114
msgid "Launch Nav2 as usual with the missing node"
msgstr "像往常一样启动Nav2，缺少的节点会被忽略"


#: ../../tutorials/docs/get_profile.rst:115
msgid "Once your data has been collected, control+C and cleanly finish the profiled process and the rest of the navigation"
msgstr "在收集完数据后，使用Control+C干净地结束正在进行性能分析的进程以及其余的导航过程"


#: ../../tutorials/docs/get_profile.rst:117
msgid "It is important that the profiler node is launched before Nav2 so that it can take the signals from the lifecycle manager to transition up."
msgstr "重要的是在Nav2之前启动分析器节点，这样它可以接收生命周期管理器发出的信号以进行状态转换。"


#: ../../tutorials/docs/get_profile.rst:120
msgid "Interpreting Results"
msgstr "解释结果"


#: ../../tutorials/docs/get_profile.rst:122
msgid "Once you have your ``callgrind`` results, regardless of if you did it through a node, launch file, Nav2, or elsewhere, now we can analyze the results from the profiler to identify bottlenecks or potential areas of improvement. Using ``kcachegrind``:"
msgstr "一旦您获得了``callgrind``结果，无论您是通过节点、启动文件、Nav2还是其他方式进行分析，现在我们可以通过分析分析器的结果来识别性能瓶颈或潜在改进的领域。使用``kcachegrind``:"


#: ../../tutorials/docs/get_profile.rst:128
msgid "This should open a window looking like below. The left side shows all of the calls and their relative percentages of compute time they and their children functions utilized."
msgstr "这将打开一个看起来如下图所示的窗口。左侧显示了所有调用及其所使用的计算时间及其子函数所占的相对比例。"


#: ../../tutorials/docs/get_profile.rst:135
msgid "If you select the top level entry on the left sidebar, then select \"Call Graph\" at the bottom of the right workspace, it should show you a call graph of where the compute time was spent as a graph of method calls. This can be exceptionally helpful to find the methods where the most time is spent."
msgstr "如果您在左侧边栏上选择顶级条目，然后在右侧工作区的底部选择“调用图”，它将显示计算时间花费的调用图，即方法调用的图形表示。这对于找到花费最多时间的方法非常有帮助。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:4
msgid "Dynamic Object Following"
msgstr "动态对象跟随"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:20
msgid "This tutorial shows how to use Nav2 for a different task other than going from point A to point B. In this case, we will use Nav2 to follow a moving object at a distance indefinitely."
msgstr "本教程演示了如何在Nav2中执行与从点A到点B的不同任务。在本例中，我们将使用Nav2来无限跟随一个移动对象的距离。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:22
msgid "This task is useful in cases such as following a person or another robot. Below are some sample videos of applications that could be created using this capability. The \"Carry My Luggage\" RoboCup @ Home test, in which the `CATIE Robotics <https://robotics.catie.fr/>`_ team performs the test successfully and this real (future) world application:"
msgstr "这个任务在追踪一个人或另一个机器人的情况下非常有用。以下是一些可以使用这种能力创建的应用程序的示例视频。``Carry My Luggage`` RoboCup @ Home 测试，其中 `CATIE Robotics <https://robotics.catie.fr/>`_ 团队成功进行了测试，这是一个真实（未来）世界的应用程序："


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:35
msgid "The requirements for this task are as follows:"
msgstr "该任务的要求如下："


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:37
msgid "Changes are limited to the behavior tree used to navigate. This behavior tree can be selected in the ``NavigateToPose`` action when required, or it can be the default behavior tree. It is made up of run-time configurable plugins."
msgstr "更改限于用于导航的行为树。此行为树可以在需要时在``NavigateToPose``动作中选择，或者它可以是默认的行为树。它由运行时可配置的插件组成。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:38
msgid "The configuration of the planner and the controller will not be modified."
msgstr "规划器和控制器的配置不会被修改。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:39
msgid "The action will indefinitely run until it is canceled by who initiated it."
msgstr "该动作将一直运行，直到由启动它的人取消为止。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:41
msgid "The detection of the dynamic object (like a person) to follow is outside the scope of this tutorial. As shown in the following diagram, your application should provide a detector for the object(s) of interest, send the initial pose to the ``NavigateToPose`` action, and update it on a topic for the duration of the task. Many different types of detectors exist that you can leverage for this application:"
msgstr "检测要跟随的动态物体（例如人）超出了本教程的范围。如下图所示，您的应用程序应提供一个用于检测感兴趣物体的探测器，将初始姿态发送到“NavigateToPose”动作，并在任务的整个过程中通过话题进行更新。有许多不同类型的探测器可供您在此应用程序中使用："


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:52
msgid "0- Create the Behavior Tree"
msgstr "0- 创建行为树"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:54
msgid "Let's start from this simple behavior tree. This behavior tree replans a new path at 1 hz and passes that path to the controller to follow:"
msgstr "让我们从这个简单的行为树开始。该行为树以1赫兹的频率重新规划新路径，并将该路径传递给控制器进行跟随："


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:69
msgid "First, let's make this behavior run until there's a failure. For this purpose, we will use the ``KeepRunningUntilFailure`` control node."
msgstr "首先，让我们让这个行为一直运行，直到出现故障。为此，我们将使用``KeepRunningUntilFailure``控制节点。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:86
msgid "We will then use the decorator ``GoalUpdater`` to accept updates of the dynamic object pose we're trying to follow. This node takes as input the current goal and subscribes to the topic ``/goal_update``. It sets the new goal as ``updated_goal`` if a new goal on that topic is received."
msgstr "然后，我们将使用修饰器“GoalUpdater”来接受我们要跟随的动态物体姿态的更新。该节点以当前目标作为输入，并订阅主题“/goal_update”。如果在该主题上接收到新目标，它将将新目标设置为“updated_goal”。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:105
msgid "To stay at a certain distance from the target, we will use the action node ``TruncatePath``. This node modifies a path making it shorter so we don't try to navigate into the object of interest. We can set up the desired distance to the goal using the input port ``distance``."
msgstr "为了保持与目标的一定距离，我们将使用动作节点``TruncatePath``。该节点会修改路径，使其变短，以便我们不会试图进入感兴趣的对象。我们可以使用输入端口``distance``来设置到目标的期望距离。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:127
msgid "Now, you may save this behavior tree and use it in our navigation task."
msgstr "现在，您可以保存这个行为树并在我们的导航任务中使用它。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:129
msgid "For reference, this exact behavior tree is `made available <https://github.com/ros-planning/navigation2/blob/main/nav2_bt_navigator/behavior_trees/follow_point.xml>`_ to you batteries included in the ``nav2_bt_navigator`` package."
msgstr "供您使用的确切行为树可以在``nav2_bt_navigator``包中找到，链接在`此处 <https://github.com/ros-planning/navigation2/blob/main/nav2_bt_navigator/behavior_trees/follow_point.xml>`_。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:132
msgid "1- Setup Rviz clicked point"
msgstr "1- 设置 Rviz 点击点"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:134
msgid "We are going to use RViz instead of a full application so you can test at home without finding a detector to get started. We will use the \"clicked point\" button on the toolbar to substitute object detections to provide goal updates to Nav2. This button allows you to publish coordinates in the topic ``/clicked_point``. This point needs to be sent to the behavior tree, using the program ``clicked_point_to_pose``, from `this repo <https://github.com/fmrico/nav2_test_utils>`_. Clone this repo in your workspace, build, and type in a terminal."
msgstr "我们将使用RViz而不是完整的应用程序，这样您就可以在家中进行测试，而无需找到一个探测器来开始。我们将使用工具栏上的“clicked point”按钮，用来替代对象检测，以向Nav2提供目标更新。该按钮允许您在主题``/clicked_point``中发布坐标。这个点需要通过程序``clicked_point_to_pose``发送到行为树，从`此存储库 <https://github.com/fmrico/nav2_test_utils>`_中获取。在您的工作空间中克隆此存储库，构建并在终端中输入命令。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:138
msgid "``ros2 run nav2_test_utils clicked_point_to_pose``"
msgstr "``ros2 run nav2_test_utils clicked_point_to_pose``"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:140
msgid "Optionally, you can remap this topic in your rviz configuration file to ``goal_updates``."
msgstr "可选地，您可以在rviz配置文件中重新映射此主题为``goal_updates``。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:143
msgid "2- Run Dynamic Object Following in Nav2 Simulation"
msgstr "2- 在Nav2仿真中运行动态物体跟随"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:145
msgid "Start Nav2 in one terminal:"
msgstr "在一个终端中启动Nav2："


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:147
msgid "``ros2 launch nav2_bringup tb3_simulation_launch.py default_bt_xml_filename:=/path/to/bt.xml``"
msgstr "``ros2 launch nav2_bringup tb3_simulation_launch.py default_bt_xml_filename:=/path/to/bt.xml``"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:149
msgid "Open RViz and, after initialize the robot position, command the robot to navigate to any position. Use the button clicked point to simulate a new detection of the object of interest, as shown in the video in the head of this tutorial."
msgstr "打开RViz，在初始化机器人位置后，命令机器人导航到任意位置。使用点击点按钮模拟对感兴趣对象的新检测，如本教程开头的视频所示。"


#: ../../tutorials/docs/navigation2_dynamic_point_following.rst:151
msgid "When you have a detector detecting your obstacle at a higher rate (1 hz, 10 hz, 100 hz) you will see a far more reactive robot following your detected object of interest!"
msgstr "当你的检测器以更高的频率（1 Hz、10 Hz、100 Hz）检测到障碍物时，你将看到一个更具反应性的机器人跟随你检测到的感兴趣的物体！"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:4
msgid "Navigating with a Physical Turtlebot 3"
msgstr "使用实体Turtlebot 3导航"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:21
msgid "This tutorial shows how to control and navigate Turtlebot 3 using the ROS 2 Nav2 on a physical Turtlebot 3 robot. Before completing this tutorials, completing :ref:`getting_started` is highly recommended especially if you are new to ROS and Nav2."
msgstr "本教程展示了如何使用ROS 2 Nav2在物理Turtlebot 3机器人上控制和导航。在完成本教程之前，强烈推荐完成 :ref:`getting_started`，特别是如果你对ROS和Nav2还不熟悉的话。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:24
msgid "This tutorial may take about 1 hour to complete. It depends on your experience with ROS, robots, and what computer system you have."
msgstr "完成本教程可能需要大约1小时。这取决于您对ROS、机器人的经验以及您所拥有的计算机系统。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:30
msgid "You must install Nav2, Turtlebot3. If you don't have them installed, please follow :ref:`getting_started`."
msgstr "你必须安装Nav2和Turtlebot3。如果你尚未安装它们，请按照 :ref:`getting_started` 进行安装。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:37
msgid "0- Setup Your Enviroment Variables"
msgstr "0- 设置环境变量"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:39 ../../tutorials/docs/navigation2_with_slam.rst:47
msgid "Run the following commands first whenever you open a new terminal during this tutorial."
msgstr "在本教程中，每次打开新的终端时，请首先运行以下命令。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:41 ../../tutorials/docs/navigation2_with_slam.rst:49
msgid "``source /opt/ros/<ros2-distro>/setup.bash``"
msgstr "``source /opt/ros/<ros2-distro>/setup.bash``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:42 ../../tutorials/docs/navigation2_with_slam.rst:50
msgid "``export TURTLEBOT3_MODEL=waffle``"
msgstr "``export TURTLEBOT3_MODEL=waffle``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:45
msgid "1- Launch Turtlebot 3"
msgstr "1- 启动Turtlebot 3"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:47
msgid "You will need to launch your robot's interface,"
msgstr "你需要启动机器人的界面,"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:49
msgid "``ros2 launch turtlebot3_bringup robot.launch.py  use_sim_time:=False``"
msgstr "``ros2 launch turtlebot3_bringup robot.launch.py use_sim_time:=False``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:52
msgid "2- Launch Nav2"
msgstr "2- 启动Nav2"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:54
msgid "You need to have a map of the environment where you want to Navigate Turtlebot 3, or create one live with SLAM."
msgstr "您需要拥有一个Turtlebot 3导航的环境地图，或者使用SLAM实时创建一个。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:56
msgid "In case you are interested, there is a use case tutorial which shows how to use Nav2 with SLAM. :ref:`navigation2-with-slam`."
msgstr "如果你感兴趣，这里有一个用例教程展示了如何使用带有SLAM的Nav2。:ref:`navigation2-with-slam`。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:59
msgid "Required files:"
msgstr "Required files:"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:61
msgid "``your-map.map``"
msgstr "``your-map.map``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:62
msgid "``your-map.yaml``"
msgstr "``your-map.yaml``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:64
msgid "``<your_map>.yaml`` is the configuration file for the map we want to provide Nav2. In this case, it has the map resolution value, threshold values for obstacles and free spaces, and a map file location. You need to make sure these values are correct. More information about the map.yaml can be found `here <http://wiki.ros.org/map_server>`_."
msgstr "``<your_map>.yaml`` 是我们要提供给Nav2的地图的配置文件。在这种情况下，它包含地图分辨率值、障碍物和自由空间的阈值以及地图文件的位置。你需要确保这些值是正确的。关于map.yaml的更多信息可以在`这里 <http://wiki.ros.org/map_server>`_ 找到。"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:69
msgid "Launch Nav2. If you set autostart:=False, you need to click on the start button in RViz to initialize the nodes. Make sure `use_sim time` is set to **False**, because we want to use the system time instead of the time simulation time from Gazebo."
msgstr "Launch Nav2. If you set autostart:=False, you need to click on the start button in RViz to initialize the nodes. Make sure `use_sim time` is set to **False**, because we want to use the system time instead of the time simulation time from Gazebo."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:72
msgid "``ros2 launch nav2_bringup bringup_launch.py use_sim_time:=False autostart:=False map:=/path/to/your-map.yaml``"
msgstr "``ros2 launch nav2_bringup bringup_launch.py use_sim_time:=False autostart:=False map:=/path/to/your-map.yaml``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:74
msgid "Note: Don't forget to change **/path/to/your-map.yaml** to the actual path to the your-map.yaml file."
msgstr "Note: Don't forget to change **/path/to/your-map.yaml** to the actual path to the your-map.yaml file."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:77
msgid "3-  Launch RVIZ"
msgstr "3-  Launch RVIZ"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:79
msgid "Launch RVIZ with a pre-defined configuration file."
msgstr "Launch RVIZ with a pre-defined configuration file."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:81
msgid "``ros2 run rviz2 rviz2 -d $(ros2 pkg prefix nav2_bringup)/share/nav2_bringup/rviz/nav2_default_view.rviz``"
msgstr "``ros2 run rviz2 rviz2 -d $(ros2 pkg prefix nav2_bringup)/share/nav2_bringup/rviz/nav2_default_view.rviz``"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:83
msgid "Now, you should see a shadow of Turtlebot 3 robot model in the center of the plot in Rviz. Click on the Start button (Bottom Left) if you set the auto_start parameter to false. Then, the map should appear in RViz."
msgstr "Now, you should see a shadow of Turtlebot 3 robot model in the center of the plot in Rviz. Click on the Start button (Bottom Left) if you set the auto_start parameter to false. Then, the map should appear in RViz."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:93
msgid "4- Initialize the Location of Turtlebot 3"
msgstr "4- Initialize the Location of Turtlebot 3"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:95
msgid "First, find where the robot is on the map. Check where your robot is in the room."
msgstr "First, find where the robot is on the map. Check where your robot is in the room."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:97
msgid "Set the pose of the robot in RViz. Click on the 2D Pose Estimate button and point the location of the robot on the map. The direction of the green arrow is the orientation of Turtlebot."
msgstr "Set the pose of the robot in RViz. Click on the 2D Pose Estimate button and point the location of the robot on the map. The direction of the green arrow is the orientation of Turtlebot."


msgid "Set initial pose in RViz"
msgstr "Set initial pose in RViz"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:106
msgid "Now, the 3D model of Turtlebot should move to that location. A small error in the estimated location is tolerable."
msgstr "Now, the 3D model of Turtlebot should move to that location. A small error in the estimated location is tolerable."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:110
msgid "5-  Send a Goal Pose"
msgstr "5-  Send a Goal Pose"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:112
msgid "Pick a target location for Turtlebot on the map. You can send Turtlebot 3 a goal position and a goal orientation by using the **Nav2 Goal** or the **GoalTool** buttons."
msgstr "Pick a target location for Turtlebot on the map. You can send Turtlebot 3 a goal position and a goal orientation by using the **Nav2 Goal** or the **GoalTool** buttons."


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:115
msgid "Note: Nav2 Goal button uses a ROS 2 Action to send the goal and the GoalTool publishes the goal to a topic."
msgstr "Note: Nav2 Goal button uses a ROS 2 Action to send the goal and the GoalTool publishes the goal to a topic."


msgid "Send goal pose in RViz"
msgstr "Send goal pose in RViz"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:122
msgid "Once you define the target pose,  Nav2 will find a global path and start navigating the robot on the map."
msgstr "Once you define the target pose,  Nav2 will find a global path and start navigating the robot on the map."


msgid "Robot navigating in RViz"
msgstr "Robot navigating in RViz"


#: ../../tutorials/docs/navigation2_on_real_turtlebot3.rst:129
msgid "Now, you can see that Turtlebot 3 moves towards the goal position in the room. See the video below."
msgstr "Now, you can see that Turtlebot 3 moves towards the goal position in the room. See the video below."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:4
msgid "Navigating with Keepout Zones"
msgstr "Navigating with Keepout Zones"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:21
msgid "This tutorial shows how to simply utilize keep-out/safety zones where robots can't enter and preferred lanes for robots moving in industrial environments and warehouses. All this functionality is being covered by ``KeepoutFilter`` costmap filter plugin which will be enabled and used in this document."
msgstr "This tutorial shows how to simply utilize keep-out/safety zones where robots can't enter and preferred lanes for robots moving in industrial environments and warehouses. All this functionality is being covered by ``KeepoutFilter`` costmap filter plugin which will be enabled and used in this document."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:32 ../../tutorials/docs/navigation2_with_speed_filter.rst:32
msgid "1. Prepare filter mask"
msgstr "1. Prepare filter mask"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:34
msgid "As was written in :ref:`concepts`, any Costmap Filter (including Keepout Filter) are reading the data marked in a filter mask file. Filter mask - is the usual Nav2 2D-map distributed through PGM, PNG or BMP raster file with its metadata containing in a YAML file. The following steps help to understand how to make a new filter mask:"
msgstr "As was written in :ref:`concepts`, any Costmap Filter (including Keepout Filter) are reading the data marked in a filter mask file. Filter mask - is the usual Nav2 2D-map distributed through PGM, PNG or BMP raster file with its metadata containing in a YAML file. The following steps help to understand how to make a new filter mask:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:36
msgid "Create a new image with a PGM/PNG/BMP format: copy `turtlebot3_world.pgm <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.pgm>`_ main map which will be used in a world simulation from a ``Nav2`` repository to a new ``keepout_mask.pgm`` file."
msgstr "Create a new image with a PGM/PNG/BMP format: copy `turtlebot3_world.pgm <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.pgm>`_ main map which will be used in a world simulation from a ``Nav2`` repository to a new ``keepout_mask.pgm`` file."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:38
msgid "Open ``keepout_mask.pgm`` in your favourite raster graphics editor (as an example could be taken GIMP editor). The lightness of each pixel on the mask means an encoded information for the specific costmap filter you are going to use. Color lightness of each pixel belongs to the ``[0..255]`` range (or ``[0..100]`` in percent scale), where ``0`` means black color and ``255`` - white. Another term \"darkness\" will be understood as the exact opposite of lightness. In other words ``color_darkness = 100% - color_lightness``."
msgstr "Open ``keepout_mask.pgm`` in your favourite raster graphics editor (as an example could be taken GIMP editor). The lightness of each pixel on the mask means an encoded information for the specific costmap filter you are going to use. Color lightness of each pixel belongs to the ``[0..255]`` range (or ``[0..100]`` in percent scale), where ``0`` means black color and ``255`` - white. Another term \"darkness\" will be understood as the exact opposite of lightness. In other words ``color_darkness = 100% - color_lightness``."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:40
msgid "In the GIMP lightness is expressed through color components value (e.g. ``R`` in percent scale) and might be set by moving ``L`` slider in color changing tool:"
msgstr "In the GIMP lightness is expressed through color components value (e.g. ``R`` in percent scale) and might be set by moving ``L`` slider in color changing tool:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:44
msgid "The incoming mask file is being read by the Map Server and converted into ``OccupancyGrid`` values from ``[0..100]`` range (where ``0`` means free cell, ``100`` - occupied, anything in between - less or more occupied cells on map) or be equal to ``-1`` for unknown value. In Nav2 stack each map has ``mode`` attribute which could be ``trinary``, ``scale`` or ``raw``. Depending on ``mode`` selected, the color lightness of PGM/PNG/BMP is being converted to ``OccupancyGrid`` by one of the following principles:"
msgstr "The incoming mask file is being read by the Map Server and converted into ``OccupancyGrid`` values from ``[0..100]`` range (where ``0`` means free cell, ``100`` - occupied, anything in between - less or more occupied cells on map) or be equal to ``-1`` for unknown value. In Nav2 stack each map has ``mode`` attribute which could be ``trinary``, ``scale`` or ``raw``. Depending on ``mode`` selected, the color lightness of PGM/PNG/BMP is being converted to ``OccupancyGrid`` by one of the following principles:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:46
msgid "``trinary`` (default mode): Darkness >= ``occupied_thresh`` means that map occupied (``100``). Darkness <= ``free_thresh`` - map free (``0``). Anything in between - unknown status on map (``-1``)."
msgstr "``trinary`` (default mode): Darkness >= ``occupied_thresh`` means that map occupied (``100``). Darkness <= ``free_thresh`` - map free (``0``). Anything in between - unknown status on map (``-1``)."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:47
msgid "``scale``: Alpha < ``1.0`` - unknown. Darkness >= ``occupied_thresh`` means that map occupied (``100``). Darkness <= ``free_thresh`` - map free (``0``). Anything in between - linearly interpolate to nearest integer from ``[0..100]`` range."
msgstr "``scale``: Alpha < ``1.0`` - unknown. Darkness >= ``occupied_thresh`` means that map occupied (``100``). Darkness <= ``free_thresh`` - map free (``0``). Anything in between - linearly interpolate to nearest integer from ``[0..100]`` range."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:48
msgid "``raw``: Lightness = ``0`` (dark color) means that map is free (``0``). Lightness = ``100`` (in absolute value)  - map is occupied (``100``). Anything in between - ``OccupancyGrid`` value = lightness. Lightness >= ``101`` - unknown (``-1``)."
msgstr "``raw``: Lightness = ``0`` (dark color) means that map is free (``0``). Lightness = ``100`` (in absolute value)  - map is occupied (``100``). Anything in between - ``OccupancyGrid`` value = lightness. Lightness >= ``101`` - unknown (``-1``)."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:50
msgid "where ``free_thresh`` and ``occupied_thresh`` thresholds are expressed in percentage of maximum lightness/darkness level (``255``). Map mode and thresholds are placed in YAML metadata file (see below) as ``mode``, ``free_thresh`` and ``occupied_thresh`` fields."
msgstr "where ``free_thresh`` and ``occupied_thresh`` thresholds are expressed in percentage of maximum lightness/darkness level (``255``). Map mode and thresholds are placed in YAML metadata file (see below) as ``mode``, ``free_thresh`` and ``occupied_thresh`` fields."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:54
msgid "There is another parameter in a YAML metadata file called ``negate``. By default it is set to ``false``. When it is set to ``true``, blacker pixels will be considered as free, whiter pixels - as occupied. In this case we should count color lightness instead of darkness for ``trinary`` and ``scale`` modes. ``negate`` has no effect on ``raw`` mode."
msgstr "There is another parameter in a YAML metadata file called ``negate``. By default it is set to ``false``. When it is set to ``true``, blacker pixels will be considered as free, whiter pixels - as occupied. In this case we should count color lightness instead of darkness for ``trinary`` and ``scale`` modes. ``negate`` has no effect on ``raw`` mode."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:56
msgid "For Keepout Filter ``OccupancyGrid`` value is proportional to the passibility of area corresponting to this cell: higher values means more impassable areas. Cells with occupied values covers keep-out zones where robot will never enter or pass through. ``KeepoutFilter`` can also act as a \"weighted areas layer\" by setting the ``OccupancyGrid`` to something between ``[1-99]`` non-occupied values. Robot is allowed to move in these areas, however its presence there would be \"undesirable\" there (the higher the value, the sooner planners will try to get the robot out of this area)."
msgstr "For Keepout Filter ``OccupancyGrid`` value is proportional to the passibility of area corresponting to this cell: higher values means more impassable areas. Cells with occupied values covers keep-out zones where robot will never enter or pass through. ``KeepoutFilter`` can also act as a \"weighted areas layer\" by setting the ``OccupancyGrid`` to something between ``[1-99]`` non-occupied values. Robot is allowed to move in these areas, however its presence there would be \"undesirable\" there (the higher the value, the sooner planners will try to get the robot out of this area)."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:58
msgid "Keepout Filter also covers preferred lanes case, where robots should moving only on pre-defined lanes and permitted areas e.g. in warehouses. To use this feaure you need to prepare the mask image where the lanes and permitted areas will be marked with free values while all other areas will be occupied. TIP for drawing the mask in a ``trinary`` or ``scale`` mode: typically, amount of pixels belonging to lanes are much less than pixels covering other areas. In this case initially all lanes data might be drawn with a black pencil over white background and then (just before saving a PGM) \"color inversion\" tool in a image raster editor might be used."
msgstr "Keepout Filter also covers preferred lanes case, where robots should moving only on pre-defined lanes and permitted areas e.g. in warehouses. To use this feaure you need to prepare the mask image where the lanes and permitted areas will be marked with free values while all other areas will be occupied. TIP for drawing the mask in a ``trinary`` or ``scale`` mode: typically, amount of pixels belonging to lanes are much less than pixels covering other areas. In this case initially all lanes data might be drawn with a black pencil over white background and then (just before saving a PGM) \"color inversion\" tool in a image raster editor might be used."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:60
msgid "For simplicity, in the example fill the areas with black color (in ``trinary`` mode this means occupied map) that you are going to mark as a keep-out zones:"
msgstr "For simplicity, in the example fill the areas with black color (in ``trinary`` mode this means occupied map) that you are going to mark as a keep-out zones:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:65
msgid "After all keepout areas will be filled save the ``keepout_mask.pgm`` image."
msgstr "After all keepout areas will be filled save the ``keepout_mask.pgm`` image."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:67
msgid "Like all other maps, filter mask should have its own YAML metadata file. Copy `turtlebot3_world.yaml <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.yaml>`_ to ``keepout_mask.yaml``. Open ``keepout_mask.yaml`` and correct ``image`` field to a newly made PGM mask:"
msgstr "Like all other maps, filter mask should have its own YAML metadata file. Copy `turtlebot3_world.yaml <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.yaml>`_ to ``keepout_mask.yaml``. Open ``keepout_mask.yaml`` and correct ``image`` field to a newly made PGM mask:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:75
msgid "Since filter mask image was created as a copy of main map, other fields of YAML-file do not need to be changed. Save ``keepout_mask.yaml`` and new filter mask is ready to use."
msgstr "Since filter mask image was created as a copy of main map, other fields of YAML-file do not need to be changed. Save ``keepout_mask.yaml`` and new filter mask is ready to use."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:79
msgid "World map itself and filter mask could have different sizes, origin and resolution which might be useful e.g. for cases when filter mask is covering smaller areas on maps or when one filter mask is used repeatedly many times (like annotating a keepout zone for same shape rooms in the hotel). For this case, you need to correct ``resolution`` and ``origin`` fields in YAML as well so that the filter mask is correctly laid on top of the original map."
msgstr "World map itself and filter mask could have different sizes, origin and resolution which might be useful e.g. for cases when filter mask is covering smaller areas on maps or when one filter mask is used repeatedly many times (like annotating a keepout zone for same shape rooms in the hotel). For this case, you need to correct ``resolution`` and ``origin`` fields in YAML as well so that the filter mask is correctly laid on top of the original map."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:83
msgid "Another important note is that since Costmap2D does not support orientation, the last third \"yaw\" component of the ``origin`` vector should be equal to zero. For example: ``origin: [1.25, -5.18, 0.0]``."
msgstr "Another important note is that since Costmap2D does not support orientation, the last third \"yaw\" component of the ``origin`` vector should be equal to zero. For example: ``origin: [1.25, -5.18, 0.0]``."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:86 ../../tutorials/docs/navigation2_with_speed_filter.rst:100
msgid "2. Configure Costmap Filter Info Publisher Server"
msgstr "2. Configure Costmap Filter Info Publisher Server"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:88
msgid "Each costmap filter reads incoming meta-information (such as filter type or data conversion coefficients) in a messages of ``nav2_msgs/CostmapFilterInfo`` type. These messages are being published by `Costmap Filter Info Publisher Server <https://github.com/ros-planning/navigation2/tree/main/nav2_map_server/src/costmap_filter_info>`_. The server is running as a lifecycle node. According to the `design document <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, ``nav2_msgs/CostmapFilterInfo`` messages are going in a pair with ``OccupancyGrid`` filter mask topic. Therefore, along with Costmap Filter Info Publisher Server there should be enabled a new instance of Map Server configured to publish filter mask."
msgstr "Each costmap filter reads incoming meta-information (such as filter type or data conversion coefficients) in a messages of ``nav2_msgs/CostmapFilterInfo`` type. These messages are being published by `Costmap Filter Info Publisher Server <https://github.com/ros-planning/navigation2/tree/main/nav2_map_server/src/costmap_filter_info>`_. The server is running as a lifecycle node. According to the `design document <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, ``nav2_msgs/CostmapFilterInfo`` messages are going in a pair with ``OccupancyGrid`` filter mask topic. Therefore, along with Costmap Filter Info Publisher Server there should be enabled a new instance of Map Server configured to publish filter mask."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:90
msgid "In order to enable Keepout Filter in your configuration, both servers should be enabled as a lifecycle nodes in Python launch-file. For example, this might look as follows:"
msgstr "In order to enable Keepout Filter in your configuration, both servers should be enabled as a lifecycle nodes in Python launch-file. For example, this might look as follows:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:199 ../../tutorials/docs/navigation2_with_speed_filter.rst:213
msgid "where the ``params_file`` variable should be set to a YAML-file having ROS parameters for Costmap Filter Info Publisher Server and Map Server nodes. These parameters and their meaning are listed at :ref:`configuring_map_server` page. Please, refer to it for more information. The example of ``params_file`` could be found below:"
msgstr "where the ``params_file`` variable should be set to a YAML-file having ROS parameters for Costmap Filter Info Publisher Server and Map Server nodes. These parameters and their meaning are listed at :ref:`configuring_map_server` page. Please, refer to it for more information. The example of ``params_file`` could be found below:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:218 ../../tutorials/docs/navigation2_with_speed_filter.rst:232
msgid "Note, that:"
msgstr "Note, that:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:220
msgid "For Keepout Filter the ``type`` of costmap filter should be set to ``0``."
msgstr "For Keepout Filter the ``type`` of costmap filter should be set to ``0``."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:221 ../../tutorials/docs/navigation2_with_speed_filter.rst:235
msgid "Filter mask topic name should be the equal for ``mask_topic`` parameter of Costmap Filter Info Publisher Server and ``topic_name`` parameter of Map Server."
msgstr "Filter mask topic name should be the equal for ``mask_topic`` parameter of Costmap Filter Info Publisher Server and ``topic_name`` parameter of Map Server."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:222
msgid "According to the Costmap Filters design, ``OccupancyGrid`` values are being linearly transformed into feature map in a filter space. For a Keepout Filter these values are directly passed as a filter space values without a linear conversion. Even though ``base`` and ``multiplier`` coefficients are not used in Keepout Filter, they should be set to ``0.0`` and ``1.0`` accordingly in order to explicitly show that we have one-to-one conversion from ``OccupancyGrid`` values -> to a filter value space."
msgstr "According to the Costmap Filters design, ``OccupancyGrid`` values are being linearly transformed into feature map in a filter space. For a Keepout Filter these values are directly passed as a filter space values without a linear conversion. Even though ``base`` and ``multiplier`` coefficients are not used in Keepout Filter, they should be set to ``0.0`` and ``1.0`` accordingly in order to explicitly show that we have one-to-one conversion from ``OccupancyGrid`` values -> to a filter value space."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:224
msgid "Ready-to-go standalone Python launch-script, YAML-file with ROS parameters and filter mask example for Keepout Filter could be found in a `nav2_costmap_filters_demo <https://github.com/ros-planning/navigation2_tutorials/tree/master/nav2_costmap_filters_demo>`_ directory of ``navigation2_tutorials`` repository. To simply run Filter Info Publisher Server and Map Server tuned on Turtlebot3 standard simulation written at :ref:`getting_started`, build the demo and launch ``costmap_filter_info.launch.py`` as follows:"
msgstr "Ready-to-go standalone Python launch-script, YAML-file with ROS parameters and filter mask example for Keepout Filter could be found in a `nav2_costmap_filters_demo <https://github.com/ros-planning/navigation2_tutorials/tree/master/nav2_costmap_filters_demo>`_ directory of ``navigation2_tutorials`` repository. To simply run Filter Info Publisher Server and Map Server tuned on Turtlebot3 standard simulation written at :ref:`getting_started`, build the demo and launch ``costmap_filter_info.launch.py`` as follows:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:237
msgid "3. Enable Keepout Filter"
msgstr "3. Enable Keepout Filter"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:239
msgid "Costmap Filters are Costamp2D plugins. You can enable the ``KeepoutFilter`` plugin in Costmap2D by adding ``keepout_filter`` to the ``plugins`` parameter in ``nav2_params.yaml``. You can place it in the ``global_costmap`` for planning with keepouts and ``local_costmap`` to make sure the robot won't attempt to drive through a keepout zone. The KeepoutFilter plugin should have the following parameters defined:"
msgstr "Costmap Filters are Costamp2D plugins. You can enable the ``KeepoutFilter`` plugin in Costmap2D by adding ``keepout_filter`` to the ``plugins`` parameter in ``nav2_params.yaml``. You can place it in the ``global_costmap`` for planning with keepouts and ``local_costmap`` to make sure the robot won't attempt to drive through a keepout zone. The KeepoutFilter plugin should have the following parameters defined:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:241
msgid "``plugin``: type of plugin. In our case ``nav2_costmap_2d::KeepoutFilter``."
msgstr "``plugin``: type of plugin. In our case ``nav2_costmap_2d::KeepoutFilter``."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:242
msgid "``filter_info_topic``: filter info topic name. This need to be equal to ``filter_info_topic`` parameter of Costmap Filter Info Publisher Server from the chapter above."
msgstr "``filter_info_topic``: filter info topic name. This need to be equal to ``filter_info_topic`` parameter of Costmap Filter Info Publisher Server from the chapter above."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:244
msgid "Full list of parameters supported by ``KeepoutFilter`` are listed at :ref:`keepout_filter` page."
msgstr "Full list of parameters supported by ``KeepoutFilter`` are listed at :ref:`keepout_filter` page."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:246
msgid "It is important to note that enabling ``KeepoutFilter`` for ``global_costmap`` only will cause the path planner to build plans bypassing keepout zones. Enabling ``KeepoutFilter`` for ``local_costmap`` only will cause the robot to not enter keepout zones, but the path may still go through them. So, the best practice is to enable ``KeepoutFilter`` for global and local costmaps simultaneously by adding it both in ``global_costmap`` and ``local_costmap`` in ``nav2_params.yaml``. However it does not always have to be true. In some cases keepout zones don't have to be the same for global and local costmaps, e.g. if the robot doesn't allowed to intentionally go inside keepout zones, but if its there, the robot can drive in and out really quick if it clips an edge or corner. For this case, there is not need to use extra resources of the local costmap copy."
msgstr "It is important to note that enabling ``KeepoutFilter`` for ``global_costmap`` only will cause the path planner to build plans bypassing keepout zones. Enabling ``KeepoutFilter`` for ``local_costmap`` only will cause the robot to not enter keepout zones, but the path may still go through them. So, the best practice is to enable ``KeepoutFilter`` for global and local costmaps simultaneously by adding it both in ``global_costmap`` and ``local_costmap`` in ``nav2_params.yaml``. However it does not always have to be true. In some cases keepout zones don't have to be the same for global and local costmaps, e.g. if the robot doesn't allowed to intentionally go inside keepout zones, but if its there, the robot can drive in and out really quick if it clips an edge or corner. For this case, there is not need to use extra resources of the local costmap copy."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:248
msgid "To enable ``KeepoutFilter`` with same mask for both global and local costmaps, use the following configuration:"
msgstr "To enable ``KeepoutFilter`` with same mask for both global and local costmaps, use the following configuration:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:278
msgid "All costmap filters should be enabled through a ``filters`` parameter -- though it is technically possible to include in the layered costmap itself. This is separated from the layer plugins to prevent interference in the layers, particularly the  inflation layer."
msgstr "All costmap filters should be enabled through a ``filters`` parameter -- though it is technically possible to include in the layered costmap itself. This is separated from the layer plugins to prevent interference in the layers, particularly the  inflation layer."


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:281 ../../tutorials/docs/navigation2_with_speed_filter.rst:293
msgid "4. Run Nav2 stack"
msgstr "4. Run Nav2 stack"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:283
msgid "After Costmap Filter Info Publisher Server and Map Server were launched and Keepout Filter was enabled for global/local costmaps, run Nav2 stack as written in :ref:`getting_started`:"
msgstr "After Costmap Filter Info Publisher Server and Map Server were launched and Keepout Filter was enabled for global/local costmaps, run Nav2 stack as written in :ref:`getting_started`:"


#: ../../tutorials/docs/navigation2_with_keepout_filter.rst:289
msgid "And check that filter is working properly as in the pictures below (first picture shows keepout filter enabled for the global costmap, second - differently-sized ``keepout_mask.pgm`` filter mask):"
msgstr "And check that filter is working properly as in the pictures below (first picture shows keepout filter enabled for the global costmap, second - differently-sized ``keepout_mask.pgm`` filter mask):"


#: ../../tutorials/docs/navigation2_with_slam.rst:4
msgid "(SLAM) Navigating While Mapping"
msgstr "(SLAM) Navigating While Mapping"


#: ../../tutorials/docs/navigation2_with_slam.rst:13
msgid "This document explains how to use Nav2 with SLAM. The following steps show ROS 2 users how to generate occupancy grid maps and use Nav2 to move their robot around. This tutorial applies to both simulated and physical robots, but will be completed here on physical robot."
msgstr "This document explains how to use Nav2 with SLAM. The following steps show ROS 2 users how to generate occupancy grid maps and use Nav2 to move their robot around. This tutorial applies to both simulated and physical robots, but will be completed here on physical robot."


#: ../../tutorials/docs/navigation2_with_slam.rst:17
msgid "Before completing this tutorial, completing the :ref:`getting_started` is highly recommended especially if you are new to ROS and Navigation2."
msgstr "Before completing this tutorial, completing the :ref:`getting_started` is highly recommended especially if you are new to ROS and Navigation2."


#: ../../tutorials/docs/navigation2_with_slam.rst:20
msgid "In this tutorial we'll be using SLAM Toolbox. More information can be found in the `ROSCon talk for SLAM Toolbox <https://vimeo.com/378682207>`_"
msgstr "In this tutorial we'll be using SLAM Toolbox. More information can be found in the `ROSCon talk for SLAM Toolbox <https://vimeo.com/378682207>`_"


#: ../../tutorials/docs/navigation2_with_slam.rst:25
msgid "You must install Navigation2, Turtlebot3, and SLAM Toolbox. If you don't have them installed, please follow :ref:`getting_started`."
msgstr "You must install Navigation2, Turtlebot3, and SLAM Toolbox. If you don't have them installed, please follow :ref:`getting_started`."


#: ../../tutorials/docs/navigation2_with_slam.rst:28
msgid "SLAM Toolbox can be installed via:"
msgstr "SLAM Toolbox can be installed via:"


#: ../../tutorials/docs/navigation2_with_slam.rst:30
msgid "``sudo apt install ros-<ros2-distro>-slam-toolbox``"
msgstr "``sudo apt install ros-<ros2-distro>-slam-toolbox``"


#: ../../tutorials/docs/navigation2_with_slam.rst:32
msgid "or from built from source in your workspace with:"
msgstr "or from built from source in your workspace with:"


#: ../../tutorials/docs/navigation2_with_slam.rst:34
msgid "``git clone -b <ros2-distro>-devel git@github.com:stevemacenski/slam_toolbox.git``"
msgstr "``git clone -b <ros2-distro>-devel git@github.com:stevemacenski/slam_toolbox.git``"


#: ../../tutorials/docs/navigation2_with_slam.rst:41
msgid "0- Launch Robot Interfaces"
msgstr "0- Launch Robot Interfaces"


#: ../../tutorials/docs/navigation2_with_slam.rst:43
msgid "For this tutorial, we will use the turtlebot3. If you have another robot, replace with your robot specific interfaces. Typically, this includes the robot state publisher of the URDF, simulated or physical robot interfaces, controllers, safety nodes, and the like."
msgstr "For this tutorial, we will use the turtlebot3. If you have another robot, replace with your robot specific interfaces. Typically, this includes the robot state publisher of the URDF, simulated or physical robot interfaces, controllers, safety nodes, and the like."


#: ../../tutorials/docs/navigation2_with_slam.rst:53
msgid "Launch your robot's interface and robot state publisher,"
msgstr "Launch your robot's interface and robot state publisher,"


#: ../../tutorials/docs/navigation2_with_slam.rst:55
msgid "``ros2 launch turtlebot3_bringup robot.launch.py``"
msgstr "``ros2 launch turtlebot3_bringup robot.launch.py``"


#: ../../tutorials/docs/navigation2_with_slam.rst:58
msgid "1- Launch Navigation2"
msgstr "1- Launch Navigation2"


#: ../../tutorials/docs/navigation2_with_slam.rst:60
msgid "Launch Navigation without nav2_amcl and nav2_map_server. It is assumed that the SLAM node(s) will publish to /map topic and provide the map->odom transform."
msgstr "Launch Navigation without nav2_amcl and nav2_map_server. It is assumed that the SLAM node(s) will publish to /map topic and provide the map->odom transform."


#: ../../tutorials/docs/navigation2_with_slam.rst:63
msgid "``ros2 launch nav2_bringup navigation_launch.py``"
msgstr "``ros2 launch nav2_bringup navigation_launch.py``"


#: ../../tutorials/docs/navigation2_with_slam.rst:66
msgid "2- Launch SLAM"
msgstr "2- Launch SLAM"


#: ../../tutorials/docs/navigation2_with_slam.rst:68
msgid "Bring up your choice of SLAM implementation. Make sure it provides the map->odom transform and /map topic. Run Rviz and add the topics you want to visualize such as /map, /tf, /laserscan etc. For this tutorial, we will use `SLAM Toolbox <https://github.com/SteveMacenski/slam_toolbox>`_."
msgstr "Bring up your choice of SLAM implementation. Make sure it provides the map->odom transform and /map topic. Run Rviz and add the topics you want to visualize such as /map, /tf, /laserscan etc. For this tutorial, we will use `SLAM Toolbox <https://github.com/SteveMacenski/slam_toolbox>`_."


#: ../../tutorials/docs/navigation2_with_slam.rst:74
msgid "``ros2 launch slam_toolbox online_async_launch.py``"
msgstr "``ros2 launch slam_toolbox online_async_launch.py``"


#: ../../tutorials/docs/navigation2_with_slam.rst:77
msgid "3- Working with SLAM"
msgstr "3- Working with SLAM"


#: ../../tutorials/docs/navigation2_with_slam.rst:79
msgid "Move your robot by requesting a goal through RViz or the ROS 2 CLI, ie:"
msgstr "Move your robot by requesting a goal through RViz or the ROS 2 CLI, ie:"


#: ../../tutorials/docs/navigation2_with_slam.rst:85
msgid "You should see the map update live! To save this map to file:"
msgstr "You should see the map update live! To save this map to file:"


#: ../../tutorials/docs/navigation2_with_slam.rst:87
msgid "``ros2 run nav2_map_server map_saver_cli -f ~/map``"
msgstr "``ros2 run nav2_map_server map_saver_cli -f ~/map``"


msgid "Navigation2 with SLAM"
msgstr "Navigation2 with SLAM"


#: ../../tutorials/docs/navigation2_with_slam.rst:95
msgid "4- Getting Started Simplification"
msgstr "4- Getting Started Simplification"


#: ../../tutorials/docs/navigation2_with_slam.rst:97
msgid "If you're only interested in running SLAM in the turtlebot3 getting started sandbox world, we also provide a simple way to enable SLAM as a launch configuration. Rather than individually launching the interfaces, navigation, and SLAM, you can continue to use the ``tb3_simulation_launch.py`` with ``slam`` config set to true. We provide the instructions above with the assumption that you'd like to run SLAM on your own robot which would have separated simulation / robot interfaces and navigation launch files that are combined in ``tb3_simulation_launch.py`` for the purposes of easy testing."
msgstr "If you're only interested in running SLAM in the turtlebot3 getting started sandbox world, we also provide a simple way to enable SLAM as a launch configuration. Rather than individually launching the interfaces, navigation, and SLAM, you can continue to use the ``tb3_simulation_launch.py`` with ``slam`` config set to true. We provide the instructions above with the assumption that you'd like to run SLAM on your own robot which would have separated simulation / robot interfaces and navigation launch files that are combined in ``tb3_simulation_launch.py`` for the purposes of easy testing."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:4
msgid "Navigating with Speed Limits"
msgstr "Navigating with Speed Limits"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:21
msgid "This tutorial shows how to simply utilize Speed Filter which is designed to limit the maximum speed of robots in speed restriction areas marked on a map. This functionality is being covered by ``SpeedFilter`` costmap filter plugin which will be enabled and used in this document."
msgstr "This tutorial shows how to simply utilize Speed Filter which is designed to limit the maximum speed of robots in speed restriction areas marked on a map. This functionality is being covered by ``SpeedFilter`` costmap filter plugin which will be enabled and used in this document."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:26
msgid "It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that the Nav2 project is also built locally as it was made in :ref:`build-instructions`."
msgstr "It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that the Nav2 project is also built locally as it was made in :ref:`build-instructions`."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:34
msgid "As was written in :ref:`concepts`, any Costmap Filter (including Speed Filter) is reading the data marked in a filter mask file. All information about filter masks, their types, detailed structure and how to make a new one is written in a :ref:`navigation2_with_keepout_filter` tutorial at ``1. Prepare filter masks`` chapter. The principal of drawing the filter mask for Speed Filter is the same as for Keepout Filter (to annotate a map with the requested zones), except that ``OccupancyGrid`` mask values have another meaning: these values are encoded speed limits for the areas corresponding to the cell on map."
msgstr "As was written in :ref:`concepts`, any Costmap Filter (including Speed Filter) is reading the data marked in a filter mask file. All information about filter masks, their types, detailed structure and how to make a new one is written in a :ref:`navigation2_with_keepout_filter` tutorial at ``1. Prepare filter masks`` chapter. The principal of drawing the filter mask for Speed Filter is the same as for Keepout Filter (to annotate a map with the requested zones), except that ``OccupancyGrid`` mask values have another meaning: these values are encoded speed limits for the areas corresponding to the cell on map."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:36
msgid "Let's look, how it is being decoded. As we know, ``OccupancyGrid`` values are belonging to the ``[0..100]`` range. For Speed Filter ``0`` value means no speed limit in the area corresponding zero-cell on mask. Values from ``[1..100]`` range are being linearly converted into a speed limit value by the following formula:"
msgstr "Let's look, how it is being decoded. As we know, ``OccupancyGrid`` values are belonging to the ``[0..100]`` range. For Speed Filter ``0`` value means no speed limit in the area corresponding zero-cell on mask. Values from ``[1..100]`` range are being linearly converted into a speed limit value by the following formula:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:42
msgid "where:"
msgstr "where:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:44
msgid "``filter_mask_data`` - is an ``OccupancyGrid`` value of the corresponding cell on mask where maximum speed should be restricted."
msgstr "``filter_mask_data`` - is an ``OccupancyGrid`` value of the corresponding cell on mask where maximum speed should be restricted."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:45
msgid "``base`` and ``multiplier`` are coefficients taken from ``nav2_msgs/CostmapFilterInfo`` messages published by Costmap Filter Info Server (see in next chapter below)."
msgstr "``base`` and ``multiplier`` are coefficients taken from ``nav2_msgs/CostmapFilterInfo`` messages published by Costmap Filter Info Server (see in next chapter below)."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:47
msgid "The decoded ``speed_limit`` value may have one of two meanings:"
msgstr "The decoded ``speed_limit`` value may have one of two meanings:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:49
msgid "Speed limit expressed in a percent from maximum robot speed."
msgstr "Speed limit expressed in a percent from maximum robot speed."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:50
msgid "Speed limit expressed in absolute values (e.g. in ``m/s``)."
msgstr "Speed limit expressed in absolute values (e.g. in ``m/s``)."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:52
msgid "The meaning used by Speed Filter is being read from ``nav2_msgs/CostmapFilterInfo`` messages. In this tutorial we will use the first type of speed restriction expressed in a percent from maximum robot speed."
msgstr "The meaning used by Speed Filter is being read from ``nav2_msgs/CostmapFilterInfo`` messages. In this tutorial we will use the first type of speed restriction expressed in a percent from maximum robot speed."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:57
msgid "For speed restriction expressed in a percent, ``speed_limit`` will be used exactly as a percent belonging to ``[0..100]`` range, not ``[0.0..1.0]`` range."
msgstr "For speed restriction expressed in a percent, ``speed_limit`` will be used exactly as a percent belonging to ``[0..100]`` range, not ``[0.0..1.0]`` range."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:59
msgid "Create a new image with a PGM/PNG/BMP format: copy ``turtlebot3_world.pgm`` main map which will be used in a world simulation from a Nav2 repository to a new ``speed_mask.pgm`` file. Open ``speed_mask.pgm`` in your favourite raster graphics editor and fill speed restricted areas with grey colors. In our example darker colors will indicate areas with higher speed restriction:"
msgstr "Create a new image with a PGM/PNG/BMP format: copy ``turtlebot3_world.pgm`` main map which will be used in a world simulation from a Nav2 repository to a new ``speed_mask.pgm`` file. Open ``speed_mask.pgm`` in your favourite raster graphics editor and fill speed restricted areas with grey colors. In our example darker colors will indicate areas with higher speed restriction:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:64
msgid "Area \"A\" is filled with ``40%`` gray color, area \"B\" - with ``70%`` gray, that means that speed restriction will take ``100% - 40% = 60%`` in area \"A\" and ``100% - 70% = 30%`` in area \"B\" from maximum speed value allowed for this robot. We will use ``scale`` map mode with no thresholds. In this mode darker colors will have higher ``OccupancyGrid`` values. E.g. for area \"B\" with ``70%`` of gray ``OccupancyGrid`` data will be equal to ``70``. So in order to hit the target, we need to choose ``base = 100.0`` and ``multiplier = -1.0``. This will reverse the scale ``OccupancyGrid`` values to a desired one. No thresholds (``free_thresh`` ``occupied_thresh``) were chosen for the convenience in the ``yaml``  file: to have 1:1 full range conversion of lightness value from filter mask -> to speed restriction percent."
msgstr "Area \"A\" is filled with ``40%`` gray color, area \"B\" - with ``70%`` gray, that means that speed restriction will take ``100% - 40% = 60%`` in area \"A\" and ``100% - 70% = 30%`` in area \"B\" from maximum speed value allowed for this robot. We will use ``scale`` map mode with no thresholds. In this mode darker colors will have higher ``OccupancyGrid`` values. E.g. for area \"B\" with ``70%`` of gray ``OccupancyGrid`` data will be equal to ``70``. So in order to hit the target, we need to choose ``base = 100.0`` and ``multiplier = -1.0``. This will reverse the scale ``OccupancyGrid`` values to a desired one. No thresholds (``free_thresh`` ``occupied_thresh``) were chosen for the convenience in the ``yaml``  file: to have 1:1 full range conversion of lightness value from filter mask -> to speed restriction percent."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:69
msgid "It is typical but not a mandatory selection of ``base`` and ``multiplier``. For example, you can choose map mode to be ``raw``. In this case color lightness is being directly converted into ``OccupancyGrid`` values. For masks saved in a ``raw`` mode, ``base`` and ``multiplier`` will be equal to ``0.0`` and ``1.0`` accordingly."
msgstr "It is typical but not a mandatory selection of ``base`` and ``multiplier``. For example, you can choose map mode to be ``raw``. In this case color lightness is being directly converted into ``OccupancyGrid`` values. For masks saved in a ``raw`` mode, ``base`` and ``multiplier`` will be equal to ``0.0`` and ``1.0`` accordingly."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:71
msgid "Another important thing is that it is not necessary to use the whole ``[0..100]`` percent scale. ``base`` and ``multiplier`` coefficients could be chosen so that the speed restriction values would belong to somewhere in the middle of percent range. E.g. ``base = 40.0``, ``multiplier = 0.1`` will give speed restrictions from ``[40.0%..50.0%]`` range with a step of ``0.1%``. This might be useful for fine tuning."
msgstr "Another important thing is that it is not necessary to use the whole ``[0..100]`` percent scale. ``base`` and ``multiplier`` coefficients could be chosen so that the speed restriction values would belong to somewhere in the middle of percent range. E.g. ``base = 40.0``, ``multiplier = 0.1`` will give speed restrictions from ``[40.0%..50.0%]`` range with a step of ``0.1%``. This might be useful for fine tuning."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:73
msgid "After all speed restriction areas will be filled, save the ``speed_mask.pgm`` image."
msgstr "After all speed restriction areas will be filled, save the ``speed_mask.pgm`` image."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:75
msgid "Like all other maps, the filter mask should have its own YAML metadata file. Copy `turtlebot3_world.yaml <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.yaml>`_ to ``speed_mask.yaml``. Open ``speed_mask.yaml`` and update the fields as shown below (as mentioned before for the ``scale`` mode to use whole color lightness range there should be no thresholds: ``free_thresh = 0.0`` and ``occupied_thresh = 1.0``):"
msgstr "Like all other maps, the filter mask should have its own YAML metadata file. Copy `turtlebot3_world.yaml <https://github.com/ros-planning/navigation2/blob/main/nav2_bringup/bringup/maps/turtlebot3_world.yaml>`_ to ``speed_mask.yaml``. Open ``speed_mask.yaml`` and update the fields as shown below (as mentioned before for the ``scale`` mode to use whole color lightness range there should be no thresholds: ``free_thresh = 0.0`` and ``occupied_thresh = 1.0``):"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:93
msgid "Since Costmap2D does not support orientation, the last third \"yaw\" component of the ``origin`` vector should be equal to zero (for example: ``origin: [1.25, -5.18, 0.0]``). Save ``speed_mask.yaml`` and the new filter mask is ready to use."
msgstr "Since Costmap2D does not support orientation, the last third \"yaw\" component of the ``origin`` vector should be equal to zero (for example: ``origin: [1.25, -5.18, 0.0]``). Save ``speed_mask.yaml`` and the new filter mask is ready to use."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:97
msgid "World map itself and filter mask could have different sizes, origin and resolution which might be useful (e.g. for cases when filter mask is covering smaller areas on maps or when one filter mask is used repeatedly many times, like annotating a speed restricted area for same shape rooms in the hotel). For this case, you need to correct ``resolution`` and ``origin`` fields in YAML as well so that the filter mask is correctly laid on top of the original map. This example shows using the main map as a base, but that is not required."
msgstr "World map itself and filter mask could have different sizes, origin and resolution which might be useful (e.g. for cases when filter mask is covering smaller areas on maps or when one filter mask is used repeatedly many times, like annotating a speed restricted area for same shape rooms in the hotel). For this case, you need to correct ``resolution`` and ``origin`` fields in YAML as well so that the filter mask is correctly laid on top of the original map. This example shows using the main map as a base, but that is not required."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:102
msgid "Each costmap filter reads incoming meta-information (such as filter type or data conversion coefficients) in messages of ``nav2_msgs/CostmapFilterInfo`` type. These messages are being published by `Costmap Filter Info Publisher Server <https://github.com/ros-planning/navigation2/tree/main/nav2_map_server/src/costmap_filter_info>`_. The server is running as a lifecycle node. According to the `design document <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, ``nav2_msgs/CostmapFilterInfo`` messages are going in a pair with ``OccupancyGrid`` filter mask topic. Therefore, along with Costmap Filter Info Publisher Server there should be enabled a new instance of Map Server configured to publish filter masks."
msgstr "Each costmap filter reads incoming meta-information (such as filter type or data conversion coefficients) in messages of ``nav2_msgs/CostmapFilterInfo`` type. These messages are being published by `Costmap Filter Info Publisher Server <https://github.com/ros-planning/navigation2/tree/main/nav2_map_server/src/costmap_filter_info>`_. The server is running as a lifecycle node. According to the `design document <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, ``nav2_msgs/CostmapFilterInfo`` messages are going in a pair with ``OccupancyGrid`` filter mask topic. Therefore, along with Costmap Filter Info Publisher Server there should be enabled a new instance of Map Server configured to publish filter masks."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:104
msgid "In order to enable Speed Filter in your configuration, both servers should be enabled as lifecycle nodes in Python launch-file. For example, this might look as follows:"
msgstr "In order to enable Speed Filter in your configuration, both servers should be enabled as lifecycle nodes in Python launch-file. For example, this might look as follows:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:234
msgid "For Speed Filter setting speed restrictions in a percent from maximum speed, the ``type`` of costmap filter should be set to ``1``. All possible costmap filter types could be found at :ref:`configuring_map_server` page."
msgstr "For Speed Filter setting speed restrictions in a percent from maximum speed, the ``type`` of costmap filter should be set to ``1``. All possible costmap filter types could be found at :ref:`configuring_map_server` page."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:236
msgid "As was described in a previous chapter, ``base`` and ``multiplier`` should be set to ``100.0`` and ``-1.0`` accordingly for the purposes of this tutorial example."
msgstr "As was described in a previous chapter, ``base`` and ``multiplier`` should be set to ``100.0`` and ``-1.0`` accordingly for the purposes of this tutorial example."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:238
msgid "Ready-to-go standalone Python launch-script, YAML-file with ROS parameters and filter mask example for Speed Filter could be found in a `nav2_costmap_filters_demo <https://github.com/ros-planning/navigation2_tutorials/tree/master/nav2_costmap_filters_demo>`_ directory of ``navigation2_tutorials`` repository. To simply run Filter Info Publisher Server and Map Server tuned on Turtlebot3 standard simulation written at :ref:`getting_started`, build the demo and launch ``costmap_filter_info.launch.py`` as follows:"
msgstr "Ready-to-go standalone Python launch-script, YAML-file with ROS parameters and filter mask example for Speed Filter could be found in a `nav2_costmap_filters_demo <https://github.com/ros-planning/navigation2_tutorials/tree/master/nav2_costmap_filters_demo>`_ directory of ``navigation2_tutorials`` repository. To simply run Filter Info Publisher Server and Map Server tuned on Turtlebot3 standard simulation written at :ref:`getting_started`, build the demo and launch ``costmap_filter_info.launch.py`` as follows:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:251
msgid "3. Enable Speed Filter"
msgstr "3. Enable Speed Filter"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:253
msgid "Costmap Filters are Costmap2D plugins. You can enable the ``SpeedFilter`` plugin in Costmap2D by adding ``speed_filter`` to the ``plugins`` parameter in ``nav2_params.yaml``. The Speed Filter plugin should have the following parameters defined:"
msgstr "Costmap Filters are Costmap2D plugins. You can enable the ``SpeedFilter`` plugin in Costmap2D by adding ``speed_filter`` to the ``plugins`` parameter in ``nav2_params.yaml``. The Speed Filter plugin should have the following parameters defined:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:255
msgid "``plugin``: type of plugin. In our case ``nav2_costmap_2d::SpeedFilter``."
msgstr "``plugin``: type of plugin. In our case ``nav2_costmap_2d::SpeedFilter``."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:256
msgid "``filter_info_topic``: filter info topic name. This needs to be equal to ``filter_info_topic`` parameter of Costmap Filter Info Publisher Server from the chapter above."
msgstr "``filter_info_topic``: filter info topic name. This needs to be equal to ``filter_info_topic`` parameter of Costmap Filter Info Publisher Server from the chapter above."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:257
msgid "``speed_limit_topic``: name of topic to publish speed limit to."
msgstr "``speed_limit_topic``: name of topic to publish speed limit to."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:259
msgid "Full list of parameters supported by ``SpeedFilter`` are listed at the :ref:`speed_filter` page."
msgstr "Full list of parameters supported by ``SpeedFilter`` are listed at the :ref:`speed_filter` page."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:261
msgid "You can place the plugin either in the ``global_costmap`` section in ``nav2_params.yaml`` to have speed restriction mask applied to global costmap or in the ``local_costmap`` to apply speed mask to the local costmap. However, ``SpeedFilter`` plugin should never be enabled simultaneously for global and local costmaps. Otherwise, it can lead to unwanted multiple \"speed restriction\" - \"no restriction\" message chains on speed restriction boundaries, that will cause jerking of the robot or another unpredictable behaviour."
msgstr "You can place the plugin either in the ``global_costmap`` section in ``nav2_params.yaml`` to have speed restriction mask applied to global costmap or in the ``local_costmap`` to apply speed mask to the local costmap. However, ``SpeedFilter`` plugin should never be enabled simultaneously for global and local costmaps. Otherwise, it can lead to unwanted multiple \"speed restriction\" - \"no restriction\" message chains on speed restriction boundaries, that will cause jerking of the robot or another unpredictable behaviour."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:263
msgid "In this tutorial, we will enable Speed Filter for the global costmap. For this use the following configuration:"
msgstr "In this tutorial, we will enable Speed Filter for the global costmap. For this use the following configuration:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:280
msgid "As stated in the `design <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, Speed Filter publishes speed restricting `messages <https://github.com/ros-planning/navigation2/blob/main/nav2_msgs/msg/SpeedLimit.msg>`_ targeted for a Controller Server so that it could restrict maximum speed of the robot when it needed. Controller Server has a ``speed_limit_topic`` ROS parameter for that, which should be set to the same as in ``speed_filter`` plugin value. This topic in the map server could also be used to any number of other speed-restricted applications beyond the speed limiting zones, such as dynamically adjusting maximum speed by payload mass."
msgstr "As stated in the `design <https://github.com/ros-planning/navigation2/blob/main/doc/design/CostmapFilters_design.pdf>`_, Speed Filter publishes speed restricting `messages <https://github.com/ros-planning/navigation2/blob/main/nav2_msgs/msg/SpeedLimit.msg>`_ targeted for a Controller Server so that it could restrict maximum speed of the robot when it needed. Controller Server has a ``speed_limit_topic`` ROS parameter for that, which should be set to the same as in ``speed_filter`` plugin value. This topic in the map server could also be used to any number of other speed-restricted applications beyond the speed limiting zones, such as dynamically adjusting maximum speed by payload mass."


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:282
msgid "Set ``speed_limit_topic`` parameter of a Controller Server to the same value as it set for ``speed_filter`` plugin:"
msgstr "Set ``speed_limit_topic`` parameter of a Controller Server to the same value as it set for ``speed_filter`` plugin:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:295
msgid "After Costmap Filter Info Publisher Server and Map Server were launched and Speed Filter was enabled for global/local costmap, run Nav2 stack as written in :ref:`getting_started`:"
msgstr "After Costmap Filter Info Publisher Server and Map Server were launched and Speed Filter was enabled for global/local costmap, run Nav2 stack as written in :ref:`getting_started`:"


#: ../../tutorials/docs/navigation2_with_speed_filter.rst:301
msgid "For better visualization of speed filter mask, in RViz in the left ``Displays`` pane unfold ``Map`` and change ``Topic`` from ``/map`` -> to ``/speed_filter_mask``. Set the goal behind the speed restriction areas and check that the filter is working properly: robot should slow down when going through a speed restricting areas. Below is how it might look (first picture shows speed filter enabled for the global costmap, second - ``speed_mask.pgm`` filter mask):"
msgstr "For better visualization of speed filter mask, in RViz in the left ``Displays`` pane unfold ``Map`` and change ``Topic`` from ``/map`` -> to ``/speed_filter_mask``. Set the goal behind the speed restriction areas and check that the filter is working properly: robot should slow down when going through a speed restricting areas. Below is how it might look (first picture shows speed filter enabled for the global costmap, second - ``speed_mask.pgm`` filter mask):"


#: ../../tutorials/docs/navigation2_with_stvl.rst:4
msgid "(STVL) Using an External Costmap Plugin"
msgstr "(STVL) Using an External Costmap Plugin"


#: ../../tutorials/docs/navigation2_with_stvl.rst:7
msgid "`Costmap2D and STVL`_"
msgstr "`Costmap2D and STVL`_"


#: ../../tutorials/docs/navigation2_with_stvl.rst:21
msgid "This tutorial shows how to load and use an external plugin. This example uses the `Spatio Temporal Voxel Layer <https://github.com/SteveMacenski/spatio_temporal_voxel_layer/>`_ (STVL) costmap `pluginlib <http://wiki.ros.org/pluginlib/>`_ plugin as an example. STVL is a demonstrative pluginlib plugin and the same process can be followed for other costmap plugins as well as plugin planners, controllers, and behaviors."
msgstr "This tutorial shows how to load and use an external plugin. This example uses the `Spatio Temporal Voxel Layer <https://github.com/SteveMacenski/spatio_temporal_voxel_layer/>`_ (STVL) costmap `pluginlib <http://wiki.ros.org/pluginlib/>`_ plugin as an example. STVL is a demonstrative pluginlib plugin and the same process can be followed for other costmap plugins as well as plugin planners, controllers, and behaviors."


#: ../../tutorials/docs/navigation2_with_stvl.rst:25
msgid "Before completing this tutorial, please look at the previous two tutorials on navigation in simulation and physical hardware, if available. This tutorial assumes knowledge of navigation and basic understanding of costmaps."
msgstr "Before completing this tutorial, please look at the previous two tutorials on navigation in simulation and physical hardware, if available. This tutorial assumes knowledge of navigation and basic understanding of costmaps."


#: ../../tutorials/docs/navigation2_with_stvl.rst:30
msgid "For Ubuntu 20.04 users before December 2021, there's a known issue with OpenVDB and its binaries with ``libjmalloc``. If you see an error such as ``Could not load library LoadLibrary error: /usr/lib/x86_64-linux-gnu/libjemalloc.so.2: cannot allocate memory in static TLS block``, it can be resolved with ``export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2`` until new binaries are released of OpenVDB."
msgstr "For Ubuntu 20.04 users before December 2021, there's a known issue with OpenVDB and its binaries with ``libjmalloc``. If you see an error such as ``Could not load library LoadLibrary error: /usr/lib/x86_64-linux-gnu/libjemalloc.so.2: cannot allocate memory in static TLS block``, it can be resolved with ``export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2`` until new binaries are released of OpenVDB."


#: ../../tutorials/docs/navigation2_with_stvl.rst:34
msgid "Costmap2D and STVL"
msgstr "Costmap2D and STVL"


#: ../../tutorials/docs/navigation2_with_stvl.rst:36
msgid "Costmap 2D is the data object we use to buffer sensor information into a global view that the robot will use to create plans and control efforts. Within Costmap2D, there are pluginlib plugin interfaces available to create custom behaviors loadable at runtime. Examples of included pluginlib plugins for Costmap2D are the Obstacle Layer, Voxel Layer, Static Layer, and Inflation Layer."
msgstr "Costmap 2D is the data object we use to buffer sensor information into a global view that the robot will use to create plans and control efforts. Within Costmap2D, there are pluginlib plugin interfaces available to create custom behaviors loadable at runtime. Examples of included pluginlib plugins for Costmap2D are the Obstacle Layer, Voxel Layer, Static Layer, and Inflation Layer."


#: ../../tutorials/docs/navigation2_with_stvl.rst:40
msgid "However, these are simply example plugins offered by the base implementation. Another available pluginlib plugin for Costmap2D in Navigation2 is STVL."
msgstr "However, these are simply example plugins offered by the base implementation. Another available pluginlib plugin for Costmap2D in Navigation2 is STVL."


#: ../../tutorials/docs/navigation2_with_stvl.rst:43
msgid "STVL is another 3D perception plugin similar to the Voxel Layer. A more detailed overview of how it works can be found `in this repo <https://github.com/SteveMacenski/spatio_temporal_voxel_layer/>`_, however it buffers 3D data from depth cameras, sonars, lidars, and more into a sparse volumetic world model and removes voxels over time proportional with a sensor model and time-based expiration. This can be especially useful for robots in highly dynamic envrionments and decreases the resource utilization for 3D sensor processing by up to 2x. STVL also treats 3D lidars and radars as first class citizens for support. The ROSCon talk for STVL can be found `in this video <https://vimeo.com/292699571>`_."
msgstr "STVL is another 3D perception plugin similar to the Voxel Layer. A more detailed overview of how it works can be found `in this repo <https://github.com/SteveMacenski/spatio_temporal_voxel_layer/>`_, however it buffers 3D data from depth cameras, sonars, lidars, and more into a sparse volumetic world model and removes voxels over time proportional with a sensor model and time-based expiration. This can be especially useful for robots in highly dynamic envrionments and decreases the resource utilization for 3D sensor processing by up to 2x. STVL also treats 3D lidars and radars as first class citizens for support. The ROSCon talk for STVL can be found `in this video <https://vimeo.com/292699571>`_."


#: ../../tutorials/docs/navigation2_with_stvl.rst:53
msgid "0- Setup"
msgstr "0- Setup"


#: ../../tutorials/docs/navigation2_with_stvl.rst:55
msgid "Follow the same process as in :ref:`getting_started` for installing and setting up a robot for hardware testing or simulation, as applicable. Ensure ROS 2, Navigation2, and Gazebo are installed."
msgstr "Follow the same process as in :ref:`getting_started` for installing and setting up a robot for hardware testing or simulation, as applicable. Ensure ROS 2, Navigation2, and Gazebo are installed."


#: ../../tutorials/docs/navigation2_with_stvl.rst:58
msgid "1- Install STVL"
msgstr "1- Install STVL"


#: ../../tutorials/docs/navigation2_with_stvl.rst:60
msgid "STVL can be installed in ROS 2 via the ROS Build Farm:"
msgstr "STVL can be installed in ROS 2 via the ROS Build Farm:"


#: ../../tutorials/docs/navigation2_with_stvl.rst:62
msgid "``sudo apt install ros-<ros2-distro>-spatio-temporal-voxel-layer``"
msgstr "``sudo apt install ros-<ros2-distro>-spatio-temporal-voxel-layer``"


#: ../../tutorials/docs/navigation2_with_stvl.rst:64
msgid "It can also be built from source by cloning the repository into your Navigation2 workspace:"
msgstr "It can also be built from source by cloning the repository into your Navigation2 workspace:"


#: ../../tutorials/docs/navigation2_with_stvl.rst:66
msgid "``git clone -b <ros2-distro>-devel git@github.com:stevemacenski/spatio_temporal_voxel_layer``"
msgstr "``git clone -b <ros2-distro>-devel git@github.com:stevemacenski/spatio_temporal_voxel_layer``"


#: ../../tutorials/docs/navigation2_with_stvl.rst:69
msgid "1- Modify Navigation2 Parameter"
msgstr "1- Modify Navigation2 Parameter"


#: ../../tutorials/docs/navigation2_with_stvl.rst:71
msgid "STVL is an optional plugin, like all plugins, in Costmap2D. Costmap Plugins in Navigation2 are loaded in the ``plugin_names`` and ``plugin_types`` variables inside of their respective costmaps. For example, the following will load the static and obstacle layer plugins into the name ``static_layer`` and ``obstacle_layer``, respectively:"
msgstr "STVL is an optional plugin, like all plugins, in Costmap2D. Costmap Plugins in Navigation2 are loaded in the ``plugin_names`` and ``plugin_types`` variables inside of their respective costmaps. For example, the following will load the static and obstacle layer plugins into the name ``static_layer`` and ``obstacle_layer``, respectively:"


#: ../../tutorials/docs/navigation2_with_stvl.rst:85
msgid "For Galactic or later, ``plugin_names`` and ``plugin_types`` have been replaced with a single ``plugins`` string vector for plugin names. The types are now defined in the ``plugin_name`` namespace in the ``plugin:`` field (e.g. ``plugin: MyPlugin::Plugin``). Inline comments in the code blocks will help guide you through this."
msgstr "对于Galactic或更新版本，``plugin_names``和``plugin_types``已经被单个``plugins``字符串向量替代，用于插件名称。现在，类型在``plugin_name``命名空间中的``plugin:``字段中定义（例如：``plugin: MyPlugin::Plugin``）。代码块中的内联注释将帮助指导您完成此操作。"


#: ../../tutorials/docs/navigation2_with_stvl.rst:87
msgid "To load the STVL plugin, a new plugin name and type must be added. For example, if the application required an STVL layer and no obstacle layer, our file would be:"
msgstr "To load the STVL plugin, a new plugin name and type must be added. For example, if the application required an STVL layer and no obstacle layer, our file would be:"


#: ../../tutorials/docs/navigation2_with_stvl.rst:98
msgid "Similar to the Voxel Layer, after registering the plugin, we can add the configuration of the STVL layer under the namespace ``stvl_layer``. An example fully-described parameterization of an STVL configuration is:"
msgstr "Similar to the Voxel Layer, after registering the plugin, we can add the configuration of the STVL layer under the namespace ``stvl_layer``. An example fully-described parameterization of an STVL configuration is:"


#: ../../tutorials/docs/navigation2_with_stvl.rst:141
msgid "Please copy-paste the text above, with the ``plugin_names`` and ``plugin_types`` registration, into your ``nav2_params.yaml`` to enable STVL in your application. Make sure to change both the local and global costmaps."
msgstr "Please copy-paste the text above, with the ``plugin_names`` and ``plugin_types`` registration, into your ``nav2_params.yaml`` to enable STVL in your application. Make sure to change both the local and global costmaps."


#: ../../tutorials/docs/navigation2_with_stvl.rst:144
msgid "Note: Pluginlib plugins for other Navigation2 servers such as planning, behavior, and control can be set in this same way."
msgstr "Note: Pluginlib plugins for other Navigation2 servers such as planning, behavior, and control can be set in this same way."


#: ../../tutorials/docs/navigation2_with_stvl.rst:147
msgid "2- Launch Navigation2"
msgstr "2- Launch Navigation2"


#: ../../tutorials/docs/navigation2_with_stvl.rst:149
msgid "Follow the same process as in :ref:`getting_started` to launch a simulated robot in gazebo with Navigation2. Navigation2 is now using STVL as its 3D sensing costmap layer."
msgstr "Follow the same process as in :ref:`getting_started` to launch a simulated robot in gazebo with Navigation2. Navigation2 is now using STVL as its 3D sensing costmap layer."


#: ../../tutorials/docs/navigation2_with_stvl.rst:153
msgid "3-  RVIZ"
msgstr "3-  RVIZ"


#: ../../tutorials/docs/navigation2_with_stvl.rst:155
msgid "With RViz open and ``publish_voxel_map: true``, you can visualize the underlying data structure's 3D grid using the ``{local, global}_costmap/voxel_grid`` topics. Note: It is recommended in RViz to set the ``PointCloud2`` Size to your voxel size and the style to ``Boxes`` with a neutral color for best visualization."
msgstr "With RViz open and ``publish_voxel_map: true``, you can visualize the underlying data structure's 3D grid using the ``{local, global}_costmap/voxel_grid`` topics. Note: It is recommended in RViz to set the ``PointCloud2`` Size to your voxel size and the style to ``Boxes`` with a neutral color for best visualization."


#: ../../tutorials/docs/using_collision_monitor.rst:4
msgid "Using Collision Monitor"
msgstr "Using Collision Monitor"


#: ../../tutorials/docs/using_collision_monitor.rst:8
msgid "`Preparing Nav2 stack`_"
msgstr "`Preparing Nav2 stack`_"


#: ../../tutorials/docs/using_collision_monitor.rst:9
msgid "`Configuring Collision Monitor`_"
msgstr "`Configuring Collision Monitor`_"


#: ../../tutorials/docs/using_collision_monitor.rst:10 ../../tutorials/docs/using_shim_controller.rst:11
msgid "`Demo Execution`_"
msgstr "`Demo Execution`_"


#: ../../tutorials/docs/using_collision_monitor.rst:18
msgid "This tutorial shows how to use a Collision Monitor with Nav2 stack. Based on this tutorial, you can setup it for your environment and needs."
msgstr "This tutorial shows how to use a Collision Monitor with Nav2 stack. Based on this tutorial, you can setup it for your environment and needs."


#: ../../tutorials/docs/using_collision_monitor.rst:23
msgid "It is assumed ROS2 and Nav2 dependent packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made in :ref:`build-instructions`."
msgstr "It is assumed ROS2 and Nav2 dependent packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made in :ref:`build-instructions`."


#: ../../tutorials/docs/using_collision_monitor.rst:27
msgid "Configuring Collision Monitor"
msgstr "Configuring Collision Monitor"


#: ../../tutorials/docs/using_collision_monitor.rst:29
msgid "The Collision Monitor node has its own ``collision_monitor_node.launch.py`` launch-file and preset parameters in the ``collision_monitor_params.yaml`` file for demonstration, though its trivial to add this to Nav2's main launch file if being used in practice. For the demonstration, two shapes will be created - an inner stop and a larger slowdown bounding boxes placed in the front of the robot:"
msgstr "The Collision Monitor node has its own ``collision_monitor_node.launch.py`` launch-file and preset parameters in the ``collision_monitor_params.yaml`` file for demonstration, though its trivial to add this to Nav2's main launch file if being used in practice. For the demonstration, two shapes will be created - an inner stop and a larger slowdown bounding boxes placed in the front of the robot:"


#: ../../tutorials/docs/using_collision_monitor.rst:35
msgid "If more than 3 points will appear inside a slowdown box, the robot will decrease its speed to ``30%`` from its value. For the cases when obstacles are dangerously close to the robot, inner stop zone will work. For this setup, the following lines should be added into ``collision_monitor_params.yaml`` parameters file. Stop box is named as ``PolygonStop`` and slowdown bounding box - as ``PolygonSlow``:"
msgstr "If more than 3 points will appear inside a slowdown box, the robot will decrease its speed to ``30%`` from its value. For the cases when obstacles are dangerously close to the robot, inner stop zone will work. For this setup, the following lines should be added into ``collision_monitor_params.yaml`` parameters file. Stop box is named as ``PolygonStop`` and slowdown bounding box - as ``PolygonSlow``:"


#: ../../tutorials/docs/using_collision_monitor.rst:59
msgid "The circle shape could be used instead of polygon, e.g. for the case of omni-directional robots where the collision can occur from any direction. However, for the tutorial needs, let's focus our view on polygons. For the same reason, we leave out of scope the Approach model. Both of these cases could be easily enabled by referencing to the :ref:`configuring_collision_monitor` configuration guide."
msgstr "The circle shape could be used instead of polygon, e.g. for the case of omni-directional robots where the collision can occur from any direction. However, for the tutorial needs, let's focus our view on polygons. For the same reason, we leave out of scope the Approach model. Both of these cases could be easily enabled by referencing to the :ref:`configuring_collision_monitor` configuration guide."


#: ../../tutorials/docs/using_collision_monitor.rst:62
msgid "Both polygon shapes in the tutorial were set statically. However, there is an ability to dynamically adjust them over time using topic messages containing vertices points for polygons or footprints. For more information, please refer to the configuration guide."
msgstr "Both polygon shapes in the tutorial were set statically. However, there is an ability to dynamically adjust them over time using topic messages containing vertices points for polygons or footprints. For more information, please refer to the configuration guide."


#: ../../tutorials/docs/using_collision_monitor.rst:64
msgid "For the working configuration, at least one data source should be added. In current demonstration, it is used laser scanner (though ``PointCloud2`` and Range/Sonar/IR sensors are also possible), which is described by the following lines for Collision Monitor node:"
msgstr "For the working configuration, at least one data source should be added. In current demonstration, it is used laser scanner (though ``PointCloud2`` and Range/Sonar/IR sensors are also possible), which is described by the following lines for Collision Monitor node:"


#: ../../tutorials/docs/using_collision_monitor.rst:74
msgid "Set topic names, frame ID-s and timeouts to work correctly with a default Nav2 setup. The whole ``nav2_collision_monitor/params/collision_monitor_params.yaml`` file in this case will look as follows:"
msgstr "Set topic names, frame ID-s and timeouts to work correctly with a default Nav2 setup. The whole ``nav2_collision_monitor/params/collision_monitor_params.yaml`` file in this case will look as follows:"


#: ../../tutorials/docs/using_collision_monitor.rst:111
msgid "Preparing Nav2 stack"
msgstr "Preparing Nav2 stack"


#: ../../tutorials/docs/using_collision_monitor.rst:113
msgid "The Collision Monitor is designed to operate below Nav2 as an independent safety node. This acts as a filter on the ``cmd_vel`` topic coming out of the Controller Server. If no such zone is triggered, then the Controller's ``cmd_vel`` is used. Else, it is scaled or set to stop as appropriate. For correct operation of the Collision Monitor with the Controller, it is required to add the ``cmd_vel -> cmd_vel_raw`` remapping to the ``navigation_launch.py`` bringup script as presented below:"
msgstr "The Collision Monitor is designed to operate below Nav2 as an independent safety node. This acts as a filter on the ``cmd_vel`` topic coming out of the Controller Server. If no such zone is triggered, then the Controller's ``cmd_vel`` is used. Else, it is scaled or set to stop as appropriate. For correct operation of the Collision Monitor with the Controller, it is required to add the ``cmd_vel -> cmd_vel_raw`` remapping to the ``navigation_launch.py`` bringup script as presented below:"


#: ../../tutorials/docs/using_collision_monitor.rst:137
msgid "Please note, that the remapped ``cmd_vel_raw`` topic should match to the input velocity ``cmd_vel_in_topic`` parameter value of the Collision Monitor node, and the output velocity ``cmd_vel_out_topic`` parameter value should be actual ``cmd_vel`` to fit the replacement."
msgstr "Please note, that the remapped ``cmd_vel_raw`` topic should match to the input velocity ``cmd_vel_in_topic`` parameter value of the Collision Monitor node, and the output velocity ``cmd_vel_out_topic`` parameter value should be actual ``cmd_vel`` to fit the replacement."


#: ../../tutorials/docs/using_collision_monitor.rst:140 ../../tutorials/docs/using_shim_controller.rst:115
msgid "Demo Execution"
msgstr "Demo Execution"


#: ../../tutorials/docs/using_collision_monitor.rst:142
msgid "Once Collision Monitor node has been tuned and ``cmd_vel`` topics remapped, Collision Monitor node is ready to run. For that, run Nav2 stack as written in :ref:`getting_started`:"
msgstr "Once Collision Monitor node has been tuned and ``cmd_vel`` topics remapped, Collision Monitor node is ready to run. For that, run Nav2 stack as written in :ref:`getting_started`:"


#: ../../tutorials/docs/using_collision_monitor.rst:149
msgid "In parallel console, launch Collision Monitor node by using its launch-file:"
msgstr "In parallel console, launch Collision Monitor node by using its launch-file:"


#: ../../tutorials/docs/using_collision_monitor.rst:155
msgid "Since both ``PolygonStop`` and ``PolygonSlow`` polygons will have their own publishers, they could be added to visualization as shown at the picture below:"
msgstr "Since both ``PolygonStop`` and ``PolygonSlow`` polygons will have their own publishers, they could be added to visualization as shown at the picture below:"


#: ../../tutorials/docs/using_collision_monitor.rst:160
msgid "Set the initial pose and then put Nav2 goal on map. The robot will start its movement, slowing down while running near the obstacles, and stopping in close proximity to them:"
msgstr "Set the initial pose and then put Nav2 goal on map. The robot will start its movement, slowing down while running near the obstacles, and stopping in close proximity to them:"


#: ../../tutorials/docs/using_groot.rst:4
msgid "Groot - Interacting with Behavior Trees"
msgstr "Groot - Interacting with Behavior Trees"


#: ../../tutorials/docs/using_groot.rst:11
msgid "`Visualize Behavior Trees`_"
msgstr "`Visualize Behavior Trees`_"


#: ../../tutorials/docs/using_groot.rst:12
msgid "`Edit Behavior Trees`_"
msgstr "`Edit Behavior Trees`_"


#: ../../tutorials/docs/using_groot.rst:13
msgid "`Adding A Custom Node`_"
msgstr "`Adding A Custom Node`_"


#: ../../tutorials/docs/using_groot.rst:28
msgid "`Groot <https://github.com/BehaviorTree/Groot>`_ is the companion application of the `BehaviorTree.CPP <https://github.com/BehaviorTree/BehaviorTree.CPP>`_ library used to create, edit, and visualize behavior trees. Behavior Trees are deeply integrated into Nav2, used as the main method of orchestrating task server logic across a complex navigation and autonomy stack. Behavior Trees, in short BTs, consist of many nodes completing different tasks and control the flow of logic, similar to a Hierarchical or Finite State Machine, but organized in a tree structure. These nodes are of types: `Action`, `Condition`, `Control`, or `Decorator`, and are described in more detail in :ref:`concepts` and `BehaviorTree.CPP <https://www.behaviortree.dev/docs/learn-the-basics/BT_basics#types-of-nodes>`_."
msgstr "`Groot <https://github.com/BehaviorTree/Groot>`_ is the companion application of the `BehaviorTree.CPP <https://github.com/BehaviorTree/BehaviorTree.CPP>`_ library used to create, edit, and visualize behavior trees. Behavior Trees are deeply integrated into Nav2, used as the main method of orchestrating task server logic across a complex navigation and autonomy stack. Behavior Trees, in short BTs, consist of many nodes completing different tasks and control the flow of logic, similar to a Hierarchical or Finite State Machine, but organized in a tree structure. These nodes are of types: `Action`, `Condition`, `Control`, or `Decorator`, and are described in more detail in :ref:`concepts` and `BehaviorTree.CPP <https://www.behaviortree.dev/docs/learn-the-basics/BT_basics#types-of-nodes>`_."


#: ../../tutorials/docs/using_groot.rst:33
msgid ":ref:`writing_new_nbt_plugin` offers a well written example of creating a simple ``Action`` node if creating new BT nodes is of interest. This tutorial will focus solely on launching Groot, visualizing a Behavior Tree, and modifying that tree for a given customization, assuming a library of BT nodes. Luckily, Nav2 provides a robust number of BT nodes for your use out of the box, enumerated in :ref:`plugins`."
msgstr ":ref:`writing_new_nbt_plugin` offers a well written example of creating a simple ``Action`` node if creating new BT nodes is of interest. This tutorial will focus solely on launching Groot, visualizing a Behavior Tree, and modifying that tree for a given customization, assuming a library of BT nodes. Luckily, Nav2 provides a robust number of BT nodes for your use out of the box, enumerated in :ref:`plugins`."


#: ../../tutorials/docs/using_groot.rst:35
msgid "A BT configuration file in BehaviorTree.CPP is an XML file. This is used to dynamically load the BT node plugins at run-time from the appropriate libraries mapped to their names. The XML format is defined `in detail here <https://www.behaviortree.dev/docs/learn-the-basics/xml_format/>`_. Therefore, Groot needs to have a list of nodes it has access to and important metadata about them like their type and ports (or parameters). We refer to this as the \"pallet\" of nodes later in the tutorial."
msgstr "A BT configuration file in BehaviorTree.CPP is an XML file. This is used to dynamically load the BT node plugins at run-time from the appropriate libraries mapped to their names. The XML format is defined `in detail here <https://www.behaviortree.dev/docs/learn-the-basics/xml_format/>`_. Therefore, Groot needs to have a list of nodes it has access to and important metadata about them like their type and ports (or parameters). We refer to this as the \"pallet\" of nodes later in the tutorial."


#, python-format
msgid "In the video above you can see Groot side-by-side with RVIz and a test platform 100% equipped with ROS-enabled hardware from SIEMENS. Groot not only displays the current Behavior Tree while the robot is operating. Note: Before ROS 2 Humble, live Groot behavior tree monitoring during execution was supported in Nav2. This was removed due to buggy support in BT.CPP / Groot for changing behavior trees on the fly, see :ref:`galactic_migration` for more details."
msgstr "In the video above you can see Groot side-by-side with RVIz and a test platform 100% equipped with ROS-enabled hardware from SIEMENS. Groot not only displays the current Behavior Tree while the robot is operating. Note: Before ROS 2 Humble, live Groot behavior tree monitoring during execution was supported in Nav2. This was removed due to buggy support in BT.CPP / Groot for changing behavior trees on the fly, see :ref:`galactic_migration` for more details."


#: ../../tutorials/docs/using_groot.rst:41
msgid "Visualize Behavior Trees"
msgstr "Visualize Behavior Trees"


#: ../../tutorials/docs/using_groot.rst:43
msgid "To display a Behavior Tree like that in :numref:`groot_nav2_default_bt`, we will first start the Groot executable. Out of the box, Groot can only display Behavior Trees and nodes that are from the defaults in BT.CPP, since it does not know anything about Nav2 or your other projects. Therefore, we must point Groot to our pallet, or index, of Nav2 / custom behavior tree nodes:"
msgstr "To display a Behavior Tree like that in :numref:`groot_nav2_default_bt`, we will first start the Groot executable. Out of the box, Groot can only display Behavior Trees and nodes that are from the defaults in BT.CPP, since it does not know anything about Nav2 or your other projects. Therefore, we must point Groot to our pallet, or index, of Nav2 / custom behavior tree nodes:"


#: ../../tutorials/docs/using_groot.rst:47
msgid "Open Groot in editor mode. Now, Groot should look like in :numref:`groot_bt_editor`."
msgstr "Open Groot in editor mode. Now, Groot should look like in :numref:`groot_bt_editor`."


#: ../../tutorials/docs/using_groot.rst:48
msgid "Select the `Load palette from file` option either via the context menu or the import icon in the top middle of the menu bar."
msgstr "Select the `Load palette from file` option either via the context menu or the import icon in the top middle of the menu bar."


#: ../../tutorials/docs/using_groot.rst:49
msgid "Open the file `/path/to/navigation2/nav2_behavior_tree/nav2_tree_nodes.xml` to import all the custom behavior tree nodes used for navigation. This is the pallet of Nav2 custom behavior tree nodes. Now, Groot should look like in :numref:`groot_bt_editor_with_nodes`."
msgstr "Open the file `/path/to/navigation2/nav2_behavior_tree/nav2_tree_nodes.xml` to import all the custom behavior tree nodes used for navigation. This is the pallet of Nav2 custom behavior tree nodes. Now, Groot should look like in :numref:`groot_bt_editor_with_nodes`."


#: ../../tutorials/docs/using_groot.rst:50
msgid "Select `Load tree` option near the top left corner"
msgstr "Select `Load tree` option near the top left corner"


#: ../../tutorials/docs/using_groot.rst:51
msgid "Browse the tree you want to visualize, then select `OK`. The Nav2 BTs exist in `/path/to/navigation2/nav2_bt_navigator/behavior_trees/`"
msgstr "Browse the tree you want to visualize, then select `OK`. The Nav2 BTs exist in `/path/to/navigation2/nav2_bt_navigator/behavior_trees/`"


#: ../../tutorials/docs/using_groot.rst:57
msgid "Default Editor View"
msgstr "Default Editor View"


#: ../../tutorials/docs/using_groot.rst:57
msgid "Editor with Custom Nodes loaded in blue"
msgstr "Editor with Custom Nodes loaded in blue"


#: ../../tutorials/docs/using_groot.rst:60
msgid "If you select the default tree `navigate_w_replanning_and_recovery.xml`, then a Groot editor should look like :numref:`groot_nav2_default_bt`."
msgstr "If you select the default tree `navigate_w_replanning_and_recovery.xml`, then a Groot editor should look like :numref:`groot_nav2_default_bt`."


#: ../../tutorials/docs/using_groot.rst:66
msgid "Full Nav2 Default BehaviorTree"
msgstr "Full Nav2 Default BehaviorTree"


#: ../../tutorials/docs/using_groot.rst:70
msgid "If a tree cannot be visualized because some nodes are missing in the pallet, you might need to add it to your pallet. While we try to keep Nav2's BT nodes and pallets in sync, if you notice one is missing, please file a ticket or pull request and we should have that updated quickly."
msgstr "If a tree cannot be visualized because some nodes are missing in the pallet, you might need to add it to your pallet. While we try to keep Nav2's BT nodes and pallets in sync, if you notice one is missing, please file a ticket or pull request and we should have that updated quickly."


#: ../../tutorials/docs/using_groot.rst:74
msgid "Edit Behavior Trees"
msgstr "Edit Behavior Trees"


#: ../../tutorials/docs/using_groot.rst:76
msgid "Now that you have a Nav2 BT open in Groot in editor mode, you should be able to trivially modify it using the GUI. Starting from a screen like that shown in :numref:`groot_nav2_default_bt`, you can pull in new nodes from the side panel to add them to the workspace. You may then connect the nodes using a \"drag and drop\" motion between the node's input and output ports to assemble the new nodes into the tree."
msgstr "Now that you have a Nav2 BT open in Groot in editor mode, you should be able to trivially modify it using the GUI. Starting from a screen like that shown in :numref:`groot_nav2_default_bt`, you can pull in new nodes from the side panel to add them to the workspace. You may then connect the nodes using a \"drag and drop\" motion between the node's input and output ports to assemble the new nodes into the tree."


#: ../../tutorials/docs/using_groot.rst:80
msgid "If you select a given node, you can change metadata about it such as its name or values of parameterizable ports. When you're done modifying, simply save the new configuration file and use that on your robot the next time!"
msgstr "If you select a given node, you can change metadata about it such as its name or values of parameterizable ports. When you're done modifying, simply save the new configuration file and use that on your robot the next time!"


#: ../../tutorials/docs/using_groot.rst:83
msgid "Adding A Custom Node"
msgstr "Adding A Custom Node"


#: ../../tutorials/docs/using_groot.rst:85
msgid "Each node in the behavior tree holds a specialized function. Sometimes, its useful to create new nodes and add them to your pallet during the design process - perhaps before the implementations themselves exist. This helps designers abstract away the implementation specifics of the nodes from the higher level logic of the tree itself and how they'd like to interact with a given node (e.g. type, ports, etc). Within Groot, you may create new custom nodes to add to your tree and export these new nodes back to your pallet. Implementing the node itself needs to be done separately from Groot, which is described in :ref:`writing_new_nbt_plugin`."
msgstr "Each node in the behavior tree holds a specialized function. Sometimes, its useful to create new nodes and add them to your pallet during the design process - perhaps before the implementations themselves exist. This helps designers abstract away the implementation specifics of the nodes from the higher level logic of the tree itself and how they'd like to interact with a given node (e.g. type, ports, etc). Within Groot, you may create new custom nodes to add to your tree and export these new nodes back to your pallet. Implementing the node itself needs to be done separately from Groot, which is described in :ref:`writing_new_nbt_plugin`."


#: ../../tutorials/docs/using_groot.rst:95
msgid "Create a new Custom Node"
msgstr "Create a new Custom Node"


#: ../../tutorials/docs/using_groot.rst:98
msgid "Creating a new custom node can be started by clicking the orange marked icon in :numref:`groot_create_custom_node`, while Groot is in Editor mode. This should load a new window, similar to :numref:`groot_interactive_node_creation`. In this new window, it asks you to fill in the metadata about this new node, in order to create it. It will ask you for standard information such as name (green box), type of node (orange box), and any optional ports for parameterization or access to blackboard variables (blue box)."
msgstr "Creating a new custom node can be started by clicking the orange marked icon in :numref:`groot_create_custom_node`, while Groot is in Editor mode. This should load a new window, similar to :numref:`groot_interactive_node_creation`. In this new window, it asks you to fill in the metadata about this new node, in order to create it. It will ask you for standard information such as name (green box), type of node (orange box), and any optional ports for parameterization or access to blackboard variables (blue box)."


#: ../../tutorials/docs/using_groot.rst:103
msgid "After completing, select `OK` in :numref:`groot_interactive_node_creation`, the new custom node should appear in blue in the `TreeNode Palette` as in :numref:`groot_export_new_node`."
msgstr "After completing, select `OK` in :numref:`groot_interactive_node_creation`, the new custom node should appear in blue in the `TreeNode Palette` as in :numref:`groot_export_new_node`."


#: ../../tutorials/docs/using_groot.rst:110
msgid "UI to describing new Nodes"
msgstr "UI to describing new Nodes"


#: ../../tutorials/docs/using_groot.rst:110
msgid "Exporting the new Custom Node"
msgstr "Exporting the new Custom Node"


#: ../../tutorials/docs/using_groot.rst:113
msgid "Before starting to create a new BT based on the new custom nodes, it is recommend to export the newly created nodes to save in case of Groot crashing. This can be performed with the icon highlighted in green from :numref:`groot_export_new_node`. The resulting XML output from the node created in :numref:`groot_interactive_node_creation` can be seen below. You can see more examples in `Nav2's BT Node Pallet XML <https://github.com/ros-planning/navigation2/blob/main/nav2_behavior_tree/nav2_tree_nodes.xml>`_."
msgstr "Before starting to create a new BT based on the new custom nodes, it is recommend to export the newly created nodes to save in case of Groot crashing. This can be performed with the icon highlighted in green from :numref:`groot_export_new_node`. The resulting XML output from the node created in :numref:`groot_interactive_node_creation` can be seen below. You can see more examples in `Nav2's BT Node Pallet XML <https://github.com/ros-planning/navigation2/blob/main/nav2_behavior_tree/nav2_tree_nodes.xml>`_."


#: ../../tutorials/docs/using_shim_controller.rst:4
msgid "Using Rotation Shim Controller"
msgstr "Using Rotation Shim Controller"


#: ../../tutorials/docs/using_shim_controller.rst:8
msgid "`What is the Rotation Shim Controller?`_"
msgstr "`What is the Rotation Shim Controller?`_"


#: ../../tutorials/docs/using_shim_controller.rst:9
msgid "`Configuring Rotation Shim Controller`_"
msgstr "`Configuring Rotation Shim Controller`_"


#: ../../tutorials/docs/using_shim_controller.rst:10
msgid "`Configuring Primary Controller`_"
msgstr "`Configuring Primary Controller`_"


#: ../../tutorials/docs/using_shim_controller.rst:16
msgid "This tutorial will discuss how to set up your robot to use the ``RotationShimController`` to help create intuitive, rotate-in-place, behavior for your robot while starting out to track a path. The goal of this tutorial is to explain to the reader the value of the controller, how to configure it, how to configure the primary controller with it, and finally an example of it in use."
msgstr "This tutorial will discuss how to set up your robot to use the ``RotationShimController`` to help create intuitive, rotate-in-place, behavior for your robot while starting out to track a path. The goal of this tutorial is to explain to the reader the value of the controller, how to configure it, how to configure the primary controller with it, and finally an example of it in use."


#: ../../tutorials/docs/using_shim_controller.rst:18
msgid "Before starting this tutorial, completing the :ref:`getting_started` is highly recommended especially if you are new to ROS and Nav2. The requirements are having the latest install of Nav2 / ROS 2 containing this package."
msgstr "Before starting this tutorial, completing the :ref:`getting_started` is highly recommended especially if you are new to ROS and Nav2. The requirements are having the latest install of Nav2 / ROS 2 containing this package."


#: ../../tutorials/docs/using_shim_controller.rst:21
msgid "What is the Rotation Shim Controller?"
msgstr "What is the Rotation Shim Controller?"


#: ../../tutorials/docs/using_shim_controller.rst:23
msgid "This was developed due to quirks in TEB and DWB, but applicable to any other controller plugin type that you'd like to have rotation in place behavior with. ``TEB``'s behavior tends to whip the robot around with small turns, or when the path is starting at a very different heading than current, in a somewhat surprising way due to the elastic band approach. ``DWB`` can be tuned to have any type of behavior, but typically to tune it to be an excellent path follower also makes it less optimally capable of smooth transitions to new paths at far away headings -- there are always trade offs. Giving both TEB and DWB a better starting point to start tracking a path makes tuning the controllers significantly easier and creates more intuitive results for on-lookers."
msgstr "This was developed due to quirks in TEB and DWB, but applicable to any other controller plugin type that you'd like to have rotation in place behavior with. ``TEB``'s behavior tends to whip the robot around with small turns, or when the path is starting at a very different heading than current, in a somewhat surprising way due to the elastic band approach. ``DWB`` can be tuned to have any type of behavior, but typically to tune it to be an excellent path follower also makes it less optimally capable of smooth transitions to new paths at far away headings -- there are always trade offs. Giving both TEB and DWB a better starting point to start tracking a path makes tuning the controllers significantly easier and creates more intuitive results for on-lookers."


#: ../../tutorials/docs/using_shim_controller.rst:25
msgid "Note that it is not required to use this with **any** plugin. Many users are perfectly successful without using this controller, but if a robot may rotate in place before beginning its path tracking task (or others), it can be advantageous to do so."
msgstr "Note that it is not required to use this with **any** plugin. Many users are perfectly successful without using this controller, but if a robot may rotate in place before beginning its path tracking task (or others), it can be advantageous to do so."


#: ../../tutorials/docs/using_shim_controller.rst:27
msgid "The ``nav2_rotation_shim_controller`` will check the rough heading difference with respect to the robot and a newly received path. If within a threshold, it will pass the request onto the ``primary_controller`` to execute the task. If it is outside of the threshold, this controller will rotate the robot in place towards that path heading. Once it is within the tolerance, it will then pass off control-execution from this rotation shim controller onto the primary controller plugin. At this point, the robot's main plugin will take control for a smooth hand off into the task."
msgstr "“nav2_rotation_shim_controller”将检查与机器人和新接收的路径之间的大致方向差异。如果在一个阈值内，它将将请求传递给“primary_controller”来执行任务。如果超出阈值，该控制器将原地旋转机器人朝向该路径方向。一旦在容差范围内，它将从此旋转适配器控制器转移到主要控制器插件上执行控制。此时，机器人的主要插件将接管控制权，以平稳地过渡到任务。"


#: ../../tutorials/docs/using_shim_controller.rst:29
msgid "The ``RotationShimController`` is most suitable for:"
msgstr "``RotationShimController`` 最适用于以下情况："


#: ../../tutorials/docs/using_shim_controller.rst:31
msgid "Robots that can rotate in place, such as differential and omnidirectional robots."
msgstr "能够原地旋转的机器人，如差分驱动和全向驱动机器人。"


#: ../../tutorials/docs/using_shim_controller.rst:32
msgid "Preference to rotate in place when starting to track a new path that is at a significantly different heading than the robot's current heading -- or when tuning your controller for its task makes tight rotations difficult."
msgstr "在开始跟踪一个与机器人当前朝向显著不同的新路径时，或者在为任务调整控制器时，进行原地旋转的首选。"


#: ../../tutorials/docs/using_shim_controller.rst:33
msgid "Using planners that are non-kinematically feasible, such as NavFn, Theta\\*, or Smac 2D (Feasible planners such as Smac Hybrid-A* and State Lattice will start search from the robot's actual starting heading, requiring no rotation since their paths are guaranteed drivable by physical constraints)."
msgstr "使用非运动学可行的规划器，如 NavFn、Theta\\* 或 Smac 2D（可行的规划器如 Smac Hybrid-A* 和 State Lattice 将从机器人的实际起始方向开始搜索，不需要旋转，因为它们的路径在物理约束下是可行的）。"


#: ../../tutorials/docs/using_shim_controller.rst:36
msgid "Regulated Pure Pursuit has this built in so it is not necessary to pair with RPP. However, it is applicable to all others. See :ref:`plugins` for a full list of current controller plugins."
msgstr "Regulated Pure Pursuit has this built in so it is not necessary to pair with RPP. However, it is applicable to all others. See :ref:`plugins` for a full list of current controller plugins."


#: ../../tutorials/docs/using_shim_controller.rst:39
msgid "Configuring Rotation Shim Controller"
msgstr "Configuring Rotation Shim Controller"


#: ../../tutorials/docs/using_shim_controller.rst:41
msgid "This controller is a *shim* because it is placed between the primary controller plugin and the controller server. It takes commands and pre-processes them to rotate to the heading and then passes off execution-control to the primary plugin once that condition is met - acting as a simple pass through."
msgstr "This controller is a *shim* because it is placed between the primary controller plugin and the controller server. It takes commands and pre-processes them to rotate to the heading and then passes off execution-control to the primary plugin once that condition is met - acting as a simple pass through."


#: ../../tutorials/docs/using_shim_controller.rst:43
msgid "As such, its configuration looks very similar to that of any other plugin. In the code block below, you can see that we've added the ``RotationShimController`` as the plugin for path tracking in the controller server. You can see that we've also configured it below with its internal parameters, ``angular_dist_threshold`` through ``max_angular_accel``."
msgstr "As such, its configuration looks very similar to that of any other plugin. In the code block below, you can see that we've added the ``RotationShimController`` as the plugin for path tracking in the controller server. You can see that we've also configured it below with its internal parameters, ``angular_dist_threshold`` through ``max_angular_accel``."


#: ../../tutorials/docs/using_shim_controller.rst:74
msgid "The Rotation Shim Controller is very simple and only has a couple of parameters to dictate the conditions it should be enacted."
msgstr "The Rotation Shim Controller is very simple and only has a couple of parameters to dictate the conditions it should be enacted."


#: ../../tutorials/docs/using_shim_controller.rst:76
msgid "``angular_dist_threshold``: The angular distance (in radians) apart from the robot's current heading and the approximated path heading to trigger the rotation behavior. Once the robot is within this threshold, control is handed over to the primary controller plugin."
msgstr "``angular_dist_threshold``: The angular distance (in radians) apart from the robot's current heading and the approximated path heading to trigger the rotation behavior. Once the robot is within this threshold, control is handed over to the primary controller plugin."


#: ../../tutorials/docs/using_shim_controller.rst:77
msgid "``forward_sampling_distance``: The distance (in meters) away from the robot to select a point on the path to approximate the path's starting heading at. This is analogous to a \"lookahead\" point."
msgstr "``forward_sampling_distance``: The distance (in meters) away from the robot to select a point on the path to approximate the path's starting heading at. This is analogous to a \"lookahead\" point."


#: ../../tutorials/docs/using_shim_controller.rst:78
msgid "``rotate_to_heading_angular_vel``: The angular velocity (in rad/s) to have the robot rotate to heading by, when the behavior is enacted."
msgstr "``rotate_to_heading_angular_vel``: The angular velocity (in rad/s) to have the robot rotate to heading by, when the behavior is enacted."


#: ../../tutorials/docs/using_shim_controller.rst:79
msgid "``max_angular_accel``: The angular acceleration (in rad/s/s) to have the robot rotate to heading by, when the behavior is enacted."
msgstr "``max_angular_accel``: The angular acceleration (in rad/s/s) to have the robot rotate to heading by, when the behavior is enacted."


#: ../../tutorials/docs/using_shim_controller.rst:80
msgid "``simulate_ahead_time``: The Time (s) to forward project the rotation command to check for collision"
msgstr "``simulate_ahead_time``: The Time (s) to forward project the rotation command to check for collision"


#: ../../tutorials/docs/using_shim_controller.rst:83
msgid "Configuring Primary Controller"
msgstr "Configuring Primary Controller"


#: ../../tutorials/docs/using_shim_controller.rst:85
msgid "There is one more remaining parameter of the ``RotationShimController`` not mentioned above, the ``primary_controller``. This is the type of controller that your application would like to use as the primary modus operandi. It will share the same name and yaml namespace as the shim plugin. You can observe this below with the primary controller set the ``DWB`` (with the progress and goal checkers removed for brevity)."
msgstr "There is one more remaining parameter of the ``RotationShimController`` not mentioned above, the ``primary_controller``. This is the type of controller that your application would like to use as the primary modus operandi. It will share the same name and yaml namespace as the shim plugin. You can observe this below with the primary controller set the ``DWB`` (with the progress and goal checkers removed for brevity)."


#: ../../tutorials/docs/using_shim_controller.rst:111
msgid "An important note is that **within the same yaml namespace**, you may also include any ``primary_controller`` specific parameters required for a robot. Thusly, after ``max_angular_accel``, you can include any of ``DWB``'s parameters for your platform."
msgstr "An important note is that **within the same yaml namespace**, you may also include any ``primary_controller`` specific parameters required for a robot. Thusly, after ``max_angular_accel``, you can include any of ``DWB``'s parameters for your platform."


#: ../../tutorials/index.rst:4
msgid "General Tutorials"
msgstr "General Tutorials"


#: ../../tutorials/index.rst:6
msgid "Navigation2 Tutorials"
msgstr "Navigation2教程"

