# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020
# This file is distributed under the same license as the Navigation 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Navigation 2 latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-18 21:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:4
msgid "Writing a New Behavior Plugin"
msgstr "编写新的行为插件"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:6 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:6 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:6 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:6 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:6 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:6
msgid "`Overview`_"
msgstr "`概述`_"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:7 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:7 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:7 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:7 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:7 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:7
msgid "`Requirements`_"
msgstr "`要求`_"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:8 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:8 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:8 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:8 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:8 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:8
msgid "`Tutorial Steps`_"
msgstr "`教程步骤`_"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:11 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:11 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:16 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:17 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:16 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:11
msgid "Overview"
msgstr "概述"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:13
msgid "This tutorial shows how to create you own Behavior Plugin. The Behavior Plugins live in the behavior server. Unlike the planner and controller servers, each behavior will host its own unique action server. The planners and controllers have the same API as they accomplish the same task. However, recoveries can be used to do a wide variety of tasks, so each behavior can have its own unique action message definition and server. This allows for massive flexibility in the behavior server enabling any behavior action imaginable that doesn't need to have other reuse."
msgstr "本教程展示了如何创建自己的行为插件。行为插件位于行为服务器中。与规划器和控制器服务器不同，每个行为将拥有自己独特的动作服务器。规划器和控制器具有相同的API，因为它们执行相同的任务。然而，恢复可以用于执行各种各样的任务，因此每个行为可以拥有自己独特的动作消息定义和服务器。这使得行为服务器具有极大的灵活性，可以实现任何可能的行为动作，而无需进行其他的重用。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:21 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:17 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:23 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:28 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:21 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:20
msgid "Requirements"
msgstr "要求"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:23 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:19 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:30 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:23 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:22
msgid "ROS 2 (binary or build-from-source)"
msgstr "ROS 2（二进制或源码编译）"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:24 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:20 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:31 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:24 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:23
msgid "Nav2 (Including dependencies)"
msgstr "Nav2（包括依赖项）"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:25 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:21 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:32 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:25 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:24
msgid "Gazebo"
msgstr "Gazebo"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:26 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:22 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:33 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:26 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:25
msgid "Turtlebot3"
msgstr "Turtlebot3"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:29 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:25 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:28 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:36 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:29 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:28
msgid "Tutorial Steps"
msgstr "`教程步骤`"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:32
msgid "1- Creating a new Behavior Plugin"
msgstr "1- 创建一个新的行为插件"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:34
msgid "We will create a simple send sms behavior. It will use Twilio to send a message via SMS to a remote operations center. The code in this tutorial can be found in `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ repository as ``nav2_sms_behavior``. This package can be a considered as a reference for writing Behavior Plugin."
msgstr "我们将创建一个简单的发送短信行为。它将使用Twilio通过短信向远程运营中心发送消息。本教程中的代码可以在 `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ 仓库的 ``nav2_sms_behavior`` 中找到。该软件包可作为编写行为插件的参考。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:39
msgid "Our example plugin implements the plugin class of ``nav2_core::Behavior``. However, we have a nice wrapper for actions in ``nav2_behaviors``, so we use the ``nav2_behaviors::TimedBehavior`` base class for this application instead. This wrapper class derives from the ``nav2_core`` class so it can be used as a plugin, but handles the vast majority of ROS 2 action server boiler plate required."
msgstr "我们的示例插件实现了 ``nav2_core::Behavior`` 的插件类。但是，我们在 ``nav2_behaviors`` 中有一个很好的动作包装器，因此我们在此应用程序中使用 ``nav2_behaviors::TimedBehavior`` 基类。这个包装器类派生自 ``nav2_core`` 类，因此可以用作插件，但处理了所需的大部分 ROS 2 动作服务器样板代码。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:43
msgid "The base class from ``nav2_core`` provides 4 pure virtual methods to implement a Behavior Plugin. The plugin will be used by the behavior server to host the plugins, but each plugin will provide their own unique action server interface. Let's learn more about the methods needed to write a Behavior Plugin **if you did not use the ``nav2_behaviors`` wrapper**."
msgstr "``nav2_core`` 中的基类提供了4个纯虚方法来实现行为插件。行为服务器将使用插件来托管插件，但每个插件将提供自己独特的动作服务器接口。让我们了解更多关于编写行为插件所需的方法**如果您没有使用``nav2_behaviors``封装**。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:48 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:72 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:42 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:42
msgid "**Virtual method**"
msgstr "**虚拟方法**"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:48 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:72 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:42 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:42
msgid "**Method description**"
msgstr "**方法描述**"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:48 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:72 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:49 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:42 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:42
msgid "**Requires override?**"
msgstr "**需要重写？**"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:50 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:51 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:44 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:47
msgid "configure()"
msgstr "configure()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:50
msgid "Method is called at when server enters on_configure state. Ideally this method should perform declarations of ROS parameters and initialization of behavior's member variables. This method takes 4 input parameters: shared pointer to parent node, behavior name, tf buffer pointer and shared pointer to a collision checker."
msgstr "当服务器进入 on_configure 状态时调用该方法。理想情况下，此方法应该执行 ROS 参数的声明和行为成员变量的初始化。此方法接受 4 个输入参数：父节点的共享指针、行为名称、tf 缓冲指针和碰撞检查器的共享指针。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:50 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:56 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:60 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:64 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:74 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:78 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:51 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:55 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:55 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:62 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:76 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:51 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:56 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:60 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:64 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:67 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:70 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:76 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:44 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:50 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:54 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:58 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:61 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:44 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:62 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:67 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:70 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:76 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:79
msgid "Yes"
msgstr "是"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:56 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:56 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:50 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:51
msgid "activate()"
msgstr "activate()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:56
msgid "Method is called when behavior server enters on_activate state. Ideally this method should implement operations which are neccessary before the behavior goes to an active state."
msgstr "当行为服务器进入on_activate状态时调用该方法。理想情况下，此方法应实现在行为进入活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:60 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:60 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:54 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:55
msgid "deactivate()"
msgstr "deactivate()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:60
msgid "Method is called when behavior server enters on_deactivate state. Ideally this method should implement operations which are neccessary before behavior goes to an inactive state."
msgstr "当行为服务器进入on_deactivate状态时调用该方法。理想情况下，此方法应实现在行为进入非活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:64 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:64 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:58 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:59
msgid "cleanup()"
msgstr "cleanup()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:64 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:86
msgid "Method is called when behavior server goes to on_cleanup state. Ideally this method should clean up resources which are created for the behavior."
msgstr "当行为服务器进入on_cleanup状态时调用该方法。理想情况下，此方法应清理为行为创建的资源。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:68
msgid "For the ``nav2_behaviors`` wrapper, which provides the ROS 2 action interface and boilerplate, we have 4 virtual methods to implement. This tutorial uses this wrapper so these are the main elements we will address."
msgstr "对于提供ROS 2动作接口和样板代码的``nav2_behaviors``包装器，我们有4个虚拟方法需要实现。本教程使用这个包装器，因此我们将解决以下主要要素。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:74
msgid "onRun()"
msgstr "onRun()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:74
msgid "Method is called immediately when a new behavior action request is received. Gives the action goal to process and should start behavior initialization / process."
msgstr "当接收到新的行为动作请求时立即调用该方法。将行为目标传递给处理，并应启动行为初始化/处理。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:78
msgid "onCycleUpdate()"
msgstr "onCycleUpdate()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:78
msgid "Method is called at the behavior update rate and should complete any necessary updates. An example for spinning is computing the command velocity for the current cycle, publishing it and checking for completion."
msgstr "以行为更新速率调用该方法，并应完成任何必要的更新。例如，对于旋转，可以计算当前周期的命令速度，将其发布并检查完成情况。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:82
msgid "onConfigure()"
msgstr "onConfigure()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:82
msgid "Method is called when behavior server enters on_configure state. Ideally this method should implement operations which are neccessary before behavior goes to a configured state (get parameters, etc)."
msgstr "当行为服务器进入on_configure状态时调用该方法。理想情况下，此方法应该实现在行为进入已配置状态之前必需的操作（获取参数等）。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:82 ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:86 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:59 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:63 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:68 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:71 ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:74 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:51 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:72 ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:74 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:47 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:51 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:55 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:59
msgid "No"
msgstr "No"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:86
msgid "onCleanup()"
msgstr "onCleanup()"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:90
msgid "For this tutorial, we will be using methods ``onRun()``, ``onCycleUpdate()``, and ``onConfigure()`` to create the SMS behavior. ``onConfigure()`` will be skipped for brevity, but only declares parameters."
msgstr "对于本教程，我们将使用``onRun()``, ``onCycleUpdate()``和``onConfigure()``方法来创建短信行为。为了简洁起见，我们将跳过``onConfigure()``，但仅声明参数。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:93
msgid "In recoveries, ``onRun()`` method must set any initial state and kick off the behavior. For the case of our call for help behavior, we can trivially compute all of our needs in this method."
msgstr "在恢复中，``onRun()`` 方法必须设置任何初始状态并启动行为。对于我们的求助行为，我们可以在此方法中轻松计算出所有需要的内容。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:118
msgid "We receive an action goal, ``command``, which we want to process. ``command`` contains a field ``message`` that contains the message we want to communicate to our mothership. This is the \"call for help\" message that we want to send via SMS to our brothers in arms in the operations center."
msgstr "我们接收到一个动作目标``command``，我们想要处理它。``command``包含一个字段``message``，其中包含我们想要通过短信发送给作战指挥中心的消息。这是我们希望发送的“求救”短信，以便将其发送给我们的战友。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:122
msgid "We use the service Twilio to complete this task. Please `create an account <https://www.twilio.com/>`_ and get all the relavent information needed for creating the service (e.g. ``account_sid``, ``auth_token``, and a phone number). You can set these values as parameters in your configuration files corresponding to the ``onConfigure()`` parameter declarations."
msgstr "我们使用 Twilio 服务完成此任务。请`创建一个账户 <https://www.twilio.com/>`_，并获取创建该服务所需的所有相关信息（例如 ``account_sid``、``auth_token`` 和一个电话号码）。您可以将这些值作为参数设置到与 ``onConfigure()`` 参数声明相对应的配置文件中。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:126
msgid "We use the ``_twilio`` object to send our message with your account information from the configuration file. We send the message and log to screen whether or not the message was sent successfully or not. We return a ``FAILED`` or ``SUCCEEDED`` depending on this value to be returned to the action client."
msgstr "我们使用``_twilio``对象发送带有配置文件中的账户信息的消息。我们发送消息，并在屏幕上记录消息是否成功发送。根据这个值，我们返回``FAILED``或``SUCCEEDED``，以便返回给动作客户端。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:130
msgid "``onCycleUpdate()`` is trivially simple as a result of our short-running behavior. If the behavior was instead longer running like spinning, navigating to a safe area, or getting out of a bad spot and waiting for help, then this function would be checking for timeouts or computing control values. For our example, we simply return success because we already completed our mission in ``onRun()``."
msgstr "``onCycleUpdate()`` 对于我们这个短时运行的行为来说非常简单。如果行为需要长时间运行，例如旋转、导航到安全区域或离开危险区域并等待帮助，那么此函数将检查超时或计算控制值。对于我们的示例，我们简单地返回成功，因为我们已经在 ``onRun()`` 中完成了我们的任务。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:141
msgid "The remaining methods are not used and are not mandatory to override them."
msgstr "剩余的方法未被使用，不需要强制重写它们。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:144
msgid "2- Exporting the Behavior Plugin"
msgstr "2- 导出行为插件"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:146
msgid "Now that we have created our custom behavior, we need to export our Behavior Plugin so that it would be visible to the behavior server. Plugins are loaded at runtime and if they are not visible, then our behavior server won't be able to load it. In ROS 2, exporting and loading plugins is handled by ``pluginlib``."
msgstr "现在我们已经创建了自定义行为，我们需要导出我们的行为插件，以便行为服务器能够看到它。插件在运行时加载，如果它们不可见，那么我们的行为服务器将无法加载它。在ROS 2中，导出和加载插件由``pluginlib``处理。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:148
msgid "Coming to our tutorial, class ``nav2_sms_bahavior::SendSms`` is loaded dynamically as ``nav2_core::Behavior`` which is our base class."
msgstr "在我们的教程中，``nav2_sms_bahavior::SendSms`` 类以 ``nav2_core::Behavior`` 动态加载，它是我们的基类。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:150
msgid "To export the behavior, we need to provide two lines"
msgstr "要导出该行为，我们需要提供两行代码。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:157 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:150
msgid "Note that it requires pluginlib to export out plugin's class. Pluginlib would provide as macro ``PLUGINLIB_EXPORT_CLASS`` which does all the work of exporting."
msgstr "请注意，它需要 pluginlib 来导出插件的类。Pluginlib 提供了宏 ``PLUGINLIB_EXPORT_CLASS``，它完成了所有的导出工作。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:159
msgid "It is good practice to place these lines at the end of the file but technically, you can also write at the top."
msgstr "按照惯例，将这些代码放在文件末尾是一个好的做法，但从技术上讲，也可以放在文件顶部。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:161
msgid "Next step would be to create plugin's description file in the root directory of the package. For example, ``behavior_plugin.xml`` file in our tutorial package. This file contains following information"
msgstr "下一步是在软件包的根目录中创建插件描述文件。例如，在我们的教程软件包中，我们可以创建一个名为``behavior_plugin.xml``的文件。该文件包含以下信息"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:163 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:282
msgid "``library path``: Plugin's library name and it's location."
msgstr "``library path``：插件的库名称和位置。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:164 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:219 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:157 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:283
msgid "``class name``: Name of the class."
msgstr "``class name``：类的名称。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:165 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:220 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:158 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:284
msgid "``class type``: Type of class."
msgstr "``class type``：类的类型。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:166 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:221 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:159 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:285
msgid "``base class``: Name of the base class."
msgstr "``base class``：基类的名称。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:167 ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:222 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:160 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:286
msgid "``description``: Description of the plugin."
msgstr "``description``：插件的描述。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:177 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:170
msgid "Next step would be to export plugin using ``CMakeLists.txt`` by using cmake function ``pluginlib_export_plugin_description_file()``. This function installs plugin description file to ``share`` directory and sets ament indexes to make it discoverable."
msgstr "下一步是使用``CMakeLists.txt``通过使用cmake函数``pluginlib_export_plugin_description_file()``导出插件。此函数将插件描述文件安装到``share``目录，并设置ament索引以便发现它。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:183 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:176
msgid "Plugin description file should also be added to ``package.xml``"
msgstr "插件描述文件还应添加到``package.xml``中。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:192 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:185
msgid "Compile and it should be registered. Next, we'll use this plugin."
msgstr "编译后应该注册该插件。接下来，我们将使用这个插件。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:196 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:188
msgid "3- Pass the plugin name through params file"
msgstr "3- 通过参数文件传递插件名称"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:198 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:190
msgid "To enable the plugin, we need to modify the ``nav2_params.yaml`` file as below to replace following params"
msgstr "要启用该插件，我们需要修改``nav2_params.yaml``文件，如下所示，以替换以下参数"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:225 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:208
msgid "with"
msgstr "with"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:260
msgid "In the above snippet, you can observe that we add the SMS behavior under the ``send_sms`` ROS 2 action server name. We also tell the behavior server that the ``send_sms`` is of type ``SendSms`` and give it our parameters for your Twilio account."
msgstr "在上面的片段中，您可以观察到我们在``send_sms``的ROS 2动作服务器名称下添加了SMS行为。我们还告诉行为服务器``send_sms``的类型是``SendSms``，并为您的Twilio帐户提供了参数。"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:264
msgid "4- Run Behavior Plugin"
msgstr "4- 运行行为插件"


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:266
msgid "Run Turtlebot3 simulation with enabled Nav2. Detailed instruction how to make it are written at :ref:`getting_started`. Below is shortcut command for that:"
msgstr "使用启用了Nav2的Turtlebot3模拟。如何进行此操作的详细说明请参见:ref:`getting_started`。下面是该操作的快捷命令："


#: ../../plugin_tutorials/docs/writing_new_behavior_plugin.rst:272
msgid "In a new terminal run:"
msgstr "在新终端中运行："


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:4
msgid "Writing a New Behavior Tree Plugin"
msgstr "编写新的行为树插件"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:13
msgid "This tutorial shows how to create your own behavior tree (BT) plugin. The BT plugins are used as nodes in the behavior tree XML processed by the BT Navigator for navigation logic."
msgstr "本教程展示如何创建自己的行为树（BT）插件。BT插件用作行为树XML中由BT Navigator处理的导航逻辑中的节点。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:28
msgid "1- Creating a new BT Plugin"
msgstr "1- 创建一个新的BT插件"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:30
msgid "We will create a simple BT plugin node to perform an action on another server. For this example, we're going to analyze the simplest behavior tree action node in the ``nav2_behavior_tree`` package, the ``wait`` node. Beyond this example of an action BT node, you can also create custom decorator, condition, and control nodes. Each node type has a unique role in the behavior tree to perform actions like planning, control the flow of the BT, check the status of a condition, or modify the output of other BT nodes."
msgstr "我们将创建一个简单的BT插件节点，用于在另一个服务器上执行操作。在这个示例中，我们将分析``nav2_behavior_tree``软件包中最简单的行为树动作节点，即``wait``节点。除了动作BT节点的示例之外，您还可以创建自定义的装饰器、条件和控制节点。每种节点类型在行为树中扮演着独特的角色，用于执行诸如规划、控制BT的流程、检查条件的状态或修改其他BT节点的输出等操作。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:35
msgid "The code in this tutorial can be found in `nav2_behavior_tree <https://github.com/ros-planning/navigation2/tree/main/nav2_behavior_tree>`_ package as the ``wait_action`` node. This action node can be considered as a reference for writing other action node plugins."
msgstr "本教程中的代码可以在 `nav2_behavior_tree <https://github.com/ros-planning/navigation2/tree/main/nav2_behavior_tree>`_ 包中找到，作为``wait_action``节点。该动作节点可以作为编写其他动作节点插件的参考。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:38
msgid "Our example plugin inherits from the base class ``nav2_behavior_tree::BtActionNode``. The base class is a wrapper on the BehaviorTree.CPP ``BT::ActionNodeBase`` that simplifies BT action nodes that utilize ROS 2 action clients. An ``BTActionNode`` is both a BT action and uses ROS 2 action network interfaces for calling a remote server to do some work."
msgstr "我们的示例插件继承自基类``nav2_behavior_tree::BtActionNode``。该基类是BehaviorTree.CPP中``BT::ActionNodeBase``的包装器，简化了使用ROS 2动作客户端的BT动作节点。``BTActionNode``既是BT动作，又使用ROS 2动作网络接口调用远程服务器进行一些工作。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:42
msgid "When working with other types of BT nodes (e.g. decorator, control, condition) use the corresponding BT node, ``BT::DecoratorNode``, ``BT::ControlNode``, or ``BT::ConditionNode``. For BT action nodes that do *not* utilize ROS 2 action interfaces, use the ``BT::ActionNodeBase`` base class itself."
msgstr "当使用其他类型的BT节点（例如装饰器、控制器、条件节点）时，请使用相应的BT节点，``BT::DecoratorNode``、``BT::ControlNode``或``BT::ConditionNode``。对于不使用ROS 2动作接口的BT动作节点，请直接使用``BT::ActionNodeBase``基类。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:45
msgid "The ``BTActionNode`` class provides 5 virtual methods to use, in addition to the information provided in the constructor. Let's learn more about the methods needed to write a BT action plugin."
msgstr "``BTActionNode``类提供了5个虚拟方法供使用，除了构造函数提供的信息之外。让我们更详细地了解编写BT动作插件所需的方法。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:49
msgid "**method**"
msgstr "**方法**"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:49
msgid "**Required?**"
msgstr "**是否必需？**"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:51
msgid "Constructor"
msgstr "构造函数"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:51
msgid "Constructor to indicate the corresponding XML tag name to that matches the plugin, the name of the action server to call using the plugin, and any BehaviorTree.CPP special configurations required."
msgstr "构造函数用于指示与插件匹配的相应XML标记名称，使用插件调用的动作服务器的名称，以及任何需要的BehaviorTree.CPP特殊配置。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:55
msgid "providedPorts()"
msgstr "提供的端口()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:55
msgid "A function to define the input and output ports a BT node may have. These are analogous to parameters that are defined in the BT XML by hardcoded values or by the value of output ports of other nodes."
msgstr "一个函数，用于定义BT节点可能具有的输入和输出端口。这类似于通过硬编码值或其他节点的输出端口的值在BT XML中定义的参数。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:59
msgid "on_tick()"
msgstr "每秒执行()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:59
msgid "Method is called when this BT node is ticked by the behavior tree while executing. This should be used to get dynamic updates like new blackboard values, input ports, or parameters. May also reset state for the action."
msgstr "在执行期间，当行为树对此BT节点进行打勾时调用此方法。这应该用于获取动态更新，如新的黑板值、输入端口或参数。也可以重置动作的状态。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:63
msgid "on_wait_for_result()"
msgstr "等待结果()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:63
msgid "Method is called when the behavior tree node is waiting for a result from the ROS 2 action server it called. This could be used to check for updates to preempt the current task, check for a timeout, or anything to compute while waiting for the action to complete."
msgstr "当行为树节点正在等待ROS 2动作服务器返回结果时调用此方法。这可以用于检查当前任务的更新情况，检查超时或在等待动作完成时进行计算等操作。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:68
msgid "on_success()"
msgstr "成功()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:68
msgid "Method is called when the ROS 2 action server returns a successful result. Returns the value the BT node will report back to the tree."
msgstr "当ROS 2动作服务器返回成功结果时调用此方法。返回BT节点将向树报告的值。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:71
msgid "on_aborted()"
msgstr "中止()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:71
msgid "Method is called when the ROS 2 action server returns an aborted result. Returns the value the BT node will report back to the tree."
msgstr "当ROS 2动作服务器返回一个中止的结果时，调用该方法。返回BT节点将向树报告的值。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:74
msgid "on_cancelled()"
msgstr "取消()"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:74
msgid "MMethod is called when the ROS 2 action server returns a cancelled result. Returns the value the BT node will report back to the tree."
msgstr "当ROS 2动作服务器返回一个取消的结果时，调用该方法。返回BT节点将向树报告的值。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:78
msgid "For this tutorial, we will only be using the ``on_tick()`` method."
msgstr "在本教程中，我们只会使用``每秒执行()``方法。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:80
msgid "In the constructor, we need to get any non-variable parameters that apply to the behavior tree node. In this example, we need to get the value of the duration to sleep from the input port of the behavior tree XML."
msgstr "在构造函数中，我们需要获取适用于行为树节点的任何非变量参数。在这个示例中，我们需要从行为树XML的输入端口获取睡眠持续时间的值。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:103
msgid "Here, we give the input of the ``xml_tag_name``, which tells the BT node plugin the string in the XML that corresponds to this node. This will be seen later when we register this BT node as a plugin. It also takes in the string name of the action server that it will call to execute some behavior. Finally, a set of configurations that we can safely ignore for the purposes of most node plugins."
msgstr "在这里，我们提供了``xml_tag_name``的输入，它告诉BT节点插件与此节点对应的XML中的字符串。当我们将此BT节点注册为插件时，稍后会看到它。它还接受要调用以执行某些行为的动作服务器的字符串名称。最后，有一组配置，对于大多数节点插件的目的，我们可以安全地忽略它们。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:108
msgid "We then call the ``BTActionNode`` constructor. As can be seen, it's templated by the ROS 2 action type, so we give it the ``nav2_msgs::action::Wait`` action message type and forward our other inputs. The ``BTActionNode`` has the ``tick()`` method, which is called directly by the behavior tree when this node is called from the tree. ``on_tick()`` is then called before sending the action client goal."
msgstr "然后我们调用``BTActionNode``构造函数。可以看到，它是由ROS 2动作类型进行模板化的，因此我们将其提供给``nav2_msgs::action::Wait``动作消息类型，并转发其他输入。当行为树从树中调用该节点时，``BTActionNode``具有``tick()``方法，该方法直接被调用。然后，在发送动作客户端目标之前调用``on_tick()``。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:112
msgid "In the body of the constructor, we get the input port ``getInput`` of the parameter ``wait_duration``, which can be configured independently for every instance of the ``wait`` node in the tree. It is set in the ``duration`` parameter and inserted into the ``goal_``. The ``goal_`` class variable is the goal that the ROS 2 action client will send to the action server. So in this example, we set the duration to the time we want to wait by so that the action server knows the specifics of our request."
msgstr "在构造函数的主体中，我们获取参数``wait_duration``的输入端口``getInput``，可以独立配置每个树中``wait``节点的实例。它设置在``duration``参数中，并插入到``goal_``中。``goal_``类变量是ROS 2动作客户端将发送到动作服务器的目标。因此，在此示例中，我们设置持续时间为所需等待的时间，以便动作服务器了解我们请求的具体内容。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:117
msgid "The ``providedPorts()`` method gives us the opportunity to define input or output ports. Ports can be thought of as parameters that the behavior tree node has access to from the behavior tree itself. For our example, there is only a single input port, the ``wait_duration`` which can be set in the BT XML for each instance of the ``wait`` recovery. We set the type, ``int``, the default ``1``, the name ``wait_duration``, and a description of the port ``Wait time``."
msgstr "``providedPorts()``方法使我们有机会定义输入或输出端口。端口可以被视为行为树节点从行为树本身访问的参数。对于我们的示例，只有一个输入端口，即``wait_duration``，可以在每个``wait``恢复的BT XML中设置。我们设置了类型为``int``，默认值为``1``，名称为``wait_duration``，端口的描述为``等待时间``。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:133
msgid "The ``on_tick()`` method is called when the behavior tree ticks a specific node. For the wait BT node, we simply want to notify a counter on the blackboard that an action plugin that corresponds to a recovery was ticked. This is useful to keep metrics about the number of recoveries executed during a specific navigation run. You could also log or update the ``goal_`` waiting duration if that is a variable input."
msgstr "当行为树对特定节点进行刻度时，将调用``on_tick()``方法。对于等待BT节点，我们只想通知黑板上的一个计数器，即与恢复对应的动作插件已经刻度。这对于在特定导航运行期间执行的恢复次数进行度量非常有用。您还可以记录或更新``goal_``等待持续时间（如果它是可变输入）。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:145
msgid "The remaining methods are not used and are not mandatory to override them. Only some BT node plugins will require overriding ``on_wait_for_result()`` to check for preemption or check a timeout. The success, aborted, and cancelled methods will default to ``SUCCESS``, ``FAILURE``, ``SUCCESS`` respectively, if not overridden."
msgstr "剩下的方法未被使用，也不是强制要求重写它们。只有一些BT节点插件需要重写``on_wait_for_result()``以检查抢占或检查超时。如果未重写，成功、中止和取消方法将分别默认为``SUCCESS``、``FAILURE``、``SUCCESS``。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:150 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:137
msgid "2- Exporting the planner plugin"
msgstr "2- 导出规划器插件"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:152
msgid "Now that we have created our custom BT node, we need to export our plugin so that it would be visible to the behavior tree when it loads a custom BT XML. Plugins are loaded at runtime, and if they are not visible, then our BT Navigator server won't be able to load them or use them. In BehaviorTree.CPP, exporting and loading plugins is handled by the ``BT_REGISTER_NODES`` macro."
msgstr "现在我们已经创建了自定义的BT节点，我们需要导出插件，以便在加载自定义的BT XML时，行为树能够看到它。插件在运行时加载，如果它们不可见，那么我们的BT导航服务器将无法加载或使用它们。在BehaviorTree.CPP中，导出和加载插件由``BT_REGISTER_NODES``宏处理。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:169
msgid "In this macro, we must create a ``NodeBuilder`` so that our custom action node can have a non-default constructor signature (for the action and xml names). This lambda will return a unique pointer to the behavior tree node we have created. Fill in the constructor with the relevant information, giving it the ``name`` and ``config`` given in the function arguments. Then define the ROS 2 action server's name that this BT node will call, in this case, it's the ``Wait`` action."
msgstr "在此宏中，我们必须创建一个``NodeBuilder``，以便我们的自定义动作节点可以具有非默认的构造函数签名（用于动作和xml名称）。此lambda将返回我们创建的行为树节点的唯一指针。使用函数参数中给定的相关信息填写构造函数。然后定义此BT节点将调用的ROS 2动作服务器的名称，在本例中为``Wait``动作。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:174
msgid "We finally give the builder to a factory to register. ``Wait`` given to the factory is the name in the behavior tree XML file that corresponds to this BT node plugin. An example can be seen below, where the ``Wait`` BT XML node specifies a non-variable input port ``wait_duration`` of 5 seconds."
msgstr "我们最终将构建器交给工厂进行注册。工厂中的“Wait”是与此BT节点插件对应的行为树XML文件中的名称。下面是一个示例，其中“Wait”BT XML节点指定了一个非变量输入端口“wait_duration”，持续时间为5秒。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:183
msgid "3- Add plugin library name to config"
msgstr "3- 将插件库名称添加到配置中"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:185
msgid "In order for the BT Navigator node to discover the plugin we've just registered, we need to list the plugin library name under the bt_navigator node in the configuration YAML file. Configuration should look similar to the one shown below. Take note of nav2_wait_action_bt_node listed under plugin_lib_names."
msgstr "为了使BT Navigator节点能够发现我们刚刚注册的插件，我们需要在配置的YAML文件中的bt_navigator节点下列出插件库的名称。配置应该类似于下面所示的内容。请注意plugin_lib_names下列出的nav2_wait_action_bt_node。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:201
msgid "4- Run Your Custom plugin"
msgstr "4- 运行您的自定义插件"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:203
msgid "Now you can use a behavior tree with your custom BT node. For example, the ``navigate_w_replanning_and_recovery.xml`` file is shown below."
msgstr "现在您可以在自定义BT节点中使用行为树。例如，下面显示了``navigate_w_replanning_and_recovery.xml``文件。"


#: ../../plugin_tutorials/docs/writing_new_bt_plugin.rst:206
msgid "Select this BT XML file in your specific navigation request in ``NavigateToPose`` or as the default behavior tree in the BT Navigator's configuration yaml file."
msgstr "在``NavigateToPose``中的具体导航请求中选择此BT XML文件，或者将其作为BT导航器配置yaml文件中的默认行为树。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:4
msgid "Writing a New Costmap2D Plugin"
msgstr "编写新的Costmap2D插件"


msgid "Animated gif with gradient demo"
msgstr "带有渐变效果的动画GIF演示"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:18
msgid "This tutorial shows how to create your own simple `plugin <http://wiki.ros.org/pluginlib>`_ for Costmap2D."
msgstr "本教程展示了如何为Costmap2D创建自己的简单`插件 <http://wiki.ros.org/pluginlib>`_。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:20
msgid "Before starting the tutorial, please check this `video <https://vimeo.com/106994708>`_ which contains information about Costmap2D layers design and plugins basic operational principals."
msgstr "在开始教程之前，请查看此`视频<https://vimeo.com/106994708>`_，其中包含关于Costmap2D图层设计和插件基本操作原则的信息。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:25
msgid "It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made in :ref:`build-instructions`."
msgstr "假设已安装或本地构建了ROS 2、Gazebo和TurtleBot3软件包。请确保Nav2项目也在本地构建，就像在:ref:`build-instructions`中所述一样。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:31
msgid "1- Write a new Costmap2D plugin"
msgstr "1-编写一个新的Costmap2D插件"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:33
msgid "For a demonstration, this example will create a costmap plugin that puts repeating cost gradients in the costmap. The annotated code for this tutorial can be found in `navigation2_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ repository as the ``nav2_gradient_costmap_plugin`` ROS 2-package. Please refer to it when making your own layer plugin for Costmap2D."
msgstr "作为演示，本示例将创建一个在costmap中放置重复的成本梯度的成本图插件。有关本教程的带注释代码可以在`navigation2_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_存储库中找到，作为``nav2_gradient_costmap_plugin`` ROS 2软件包。在创建自己的Costmap2D层插件时，请参考它。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:37
msgid "The plugin class ``nav2_gradient_costmap_plugin::GradientLayer`` is inherited from basic class ``nav2_costmap_2d::Layer``:"
msgstr "插件类``nav2_gradient_costmap_plugin::GradientLayer``继承自基类``nav2_costmap_2d::Layer``："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:46
msgid "The basic class provides the set of virtual methods API for working with costmap layers in a plugin. These methods are called at runtime by ``LayeredCostmap``. The list of methods, their description, and necessity to have these methods in plugin's code is presented in the table below:"
msgstr "基本类提供了一组虚拟方法的API，用于在插件中处理代价地图图层。这些方法在运行时由``LayeredCostmap``调用。下表列出了这些方法、它们的描述以及插件代码中必须具备这些方法的必要性："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:51
msgid "onInitialize()"
msgstr "onInitialize()"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:51
msgid "Method is called at the end of plugin initialization. There is usually declarations of ROS parameters. This is where any required initialization should occur."
msgstr "该方法在插件初始化结束时被调用。通常会在这里声明ROS参数。任何必要的初始化应该在这里进行。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:55
msgid "updateBounds()"
msgstr "updateBounds()"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:55
msgid "Method is called to ask the plugin: which area of costmap layer it needs to update. The method has 3 input parameters: robot position and orientation, and 4 output parameters: pointers to window bounds. These bounds are used for performance reasons: to update the area inside the window where new info is available, avoiding updates of the whole costmap on every iteration."
msgstr "该方法用于询问插件：它需要更新哪个代价地图图层的区域。该方法有3个输入参数：机器人的位置和方向，以及4个输出参数：窗口边界的指针。出于性能考虑，这些边界用于更新窗口内的区域，其中有新信息可用，避免在每次迭代中更新整个代价地图。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:62
msgid "updateCosts()"
msgstr "updateCosts（）"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:62
msgid "Method is called each time when costmap re-calculation is required. It updates the costmap layer only within its bounds window. The method has 4 input parameters: calculation window bounds, and 1 output parameter: reference to a resulting costmap ``master_grid``. The ``Layer`` class provides the plugin with an internal costmap, ``costmap_``, for updates. The ``master_grid`` should be updated with values within the window bounds using one of the following update methods: ``updateWithAddition()``, ``updateWithMax()``, ``updateWithOverwrite()`` or ``updateWithTrueOverwrite()``."
msgstr "每当需要重新计算代价地图时，将调用该方法。它仅在其边界窗口内更新代价地图图层。该方法有4个输入参数：计算窗口边界，以及1个输出参数：对结果代价地图``master_grid``的引用。``Layer``类为插件提供了一个用于更新的内部代价地图``costmap_``。应使用以下更新方法之一在窗口边界内更新``master_grid``的值：``updateWithAddition()``, ``updateWithMax()``, ``updateWithOverwrite()``或``updateWithTrueOverwrite()``。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:72
msgid "matchSize()"
msgstr "matchSize（）"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:72
msgid "Method is called each time when map size was changed."
msgstr "每当地图尺寸发生变化时，将调用该方法。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:74
msgid "onFootprintChanged()"
msgstr "onFootprintChanged（）"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:74
msgid "Method is called each time when footprint was changed."
msgstr "每当足迹（footprint）发生变化时，将调用该方法。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:76
msgid "reset()"
msgstr "reset（）"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:76
msgid "It may have any code to be executed during costmap reset."
msgstr "在代价地图重置期间可以执行任何代码。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:79
msgid "In our example these methods have the following functionality:"
msgstr "在我们的示例中，这些方法具有以下功能："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:81
msgid "``GradientLayer::onInitialize()`` contains declaration of a ROS parameter with its default value:"
msgstr "``GradientLayer::onInitialize()`` 包含了一个带有默认值的 ROS 参数的声明："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:88
msgid "and sets ``need_recalculation_`` bounds recalculation indicator:"
msgstr "并设置``need_recalculation_``边界重新计算指示器："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:94
msgid "``GradientLayer::updateBounds()`` re-calculates window bounds if ``need_recalculation_`` is ``true`` and updates them regardless of ``need_recalculation_`` value."
msgstr "``GradientLayer::updateBounds()`` 如果 ``need_recalculation_`` 为 ``true``，则重新计算窗口边界，并且不论 ``need_recalculation_`` 的值如何，都会更新边界。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:96
msgid "``GradientLayer::updateCosts()`` - in this method the gradient is writing directly to the resulting costmap ``master_grid`` without merging with previous layers. This is equal to working with internal ``costmap_`` and then calling ``updateWithTrueOverwrite()`` method. Here is the gradient making algorithm for master costmap:"
msgstr "``GradientLayer::updateCosts（）`` - 在这个方法中，梯度直接写入到结果代价地图``master_grid``，而不与之前的图层合并。这等同于使用内部``costmap_``并调用``updateWithTrueOverwrite（）``方法。以下是主代价地图的梯度生成算法："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:118
msgid "where the ``GRADIENT_SIZE`` is the size of each gradient period in map cells, ``GRADIENT_FACTOR`` - decrement of costmap's value per each step:"
msgstr "其中，``GRADIENT_SIZE`` 是地图单元中每个梯度周期的大小，``GRADIENT_FACTOR`` 是每个步骤中代价地图值的递减量："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:122
msgid "These parameters are defined in plugin's header file."
msgstr "这些参数在插件的头文件中定义。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:124
msgid "``GradientLayer::onFootprintChanged()`` just resets ``need_recalculation_`` value."
msgstr "``GradientLayer::onFootprintChanged()`` 只是重置了 ``need_recalculation_`` 的值。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:126
msgid "``GradientLayer::reset()`` method is dummy: it is not used in this example plugin. It remains there since pure virtual function ``reset()`` in parent ``Layer`` class required to be overridden."
msgstr "``GradientLayer::reset()`` 方法是虚拟的：在此示例插件中未被使用。它保留在那里是因为父类 ``Layer`` 中的纯虚拟函数 ``reset()`` 要求被覆盖。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:129
msgid "2- Export and make GradientLayer plugin"
msgstr "2- 导出并制作 GradientLayer 插件"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:131
msgid "The written plugin will be loaded at runtime as its basic parent class and then will be called by plugin handling modules (for costmap2d by ``LayeredCostmap``). Pluginlib opens a given plugin in run-time and provides methods from exported classes to be callable. The mechanism of class exporting tells pluginlib which basic class should be used during these calls. This allows to extend an application by plugins without knowing application source code or recompiling it."
msgstr "编写的插件将在运行时作为其基本父类加载，然后由插件处理模块调用（对于 costmap2d 是由 ``LayeredCostmap`` 调用）。Pluginlib 在运行时打开给定的插件，并提供从导出类可调用的方法。类导出机制告诉 pluginlib 在这些调用期间应使用哪个基本类。这允许通过插件扩展应用程序，而无需知道应用程序源代码或重新编译它。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:133
msgid "In our example the ``nav2_gradient_costmap_plugin::GradientLayer`` plugin's class should be dynamically loaded as a ``nav2_costmap_2d::Layer`` basic class. For this the plugin should be registered as follows:"
msgstr "在我们的示例中，``nav2_gradient_costmap_plugin::GradientLayer`` 插件的类应该作为 ``nav2_costmap_2d::Layer`` 基类进行动态加载。为此，插件应按以下方式注册："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:135
msgid "Plugin's class should be registered with a basic type of loaded class. For this there is a special macro ``PLUGINLIB_EXPORT_CLASS`` should be added to any source-file composing the plugin library:"
msgstr "插件的类应该使用加载类的基本类型进行注册。为此，应该将特殊宏 ``PLUGINLIB_EXPORT_CLASS`` 添加到组成插件库的任何源文件中："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:142
msgid "This part is usually placed at the end of cpp-file where the plugin class was written (in our example ``gradient_layer.cpp``). It is good practice to place these lines at the end of the file, but technically, you can also place at the top."
msgstr "这部分通常放在插件类所在的 cpp 文件的末尾（在我们的示例中是 ``gradient_layer.cpp``）。将这些行放在文件末尾是良好的做法，但从技术上讲，也可以放在文件顶部。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:144
msgid "Plugin's inormation should be stored to plugin description file. This is done by using separate XML (in our example ``gradient_plugins.xml``) in the plugin's package. This file contains information about:"
msgstr "插件的信息应存储到插件描述文件中。这是通过在插件的软件包中使用单独的 XML（在我们的示例中为 ``gradient_plugins.xml``）来完成的。该文件包含有关以下内容的信息："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:146
msgid "``path``: Path and name of library where plugin is placed."
msgstr "``path``：插件所在库的路径和名称。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:147
msgid "``name``: Plugin type referenced in ``plugin_types`` parameter (see next section for more details). It could be whatever you want."
msgstr "``name``: 在 ``plugin_types`` 参数中引用的插件类型（有关更多详细信息，请参见下一节）。它可以是任何你想要的。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:148
msgid "``type``: Plugin class with namespace taken from the source code."
msgstr "``type``：插件类，其命名空间来自源代码。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:149
msgid "``basic_class_type``: Basic parent class from which plugin class was derived."
msgstr "``basic_class_type``: 插件类所派生的基本父类。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:150
msgid "``description``: Plugin description in a text form."
msgstr "``description``：以文本形式的插件描述。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:160
msgid "The export of plugin is performed by including ``pluginlib_export_plugin_description_file()`` cmake-function into ``CMakeLists.txt``. This function installs plugin description file into ``share`` directory and sets ament indexes for plugin description XML to be discoverable as a plugin of selected type:"
msgstr "通过将``pluginlib_export_plugin_description_file()`` cmake函数包含在``CMakeLists.txt``中来执行插件的导出。此函数将插件描述文件安装到``share``目录中，并为插件描述XML设置ament索引，以便可以将其发现为所选类型的插件："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:166
msgid "Plugin description file is also should be added to ``package.xml``. ``costmap_2d`` is the package of the interface definition, for our case ``Layer``, and requires a path to the xml file:"
msgstr "插件描述文件还应添加到 ``package.xml`` 中。``costmap_2d`` 是接口定义的包，在我们的案例中为 ``Layer``，需要提供指向 XML 文件的路径："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:175
msgid "After everything is done put the plugin package into ``src`` directory of a certain ROS 2-workspace, build the plugin package (``colcon build --packages-select nav2_gradient_costmap_plugin --symlink-install``) and source ``setup.bash`` file when it necessary."
msgstr "完成所有步骤后，将插件包放入特定ROS 2工作空间的``src``目录中，构建插件包（``colcon build --packages-select nav2_gradient_costmap_plugin --symlink-install``），并在必要时源化``setup.bash``文件。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:177
msgid "Now the plugin is ready to use."
msgstr "现在插件已经准备好使用了。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:180
msgid "3- Enable the plugin in Costmap2D"
msgstr "3- 在Costmap2D中启用插件"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:182
msgid "At the next step it is required to tell Costmap2D about new plugin. For that the plugin should be added to ``plugin_names`` and ``plugin_types`` lists in ``nav2_params.yaml`` optionally for ``local_costmap``/``global_costmap`` in order to be enabled in run-time for Controller/Planner Server. ``plugin_names`` list contains the names of plugin objects. These names could be anything you want. ``plugin_types`` contains types of listed in ``plugin_names`` objects. These types should correspond to ``name`` field of plugin class specified in plugin description XML-file."
msgstr "下一步需要告知 Costmap2D 新插件的存在。为此，插件应可选地添加到 ``nav2_params.yaml`` 的 ``local_costmap``/``global_costmap`` 的 ``plugin_names`` 和 ``plugin_types`` 列表中，以便在 Controller/Planner 服务器的运行时启用。``plugin_names`` 列表包含插件对象的名称，这些名称可以任意指定。``plugin_types`` 包含在 ``plugin_names`` 中列出的对象的类型，这些类型应与插件描述 XML 文件中指定的插件类的 ``name`` 字段对应。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:186 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:194
msgid "For Galactic or later, ``plugin_names`` and ``plugin_types`` have been replaced with a single ``plugins`` string vector for plugin names. The types are now defined in the ``plugin_name`` namespace in the ``plugin:`` field (e.g. ``plugin: MyPlugin::Plugin``). Inline comments in the code blocks will help guide you through this."
msgstr "对于Galactic或更新版本，``plugin_names``和``plugin_types``已经被单个``plugins``字符串向量替代，用于插件名称。现在，类型在``plugin_name``命名空间中的``plugin:``字段中定义（例如：``plugin: MyPlugin::Plugin``）。代码块中的内联注释将帮助指导您完成此操作。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:188
msgid "For example:"
msgstr "例如："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:213
msgid "YAML-file may also contain the list of parameters (if any) for each plugin, identified by plugins object name."
msgstr "YAML文件还可以包含每个插件的参数列表（如果有）。这些参数由插件对象名称进行标识。"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:215
msgid "NOTE: there could be many simultaneously loaded plugin objects of one type. For this, ``plugin_names`` list should contain different plugins names whether the ``plugin_types`` will remain the same types. For example:"
msgstr "注意：一种类型的插件可能同时加载多个对象。因此，“plugin_names”列表应包含不同的插件名称，而“plugin_types”将保持相同的类型。例如："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:221
msgid "In this case each plugin object will be handled by its own parameters tree in a YAML-file, like:"
msgstr "在这种情况下，每个插件对象将在YAML文件中通过自己的参数树进行处理，例如："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:235
msgid "4- Run GradientLayer plugin"
msgstr "4- 运行GradientLayer插件"


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:237
msgid "Run Turtlebot3 simulation with enabled Nav2. Detailed instructions how to make it are written at :ref:`getting_started`. Below is shortcut command for that:"
msgstr "使用启用了Nav2的Turtlebot3仿真运行。如何进行设置的详细说明请参阅:ref:`getting_started`。以下是快捷命令："


#: ../../plugin_tutorials/docs/writing_new_costmap2d_plugin.rst:243
msgid "Then goto RViz and click on the \"2D Pose Estimate\" button at the top and point the location on map as it was described in :ref:`getting_started`. Robot will be localized on map and the result should be as presented at picture below. There, the gradient costmap can be seen. There are also 2 noticeable things: dynamically updated by ``GradientLayer::updateCosts()`` costmap within its bounds and global path curved by gradient:"
msgstr "然后转到RViz，并单击顶部的“2D姿势估计”按钮，根据:ref:`getting_started`中所述，在地图上指向位置。机器人将在地图上进行定位，结果应如下图所示。在那里，可以看到梯度代价图。还有两个明显的特点：由``GradientLayer::updateCosts()``在其边界内动态更新的代价图和由梯度曲线化的全局路径："


msgid "Image of gradient costmap used"
msgstr "使用梯度成本地图的图像"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:4
msgid "Writing a New Controller Plugin"
msgstr "编写新的控制器插件"


msgid "Animated gif of pure pursuit controller demo"
msgstr "纯追踪控制器演示的动画gif图像"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:19
msgid "This tutorial shows how to create your own controller `plugin <https://index.ros.org/p/pluginlib/>`_."
msgstr "本教程介绍如何创建自己的控制器插件 `plugin <https://index.ros.org/p/pluginlib/>`_。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:21
msgid "In this tutorial, we will be implementing the pure pursuit path tracking algorithm based on this `paper <https://www.ri.cmu.edu/pub_files/pub3/coulter_r_craig_1992_1/coulter_r_craig_1992_1.pdf>`_. It is recommended you go through it."
msgstr "在本教程中，我们将根据这篇 `论文 <https://www.ri.cmu.edu/pub_files/pub3/coulter_r_craig_1992_1/coulter_r_craig_1992_1.pdf>`_ 实现纯追踪路径跟踪算法。建议您阅读该论文。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:24
msgid "Note: This tutorial is based on a previously existing simplified version of the Regulated Pure Pursuit controller now in the Nav2 stack. You can find the source code matching this tutorial `here <https://github.com/ros-planning/navigation2_tutorials/tree/126902457c5c646b136569886d6325f070c1073d/nav2_pure_pursuit_controller>`_."
msgstr "注意：本教程基于现有的简化版本的Regulated Pure Pursuit控制器，该控制器现已包含在Nav2堆栈中。您可以在 `这里 <https://github.com/ros-planning/navigation2_tutorials/tree/126902457c5c646b136569886d6325f070c1073d/nav2_pure_pursuit_controller>`_ 找到与本教程相匹配的源代码。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:39
msgid "1- Create a new Controller Plugin"
msgstr "1- 创建一个新的控制器插件"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:41
msgid "We will be implementing the pure pursuit controller. The annotated code in this tutorial can be found in `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ repository as the ``nav2_pure_pursuit_controller``. This package can be considered as a reference for writing your own controller plugin."
msgstr "我们将实现纯追踪控制器。本教程中的带注释代码可以在 `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ 存储库的``nav2_pure_pursuit_controller``中找到。该软件包可被视为编写自己的控制器插件的参考。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:44
msgid "Our example plugin class ``nav2_pure_pursuit_controller::PurePursuitController`` inherits from the base class ``nav2_core::Controller``. The base class provides a set of virtual methods to implement a controller plugin. These methods are called at runtime by the controller server to compute velocity commands. The list of methods, their descriptions, and necessity are presented in the table below:"
msgstr "我们的示例插件类 ``nav2_pure_pursuit_controller::PurePursuitController`` 继承自基类 ``nav2_core::Controller``。基类提供了一组虚拟方法来实现控制器插件。这些方法在运行时由控制器服务器调用以计算速度命令。方法列表、描述和必要性如下表所示："


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:51
msgid "Method is called when controller server enters on_configure state. Ideally this method should perform declarations of ROS parameters and initialization of controller's member variables. This method takes 4 input params: weak pointer to parent node, controller name, tf buffer pointer and shared pointer to costmap."
msgstr "当控制器服务器进入on_configure状态时调用此方法。理想情况下，此方法应执行ROS参数的声明和控制器成员变量的初始化。此方法接收4个输入参数：父节点的弱指针、控制器名称、tf缓冲指针和costmap的共享指针。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:56
msgid "Method is called when controller server enters on_activate state. Ideally this method should implement operations which are neccessary before controller goes to an active state."
msgstr "当控制器服务器进入“on_activate”状态时调用该方法。理想情况下，该方法应该实现在控制器进入活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:60
msgid "Method is called when controller server enters on_deactivate state. Ideally this method should implement operations which are neccessary before controller goes to an inactive state."
msgstr "当控制器服务器进入on_deactivate状态时调用此方法。理想情况下，此方法应实现在控制器进入非活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:64
msgid "Method is called when controller server goes to on_cleanup state. Ideally this method should clean up resources which are created for the controller."
msgstr "当控制器服务器进入“on_cleanup”状态时调用该方法。理想情况下，该方法应清理为控制器创建的资源。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:67
msgid "setPlan()"
msgstr "setPlan()"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:67
msgid "Method is called when the global plan is updated. Ideally this method should perform operations that transform the global plan and store it."
msgstr "当全局路径更新时调用此方法。理想情况下，此方法应执行转换全局路径并存储的操作。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:70
msgid "computeVelocityCommands()"
msgstr "computeVelocityCommands()"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:70
msgid "Method is called when a new velocity command is demanded by the controller server in-order for the robot to follow the global path. This method returns a `geometry_msgs\\:\\:msg\\:\\:TwistStamped` which represents the velocity command for the robot to drive.  This method passes 2 parameters: reference to the current robot pose and its current velocity."
msgstr "当控制器服务器要求提供新的速度指令以便机器人跟随全局路径时，调用此方法。该方法返回一个`geometry_msgs::msg::TwistStamped`，表示机器人的速度指令。该方法接受两个参数：当前机器人姿态的引用和当前速度。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:76
msgid "setSpeedLimit()"
msgstr "setSpeedLimit()"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:76
msgid "Method is called when it is required to limit the maximum linear speed of the robot. Speed limit could be expressed in absolute value (m/s) or in percentage from maximum robot speed. Note that typically, maximum rotational speed is being limited proportionally to the change of maximum linear speed, in order to keep current robot behavior untouched."
msgstr "当需要限制机器人的最大线速度时调用此方法。速度限制可以用绝对值（m/s）或相对于最大机器人速度的百分比表示。请注意，通常情况下，最大旋转速度与最大线速度的变化成比例限制，以保持当前机器人行为不变。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:83
msgid "In this tutorial, we will use the methods ``PurePursuitController::configure``, ``PurePursuitController::setPlan`` and ``PurePursuitController::computeVelocityCommands``."
msgstr "在本教程中，我们将使用``PurePursuitController::configure``、``PurePursuitController::setPlan``和``PurePursuitController::computeVelocityCommands``这些方法。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:86
msgid "In controllers, ``configure()`` method must set member variables from ROS parameters and perform any initialization required."
msgstr "在控制器中，`configure()`方法必须从ROS参数设置成员变量并执行所需的任何初始化。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:125
msgid "Here, ``plugin_name_ + \".desired_linear_vel\"`` is fetching the ROS parameter ``desired_linear_vel`` which is specific to our controller. Nav2 allows loading of multiple plugins, and to keep things organized, each plugin is mapped to some ID/name. Now, if we want to retrieve the parameters for that specific plugin, we use ``<mapped_name_of_plugin>.<name_of_parameter>`` as done in the above snippet. For example, our example controller is mapped to the name ``FollowPath`` and to retrieve the ``desired_linear_vel`` parameter, which is specific to \"FollowPath”, we used ``FollowPath.desired_linear_vel``. In other words, ``FollowPath`` is used as a namespace for plugin-specific parameters. We will see more on this when we discuss the parameters file (or params file)."
msgstr "这里，``plugin_name_ + \".desired_linear_vel\"``获取了ROS参数``desired_linear_vel``，该参数是特定于我们的控制器的。Nav2允许加载多个插件，并为了保持组织的有序，每个插件都映射到某个ID/名称。现在，如果我们想要检索该特定插件的参数，我们可以像上面的代码片段中所做的那样使用``<mapped_name_of_plugin>.<name_of_parameter>``。例如，我们的示例控制器映射到名称``FollowPath``，为了检索特定于“FollowPath”的``desired_linear_vel``参数，我们使用了``FollowPath.desired_linear_vel``。换句话说，``FollowPath``被用作插件特定参数的命名空间。在我们讨论参数文件（或参数文件）时，我们将会看到更多相关内容。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:132
msgid "The passed-in arguments are stored in member variables so that they can be used at a later stage if needed."
msgstr "传入的参数被存储在成员变量中，以便在以后的阶段如果需要时使用。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:134
msgid "In ``setPlan()`` method, we receive the updated global path for the robot to follow. In our example, we transform the received global path into the frame of the robot and then store this transformed global path for later use."
msgstr "在``setPlan()``方法中，我们接收到机器人要遵循的更新全局路径。在我们的示例中，我们将接收到的全局路径转换为机器人的坐标系，并将转换后的全局路径存储起来以供以后使用。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:145
msgid "The computation for the desired velocity happens in the ``computeVelocityCommands()`` method. It is used to calculate the desired velocity command given the current velocity and pose. The third argument - is a pointer to the ``nav2_core::GoalChecker``, that checks whether a goal has been reached. In our example, this won't be used. In the case of pure pursuit, the algorithm computes velocity commands such that the robot tries to follow the global path as closely as possible. This algorithm assumes a constant linear velocity and computes the angular velocity based on the curvature of the global path."
msgstr "期望速度的计算在`computeVelocityCommands()`方法中进行。它用于根据当前速度和姿态计算期望的速度指令。第三个参数是指向`nav2_core::GoalChecker`的指针，用于检查是否已达到目标。在我们的示例中，此参数不会被使用。对于纯追踪算法，该算法会计算使机器人尽可能紧密地跟随全局路径的速度指令。该算法假设线速度恒定，根据全局路径的曲率计算角速度。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:194
msgid "The remaining methods are not used, but it's mandatory to override them. As per the rules, we did override all but left them empty."
msgstr "剩余的方法没有使用，但是必须进行覆盖。根据规则，我们确实进行了覆盖，但是将它们保留为空白。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:197
msgid "2- Exporting the controller plugin"
msgstr "2- 导出控制器插件"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:199
msgid "Now that we have created our custom controller, we need to export our controller plugin so that it will be visible to the controller server. Plugins are loaded at runtime, and if they are not visible, then our controller server won't be able to load them. In ROS 2, exporting and loading plugins is handled by ``pluginlib``."
msgstr "现在，我们已经创建了自定义控制器，我们需要导出控制器插件，以便控制器服务器能够看到它们。插件是在运行时加载的，如果它们不可见，那么控制器服务器将无法加载它们。在ROS 2中，导出和加载插件由``pluginlib``处理。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:203
msgid "Coming back to our tutorial, class ``nav2_pure_pursuit_controller::PurePursuitController`` is loaded dynamically as ``nav2_core::Controller`` which is our base class."
msgstr "回到我们的教程，类 ``nav2_pure_pursuit_controller::PurePursuitController`` 动态加载为 ``nav2_core::Controller``，这是我们的基类。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:205 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:269
msgid "To export the controller, we need to provide two lines"
msgstr "要导出控制器，我们需要提供两行代码。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:212 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:276
msgid "Note that it requires pluginlib to export out the plugin's class. Pluginlib would provide as macro ``PLUGINLIB_EXPORT_CLASS``, which does all the work of exporting."
msgstr "请注意，它需要 pluginlib 来导出插件的类。Pluginlib 将提供宏 ``PLUGINLIB_EXPORT_CLASS``，该宏执行所有导出的工作。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:214 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:152 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:278
msgid "It is good practice to place these lines at the end of the file, but technically, you can also write at the top."
msgstr "将这些行代码放在文件末尾是一个好的做法，但从技术上讲，你也可以写在文件顶部。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:216
msgid "The next step would be to create the plugin's description file in the root directory of the package. For example, ``pure_pursuit_controller_plugin.xml`` file in our tutorial package. This file contains the following information"
msgstr "下一步是在软件包的根目录中创建插件的描述文件。例如，在我们的教程软件包中创建一个名为 ``pure_pursuit_controller_plugin.xml`` 的文件。此文件包含以下信息："


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:218 ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:156
msgid "``library path``: Plugin's library name and its location."
msgstr "``library path``：插件的库名称及其位置。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:234 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:298
msgid "Next step would be to export plugin using ``CMakeLists.txt`` by using CMake function ``pluginlib_export_plugin_description_file()``. This function installs the plugin description file to ``share`` directory and sets ament indexes to make it discoverable."
msgstr "下一步是使用 ``CMakeLists.txt`` 导出插件，使用 CMake 函数 ``pluginlib_export_plugin_description_file()``。此函数将插件描述文件安装到 ``share`` 目录，并设置 ament 索引以使其可被发现。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:240 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:304
msgid "The plugin description file should also be added to ``package.xml``"
msgstr "插件描述文件也应添加到``package.xml``中。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:249 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:313
msgid "Compile, and it should be registered. Next, we'll use this plugin."
msgstr "编译后，应该进行注册。接下来，我们将使用此插件。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:252 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:316
msgid "3- Pass the plugin name through the params file"
msgstr "3- 通过参数文件传递插件名称"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:254 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:318
msgid "To enable the plugin, we need to modify the ``nav2_params.yaml`` file as below"
msgstr "要启用插件，我们需要修改 ``nav2_params.yaml`` 文件如下所示："


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:270
msgid "In the above snippet, you can observe the mapping of our ``nav2_pure_pursuit_controller/PurePursuitController`` controller to its id ``FollowPath``. To pass plugin-specific parameters we have used ``<plugin_id>.<plugin_specific_parameter>``."
msgstr "在上面的代码片段中，您可以观察到我们将 ``nav2_pure_pursuit_controller/PurePursuitController`` 控制器映射到其 ID ``FollowPath``。要传递特定于插件的参数，我们使用了 ``<plugin_id>.<plugin_specific_parameter>``。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:274
msgid "4- Run Pure Pursuit Controller plugin"
msgstr "4- 运行 Pure Pursuit Controller 插件。"


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:276 ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:346
msgid "Run Turtlebot3 simulation with enabled Nav2. Detailed instructions on how to make it run are written at :ref:`getting_started`. Below is a shortcut command for that:"
msgstr "使用启用的 Nav2 运行 Turtlebot3 模拟。有关如何运行的详细说明，请参阅 :ref:`getting_started`。下面是一个快捷命令："


#: ../../plugin_tutorials/docs/writing_new_nav2controller_plugin.rst:282
msgid "Then goto RViz and click on the \"2D Pose Estimate\" button at the top and point the location on the map as it was described in :ref:`getting_started`. The robot will localize on the map and then click on the \"Nav2 goal\" and click on the pose where you want your robot to navigate to. After that controller will make the robot follow the global path."
msgstr "然后进入RViz，并点击顶部的\"2D Pose Estimate\"按钮，在地图上指定位置，就像在 :ref:`getting_started` 中描述的那样。机器人将在地图上进行定位，然后点击\"Nav2 goal\"，并在您希望机器人导航到的姿态上点击。之后，控制器将使机器人沿着全局路径移动。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:4
msgid "Writing a New Planner Plugin"
msgstr "编写一个新的规划器插件"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:18
msgid "This tutorial shows how to create your own planner plugin."
msgstr "本教程展示了如何创建自己的规划器插件。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:32
msgid "1- Creating a new Planner Plugin"
msgstr "1- 创建一个新的规划器插件"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:34
msgid "We will create a simple straight-line planner. The annotated code in this tutorial can be found in `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ repository as the ``nav2_straightline_planner``. This package can be considered as a reference for writing planner plugin."
msgstr "我们将创建一个简单的直线规划器。本教程中的注释代码可以在 `navigation_tutorials <https://github.com/ros-planning/navigation2_tutorials>`_ 存储库中找到，作为 ``nav2_straightline_planner``。这个包可以作为编写规划器插件的参考。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:38
msgid "Our example plugin inherits from the base class ``nav2_core::GlobalPlanner``. The base class provides 5 pure virtual methods to implement a planner plugin. The plugin will be used by the planner server to compute trajectories. Let's learn more about the methods needed to write a planner plugin."
msgstr "我们的示例插件继承自基类 ``nav2_core::GlobalPlanner``。基类提供了 5 个纯虚拟方法来实现规划器插件。该插件将由规划器服务器用于计算轨迹。让我们更多地了解编写规划器插件所需的方法。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:44
msgid "Method is called at when planner server enters on_configure state. Ideally this methods should perform declarations of ROS parameters and initialization of planner's member variables. This method takes 4 input params: shared pointer to parent node, planner name, tf buffer pointer and shared pointer to costmap."
msgstr "该方法在规划器服务器进入 on_configure 状态时调用。理想情况下，这个方法应该执行ROS参数的声明和规划器成员变量的初始化。该方法接受4个输入参数：父节点的共享指针、规划器名称、tf缓冲指针和成本地图的共享指针。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:50
msgid "Method is called when planner server enters on_activate state. Ideally this method should implement operations which are neccessary before planner goes to an active state."
msgstr "当规划器服务器进入 on_activate 状态时调用该方法。理想情况下，此方法应该实现在规划器进入活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:54
msgid "Method is called when planner server enters on_deactivate state. Ideally this method should implement operations which are neccessary before planner goes to an inactive state."
msgstr "该方法在规划器服务器进入 on_deactivate 状态时调用。理想情况下，这个方法应该实现在规划器进入非活动状态之前必要的操作。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:58
msgid "Method is called when planner server goes to on_cleanup state. Ideally this method should clean up resoures which are created for the planner."
msgstr "当规划器服务器进入on_cleanup状态时调用此方法。理想情况下，此方法应清理为规划器创建的资源。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:61
msgid "createPlan()"
msgstr "createPlan()"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:61
msgid "Method is called when planner server demands a global plan for specified start and goal pose. This method returns `nav_msgs\\:\\:msg\\:\\:Path` carrying global plan. This method takes 2 input parmas: start pose and goal pose."
msgstr "当规划器服务器要求指定起始和目标姿态的全局路径时调用此方法。此方法返回携带全局路径的`nav_msgs::msg::Path`。此方法接受两个输入参数：起始姿态和目标姿态。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:66
msgid "For this tutorial, we will be using methods ``StraightLine::configure()`` and ``StraightLine::createPlan()`` to create straight-line planner."
msgstr "在本教程中，我们将使用方法 ``StraightLine::configure()`` 和 ``StraightLine::createPlan()`` 来创建直线规划器。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:68
msgid "In planners, ``configure()`` method must set member variables from ROS parameters and any initialization required,"
msgstr "在规划器中，``configure()``方法必须从ROS参数设置成员变量和进行任何所需的初始化。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:82
msgid "Here, ``name_ + \".interpolation_resolution\"`` is fetching the ROS parameters ``interpolation_resolution`` which is specific to our planner. Nav2 allows the loading of multiple plugins, and to keep things organized, each plugin is mapped to some ID/name. Now if we want to retrieve the parameters for that specific plugin, we use ``<mapped_name_of_plugin>.<name_of_parameter>`` as done in the above snippet. For example, our example planner is mapped to the name \"GridBased\" and to retrieve the ``interpolation_resolution`` parameter which is specific to \"GridBased\", we used ``Gridbased.interpolation_resolution``. In other words, ``GridBased`` is used as a namespace for plugin-specific parameters. We will see more on this when we discuss the parameters file (or params file)."
msgstr "在这里，``name_ + \".interpolation_resolution\"`` 获取了 ROS 参数 ``interpolation_resolution``，该参数是特定于我们的规划器的。Nav2 允许加载多个插件，并为了保持组织，每个插件都映射到某个 ID/名称。现在，如果我们想要检索该特定插件的参数，我们可以像上面的片段中那样使用 ``<mapped_name_of_plugin>.<name_of_parameter>``。例如，我们的示例规划器映射到名称 \"GridBased\"，为了检索特定于 \"GridBased\" 的 ``interpolation_resolution`` 参数，我们使用了 ``Gridbased.interpolation_resolution``。换句话说，``GridBased`` 被用作插件特定参数的命名空间。当我们讨论参数文件（或参数文件）时，我们将会更多地了解这一点。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:84
msgid "In ``createPlan()`` method, we need to create a path from the given start to goal poses. The ``StraightLine::createPlan()`` is called using start pose and goal pose to solve the global path planning problem. Upon succeeding, it converts the path to the ``nav_msgs::msg::Path`` and returns to the planner server. Below annotation shows the implementation of this method."
msgstr "在``createPlan()``方法中，我们需要根据给定的起始和目标姿态创建一个路径。使用起始姿态和目标姿态调用``StraightLine::createPlan()``来解决全局路径规划问题。成功后，它将路径转换为``nav_msgs::msg::Path``并返回给规划器服务器。下面的注释显示了此方法的实现。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:134
msgid "The remaining methods are not used but it's mandatory to override them. As per the rules, we did override all but left them blank."
msgstr "剩余的方法没有使用，但是强制要求重写它们。根据规则，我们确实重写了所有方法，但是将它们留空。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:139
msgid "Now that we have created our custom planner, we need to export our planner plugin so that it will be visible to the planner server. Plugins are loaded at runtime and if they are not visible, then our planner server won't be able to load it. In ROS 2, exporting and loading plugins is handled by ``pluginlib``."
msgstr "现在我们已经创建了自定义规划器，我们需要导出规划器插件，以便它对规划器服务器可见。插件在运行时加载，如果它们不可见，则我们的规划器服务器将无法加载它。在ROS 2中，导出和加载插件由``pluginlib``处理。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:141
msgid "Coming back to our tutorial, class ``nav2_straightline_planner::StraightLine`` is loaded dynamically as ``nav2_core::GlobalPlanner`` which is our base class."
msgstr "回到我们的教程，类 ``nav2_straightline_planner::StraightLine`` 以 ``nav2_core::GlobalPlanner`` 的形式进行动态加载，后者是我们的基类。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:143
msgid "To export the planner, we need to provide two lines"
msgstr "要导出规划器，我们需要提供两行代码。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:154
msgid "Next step would be to create plugin's description file in the root directory of the package. For example, ``global_planner_plugin.xml`` file in our tutorial package. This file contains the following information"
msgstr "下一步是在包的根目录中创建插件的描述文件。例如，在我们的教程包中创建 ``global_planner_plugin.xml`` 文件。该文件包含以下信息"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:220
msgid "In the above snippet, you can observe the mapping of our ``nav2_straightline_planner/StraightLine`` planner to its id ``GridBased``. To pass plugin-specific parameters, we have used ``<plugin_id>.<plugin_specific_parameter>``."
msgstr "在上面的代码片段中，您可以观察到我们的``nav2_straightline_planner/StraightLine``规划器与其id``GridBased``的映射关系。为了传递特定于插件的参数，我们使用了``<plugin_id>.<plugin_specific_parameter>``的形式。"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:223
msgid "4- Run StraightLine plugin"
msgstr "4- 运行 StraightLine 插件"


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:225
msgid "Run Turtlebot3 simulation with enabled navigation2. Detailed instruction how to make it are written at :ref:`getting_started`. Below is shortcut command for that:"
msgstr "使用已启用的navigation2运行Turtlebot3模拟。有关如何执行此操作的详细说明，请参阅:ref:`getting_started`。下面是一个快捷命令："


#: ../../plugin_tutorials/docs/writing_new_nav2planner_plugin.rst:231
msgid "Then goto RViz and click on the \"2D Pose Estimate\" button at the top and point to the location on map as it was described in :ref:`getting_started`. Robot will localize on the map and then click on \"Navigation2 goal\" and click on the pose where you want your planner to consider a goal pose. After that planner will plan the path and robot will start moving towards the goal."
msgstr "然后进入 RViz，点击顶部的 \"2D Pose Estimate\" 按钮，并指向地图上的位置，就像在 :ref:`getting_started` 中所描述的那样。机器人将在地图上进行定位，然后点击 \"Navigation2 goal\"，并点击您希望规划器考虑的目标位姿。之后规划器将规划路径，机器人将开始朝目标前进。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:4
msgid "Writing a New Navigator Plugin"
msgstr "编写新的导航器插件"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:13
msgid "This tutorial shows how to create your own behavior-tree navigator `plugin <https://index.ros.org/p/pluginlib/>`_ based on the ``nav2_core::BehaviorTreeNavigator`` base class."
msgstr "本教程展示了如何基于 ``nav2_core::BehaviorTreeNavigator`` 基类创建自己的行为树导航器 `插件 <https://index.ros.org/p/pluginlib/>`_。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:15
msgid "In this tutorial, we will be reviewing the ``Navigate to Pose`` behavior-tree navigator plugin, which is the foundational navigator of Nav2 and complimentary behavior to ROS 1 Navigation. This completes point-to-point navigation. This tutorial will be reviewing the code and structure as of ROS 2 Iron. While small variations may be made over time, this should be sufficient to get started writing your own navigator if you choose as we do not expect major API changes on this system."
msgstr "在本教程中，我们将回顾“导航到位姿（Navigate to Pose）”行为树导航器插件，它是Nav2的基础导航器和ROS 1 Navigation的补充行为。这完成了点对点导航。本教程将回顾ROS 2 Iron版本的代码和结构。尽管随着时间的推移可能会进行一些小的变化，但这应该足以让您开始编写自己的导航器，因为我们不希望在此系统上进行重大的API更改。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:17
msgid "It may be beneficial to write your own Navigator if you have a custom action message definition you'd like to use with Navigation rather than the provided ``NavigateToPose`` or ``NavigateThroughPoses`` interfaces (e.g. doing complete coverage or containing additional constraint information). The role of the Navigators are to extract information from requests to pass to the behavior tree / blackboard, populate feedback and responses, and maintain the state of the behavior tree if relevant. The behavior tree XML will define the actual navigation logic used."
msgstr "如果您有自定义的操作消息定义，并且希望与导航一起使用而不是使用提供的“NavigateToPose”或“NavigateThroughPoses”接口（例如完成全面覆盖或包含其他约束信息），则编写自己的导航器可能会有益处。导航器的作用是从请求中提取信息，传递给行为树/黑板，填充反馈和响应，并在相关时维护行为树的状态。行为树的 XML 将定义实际使用的导航逻辑。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:31
msgid "1- Create a new Navigator Plugin"
msgstr "1- 创建新的导航器插件"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:33
msgid "We will be implementing pure point-to-point navigation behavior. The code in this tutorial can be found in `Nav2's BT Navigator package <https://github.com/ros-planning/navigation2/nav2_bt_navigator>`_ as the ``NavigateToPoseNavigator``. This package can be considered as a reference for writing your own plugin."
msgstr "我们将实现纯点对点导航行为。本教程中的代码可以在`Nav2 的 BT Navigator 包 <https://github.com/ros-planning/navigation2/nav2_bt_navigator>`_ 中找到，命名为“NavigateToPoseNavigator”。可以将此包视为编写自己插件的参考。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:35
msgid "Our example plugin class ``nav2_bt_navigator::NavigateToPoseNavigator`` inherits from the base class ``nav2_core::BehaviorTreeNavigator``. The base class provides a set of virtual methods to implement a navigator plugin. These methods are called at runtime by the BT Navigator server or as a response to ROS 2 actions to process a navigation request."
msgstr "我们的示例插件类``nav2_bt_navigator::NavigateToPoseNavigator``继承自基类``nav2_core::BehaviorTreeNavigator``。基类提供了一组虚拟方法来实现导航器插件。这些方法在运行时由BT导航服务器调用，或作为对ROS 2动作的响应以处理导航请求。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:37
msgid "Note that this class has itself a base class of ``NavigatorBase``. This class is to provide a non-templated base-class for use in loading the plugins into vectors for storage and calls for basic state transition in the lifecycle node. Its members (e.g. ``on_XYZ``) are implemented for you in ``BehaviorTreeNavigator`` and marked as ``final`` so they are not possible to be overrided by the user. The API that you will be implementing for your navigator are the virtual methods within ``BehaviorTreeNavigator``, not ``NavigatorBase``. These ``on_XYZ`` APIs are implemented in necessary functions in ``BehaviorTreeNavigator`` to handle boilerplate logic regarding the behavior tree and action server to minimize code duplication across the navigator implementations (e.g. ``on_configure`` will create the action server, register callbacks, populate the blackboard with some necessary basic information, and then call a user-defined ``configure`` function for any additional user-specific needs)."
msgstr "请注意，这个类本身有一个基类“NavigatorBase”。该类提供了一个非模板化的基类，用于将插件加载到向量中以进行存储，并在生命周期节点中进行基本状态转换的调用。其成员（例如“on_XYZ”）在“BehaviorTreeNavigator”中已经为您实现，并标记为“final”，因此用户无法重写它们。您要实现的导航器的 API 是“BehaviorTreeNavigator”中的虚拟方法，而不是“NavigatorBase”。这些“on_XYZ” API 在“BehaviorTreeNavigator”中的必要函数中实现，以处理有关行为树和动作服务器的样板逻辑，以最小化导航器实现之间的代码重复（例如，“on_configure”将创建动作服务器，注册回调，将黑板填充为一些必要的基本信息，然后调用用户定义的“configure”函数以满足任何额外的用户特定需求）。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:39
msgid "The list of methods, their descriptions, and necessity are presented in the table below:"
msgstr "下表列出了方法及其描述和必要性："


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:44
msgid "getDefaultBTFilepath()"
msgstr "getDefaultBTFilepath()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:44
msgid "Method is called on initialization to retrieve the default BT filepath to use for navigation. This may be done via parameters, hardcoded logic, sentinal files, etc."
msgstr "在初始化时调用该方法以获取用于导航的默认BT文件路径。这可以通过参数、硬编码逻辑、哨兵文件等方式完成。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:47
msgid "Method is called when BT navigator server enters on_configure state. This method should implement operations which are neccessary before navigator goes to an active state, such as getting parameters, setting up the blackboard, etc."
msgstr "当 BT 导航服务器进入“on_configure”状态时调用此方法。该方法应该实现在导航器进入活动状态之前的必要操作，如获取参数、设置黑板等。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:51
msgid "Method is called when BT navigator server enters on_activate state. This method should implement operations which are neccessary before navigator goes to an active state, such as create clients and subscriptions."
msgstr "当BT导航服务器进入on_activate状态时调用该方法。此方法应实现在导航器进入活动状态之前必需的操作，例如创建客户端和订阅。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:55
msgid "Method is called when BT navigator server enters on_deactivate state.  This method should implement operations which are neccessary before navigator goes to an inactive state."
msgstr "当 BT 导航服务器进入“on_deactivate”状态时调用此方法。该方法应该实现在导航器进入非活动状态之前的必要操作。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:59
msgid "Method is called when BT navigator server goes to on_cleanup state. This method should clean up resources which are created for the navigator."
msgstr "当BT导航服务器进入on_cleanup状态时调用该方法。此方法应清理为导航器创建的资源。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:62
msgid "goalReceived()"
msgstr "goalReceived()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:62
msgid "Method is called when a new goal is received by the action server to process. It may accept or deny this goal with its return signature. If accepted, it may need to load the appropriate parameters from the request (e.g. which BT to use), add request parameters to the blackboard for your applications use, or reset internal state."
msgstr "当动作服务器接收到新目标以进行处理时调用该方法。它可以通过返回值来接受或拒绝该目标。如果接受，可能需要从请求中加载适当的参数（例如要使用的BT），将请求参数添加到黑板以供应用程序使用，或重置内部状态。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:67
msgid "onLoop()"
msgstr "onLoop()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:67
msgid "Method is called periodically while the behavior tree is looping to check statuses or more commonly to publish action feedback statuses to the client."
msgstr "在行为树循环过程中，定期调用此方法来检查状态，或更常见地向客户端发布动作反馈状态。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:70
msgid "onPreempt()"
msgstr "onPreempt()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:70
msgid "Method is called when a new goal is requesting preemption over the existing goal currently being processed. If the new goal is viable, it should make all appropriate updates to the BT and blackboard such that this new request may immediately start being processed without hard cancelation of the initial task (e.g. preemption)."
msgstr "当一个新目标请求对当前正在处理的现有目标进行抢占时，调用该方法。如果新目标可行，应对BT和黑板进行所有适当的更新，以使该新请求可以立即开始处理，而无需硬取消初始任务（例如抢占）。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:76
msgid "goalCompleted()"
msgstr "goalCompleted()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:76
msgid "Method is called when a goal is completed to populate the action result object or do any additional checks required at the end of a task."
msgstr "当目标完成以填充动作结果对象或在任务结束时执行任何其他必要检查时调用该方法。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:79
msgid "getName()"
msgstr "getName()"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:79
msgid "Method is called to get the name of this navigator type"
msgstr "调用该方法以获取此导航器类型的名称。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:82
msgid "In the Navigate to Pose Navigator, ``configure()`` method must determine the blackboard parameter names where the goal and paths are being stored, as these are key values for processing feedback in ``onLoop`` and for the different behavior tree nodes to communicate this information between themselves. Additionally and uniquely to this navigator type, we also create a client to itself and a subscription to the ``goal_pose`` topic such that requests from the default configurations of Rviz2 using the *Goal Pose* tool will be processed."
msgstr "在导航到位点导航器中，``configure()`` 方法必须确定存储目标和路径的黑板参数名称，因为这些是在 ``onLoop`` 中处理反馈的关键值，并且对于不同的行为树节点之间进行信息交流也很重要。此外，对于这种导航器类型，我们还创建一个自身的客户端和一个订阅 ``goal_pose`` 话题的订阅器，以便处理来自 Rviz2 的默认配置（使用 *目标位姿* 工具）的请求。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:117
msgid "The values of the blackboard IDs are stored alongside the odometry smoother the BT Navigator provides for populating meaningful feedback later. Complimentary to this, the ``cleanup`` method will reset these resources. The activate and deactivate methods are not used in this particular navigator."
msgstr "黑板ID的值与里程平滑器存储在一起，BT导航器提供了填充有意义反馈的功能，以便稍后使用。与此相辅相成的是，``cleanup``方法将重置这些资源。在此特定的导航器中，不使用activate和deactivate方法。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:128
msgid "In the ``getDefaultBTFilepath()``, we use a parameter ``default_nav_to_pose_bt_xml`` to get the default behavior tree XML file to use if none is provided by the navigation request and to initialize the BT Navigator with a behavior tree hot-loaded. If one is not provided in the parameter files, then we grab a known and reasonable default XML file in the ``nav2_bt_navigator`` package:"
msgstr "在 ``getDefaultBTFilepath()`` 中，我们使用参数 ``default_nav_to_pose_bt_xml`` 来获取默认的行为树 XML 文件，以便在导航请求没有提供文件时使用，并用其初始化 BT 导航器。如果参数文件中没有提供文件，那么我们会在 ``nav2_bt_navigator`` 包中选择一个已知且合理的默认 XML 文件："


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:152
msgid "When a goal is received, we need to determine if this goal is valid and should be processed. The ``goalReceived`` method provides you the ``goal`` and a return value if it is being processed or not. This information is sent back to the action server to notify the client. In this case, we want to make sure that the goal's behavior tree is valid or else we cannot proceed. If it is valid, then we can initialize the goal pose onto the blackboard and reset some state in order to cleanly process this new request."
msgstr "当接收到一个目标时，我们需要确定该目标是否有效并且应该被处理。``goalReceived``方法提供了目标和一个返回值，用于确定目标是否正在被处理。这些信息被发送回操作服务器以通知客户端。在这种情况下，我们要确保目标的行为树是有效的，否则我们无法继续。如果有效，我们可以将目标姿态初始化到黑板上，并重置一些状态，以便清洁地处理这个新请求。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:173
msgid "Once this goal is completed, we need to populate the Action's result, if required and meaningful. In this navigator's case, it contains no result information when the navigation request was completed successfully, so this method is empty. For other navigator types, you may populate the ``result`` object provided."
msgstr "一旦完成了这个目标，如果需要且有意义，我们需要填充动作的结果。在这个导航器的情况下，当导航请求成功完成时，它不包含任何结果信息，因此该方法为空。对于其他导航器类型，您可以填充提供的 ``result`` 对象。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:183
msgid "If however a goal is preempted (e.g. a new action request comes in while an existing request is being processed), the ``onPreempt()`` method is called to determine if the new request is genuine and appropriate to preempt the currently processing goal. For example, it might not be wise to accept a preeemption request if that request is fundamentally different in nature from an existing behavior tree task or when your existing task is of a higher priority."
msgstr "然而，如果一个目标被抢占（例如，在处理现有请求时收到新的请求），``onPreempt()``方法将被调用，以确定新的请求是否真实且适合抢占当前处理的目标。例如，如果该请求在本质上与现有的行为树任务有根本不同，或者当您现有的任务具有较高的优先级时，接受抢占请求可能是不明智的。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:211
msgid "Note that here you can also see the ``initializeGoalPose`` method called. This method will set the goal parameters for this navigator onto the blackboard and reset important state information to cleanly re-use a behavior tree without old state information, as shown below:"
msgstr "请注意，在这里您还可以看到调用了 ``initializeGoalPose`` 方法。该方法将将导航器的目标参数设置到黑板上，并重置重要的状态信息，以便在不带有旧状态信息的情况下清洁地重用行为树，如下所示："


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:231
msgid "The recovery counter and start time are both important feedback terms for a client to understand the state of the current task (e.g. if its failing, having problems, or taking exceptionally long). The setting of the goal on the blackboard is taken by the ``ComputePathToPose`` BT Action node to plan a new route to the goal (and then who's path is communicated to the ``FollowPath`` BT node via the blackboard ID previously set)."
msgstr "恢复计数器和启动时间都是客户端了解当前任务状态的重要反馈信息（例如，如果它失败、出现问题或者花费异常长的时间）。将目标设置到黑板上是由``ComputePathToPose``BT动作节点接管的，以规划到目标的新路径（然后将其路径通过之前设置的黑板ID传递给``FollowPath``BT节点）。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:233
msgid "The final function implemented is ``onLoop``, which is simplified below for tutorial purposes. While anything can be done in this method, which is called as the BT is looping through the tree, it is common to use this as an opportunity to populate any necessary feedback about the state of the navigation request, robot, or metadata that a client might be interested in."
msgstr "最后实现的函数是 ``onLoop``，出于教学目的，下面进行了简化。虽然在此方法中可以执行任何操作，该方法会在BT通过树循环时被调用，通常可以利用此机会填充有关导航请求、机器人或客户端可能感兴趣的元数据的任何必要反馈信息。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:261
msgid "2- Exporting the navigator plugin"
msgstr "2- 导出导航器插件"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:263
msgid "Now that we have created our custom navigator, we need to export our plugin so that it would be visible to the BT Navigator server. Plugins are loaded at runtime, and if they are not visible, then our server won't be able to load it. In ROS 2, exporting and loading plugins is handled by ``pluginlib``."
msgstr "现在，我们已经创建了自定义的导航器，需要导出我们的插件，以便BT Navigator服务器能够看到它。插件在运行时加载，如果它们不可见，则我们的服务器将无法加载它。在ROS 2中，导出和加载插件由 ``pluginlib`` 处理。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:267
msgid "Coming to our tutorial, class ``nav2_bt_navigator::NavigateToPoseNavigator`` is loaded dynamically as ``nav2_core::NavigatorBase`` which is our base class due to the subtleties previously described."
msgstr "接下来我们的教程中，``nav2_bt_navigator::NavigateToPoseNavigator``类以``nav2_core::NavigatorBase``的形式动态加载，这是我们的基类，由于前面描述的细微差别。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:280
msgid "The next step would be to create the plugin's description file in the root directory of the package. For example, ``navigator_plugin.xml`` file in our tutorial package. This file contains the following information"
msgstr "下一步是在软件包的根目录中创建插件的描述文件。例如，在我们的教程软件包中创建 ``navigator_plugin.xml`` 文件。该文件包含以下信息"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:340
msgid "In the above snippet, you can observe the mapping of our ``nav2_bt_navigator/NavigateToPoseNavigator`` plugin to its id ``navigate_to_pose``. To pass plugin-specific parameters we have used ``<plugin_id>.<plugin_specific_parameter>``."
msgstr "在上面的片段中，您可以观察到我们的``nav2_bt_navigator/NavigateToPoseNavigator``插件与其id ``navigate_to_pose``之间的映射关系。为了传递插件特定的参数，我们使用了``<plugin_id>.<plugin_specific_parameter>``。"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:344
msgid "4- Run plugin"
msgstr "4- 运行插件"


#: ../../plugin_tutorials/docs/writing_new_navigator_plugin.rst:352
msgid "Then goto RViz and click on the \"2D Pose Estimate\" button at the top and point the location on the map as it was described in :ref:`getting_started`. The robot will localize on the map and then click on the \"Nav2 goal\" and click on the pose where you want your robot to navigate to. After that navigator will take over with the behavior tree XML file behavior definition provided to it."
msgstr "然后打开RViz，在顶部点击“2D Pose Estimate”按钮，并在地图上指定位置，就像在 :ref:`getting_started` 中描述的那样。机器人将在地图上进行定位，然后点击“Nav2 goal”，并点击您希望机器人导航到的姿势。之后导航器将使用提供的行为树XML文件行为定义接管控制。"


#: ../../plugin_tutorials/index.rst:4
msgid "Plugin Tutorials"
msgstr "插件教程"


#: ../../plugin_tutorials/index.rst:6
msgid "Navigation2 Tutorials"
msgstr "Navigation2教程"

