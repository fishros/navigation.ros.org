# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020
# This file is distributed under the same license as the Navigation 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Navigation 2 latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-18 21:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"


#: ../../tuning/index.rst:4
msgid "Tuning Guide"
msgstr "调优指南"


#: ../../tuning/index.rst:6
msgid "This guide is meant to assist users in tuning their navigation system. While :ref:`configuration` is the home of the list of parameters for all of Nav2, it doesn't contain much *color* for how to tune a system using the most important of them. The aim of this guide is to give more advice in how to setup your system beyond a first time setup, which you can find at :ref:`setup_guides`. This will by no means cover all of the parameters (so please, do review the configuration guides for the packages of interest), but will give some helpful hints and tips."
msgstr "本指南旨在帮助用户调整其导航系统。虽然 :ref:`configuration` 包含了Nav2的所有参数列表，但对于如何使用其中最重要的参数进行调优，它并没有提供太多的指导。本指南的目的是在第一次设置之后提供更多关于如何设置系统的建议，您可以在 :ref:`setup_guides` 中找到第一次设置的相关信息。这并不意味着涵盖了所有参数（因此，请查阅感兴趣的软件包的配置指南），但会提供一些有用的提示和技巧。"


#: ../../tuning/index.rst:8
msgid "This tuning guide is a perpetual work in progress. If you see some insights you have missing, please feel free to file a ticket or pull request with the wisdom you would like to share. This is an open section supported by the generosity of Nav2 users and maintainers. Please consider paying it forward."
msgstr "这个调优指南是一个持续进行中的工作。如果你发现有一些你缺失的见解，请随时提交一个工单或拉取请求，分享你想要分享的智慧。这是一个由Nav2用户和维护人员慷慨支持的开放部分。请考虑回馈。"


#: ../../tuning/index.rst:11
msgid "Inflation Potential Fields"
msgstr "膨胀潜力场"


#: ../../tuning/index.rst:13
msgid "Many users and ecosystem navigation configuration files the maintainers find are really missing the point of the inflation layer. While it's true that you can simply inflate a small radius around the walls to weight against critical collisions, the *true* value of the inflation layer is creating a consistent potential field around the entire map."
msgstr "许多用户和生态系统的导航配置文件中，维护人员发现实际上忽略了膨胀层的要点。虽然你可以简单地在墙壁周围膨胀一个小半径以避免严重碰撞，但是膨胀层的真正价值在于创建一个始终如一的势场，覆盖整个地图。"


#: ../../tuning/index.rst:15
msgid "Some of the most popular tuning guides for ROS Navigation / Nav2 even `call this out specifically <https://arxiv.org/pdf/1706.09068.pdf>`_ that there's substantial benefit to creating a gentle potential field across the width of the map - after inscribed costs are applied - yet very few users do this in practice."
msgstr "一些最受欢迎的ROS导航/Nav2调优指南甚至在 `这方面特别指出 <https://arxiv.org/pdf/1706.09068.pdf>`_ ，在应用内刻画成本之后，在地图的宽度上创建一个平滑的潜力场会带来实质性的好处，但实际上很少有用户这样做。"


#: ../../tuning/index.rst:17
msgid "This habit actually results in paths produced by NavFn, Theta\\*, and Smac Planner to be somewhat suboptimal. They really want to look for a smooth potential field rather than wide open 0-cost spaces in order to stay in the middle of spaces and deal with close-by moving obstacles better. It will allow search to be weighted towards freespace far before the search algorithm runs into the obstacle that the inflation is caused by, letting the planner give obstacles as wide of a berth as possible."
msgstr "这种做法实际上会导致NavFn、Theta*和Smac Planner生成的路径略显次优。它们实际上更希望寻找一个平滑的势场，而不是广阔开放的零代价空间，以便保持在空间的中间位置并更好地处理附近的移动障碍物。这将允许搜索在搜索算法遇到膨胀引起的障碍物之前就偏向于自由空间，从而使规划器尽可能地远离障碍物。"


#: ../../tuning/index.rst:19
msgid "So it is the maintainers' recommendation, as well as all other cost-aware search planners available in ROS, to increase your inflation layer cost scale and radius in order to adequately produce a smooth potential across the entire map. For very large open spaces, its fine to have 0-cost areas in the middle, but for halls, aisles, and similar; **please create a smooth potential to provide the best performance**."
msgstr "因此，根据维护者的建议以及ROS中提供的所有其他成本感知搜索规划器，为了在整个地图上充分产生平滑的潜力场，您需要增加膨胀层的成本比例和半径。对于非常大的开放空间，在中间有0成本区域是可以接受的，但对于大厅、过道和类似的区域，请**创建一个平滑的潜力场以获得最佳性能**。"


#: ../../tuning/index.rst:22
msgid "Robot Footprint vs Radius"
msgstr "机器人足迹与半径"


#: ../../tuning/index.rst:24
msgid "Nav2 allows users to specify the robot's shape in 2 ways: a geometric ``footprint`` or the radius of a circle encompassing the robot. In ROS (1), it was pretty reasonable to always specify a radius approximation of the robot, since the global planning algorithms didn't use it and the local planners / costmaps were set up with the circular assumption baked in."
msgstr "Nav2允许用户以两种方式指定机器人的形状：几何“footprint”或包围机器人的圆的半径。在ROS（1）中，通常指定一个近似的机器人半径是相当合理的，因为全局规划算法不使用它，并且本地规划器/成本图设置了圆形的假设。"


#: ../../tuning/index.rst:26
msgid "However, in Nav2, we now have multiple planning and controller algorithms that make use of the full SE2 footprint. If your robot is non-circular, it is recommended that you give the planners and controllers the actual, geometric footprint of your robot. This will allow the planners and controllers to plan or create trajectories into tighter spaces. For example, if you have a very long but skinny robot, the circular assumption wouldn't allow a robot to plan into a space only a little wider than your robot, since the robot would not fit length-wise."
msgstr "然而，在Nav2中，我们现在有多个规划和控制算法使用完整的SE2足迹。如果你的机器人不是圆形的，建议你给规划器和控制器提供机器人的实际几何足迹。这将使规划器和控制器能够规划或创建进入更狭小空间的轨迹。例如，如果你有一个非常长但瘦的机器人，圆形的假设将不允许机器人规划进入只比机器人稍宽一点的空间，因为机器人无法长度方向上适应。"


#: ../../tuning/index.rst:28
msgid "The kinematically feasible planners (e.g. Smac Hybrid-A\\*, Smac State Lattice) will use the SE2 footprint for collision checking to create kinematically feasible plans, if provided with the actual footprint. As of December, 2021 all of the controller plugins support full footprint collision checking to ensure safe path tracking. If you provide a footprint of your robot, it will be used to make sure trajectories are valid and it is recommended you do so. It will prevent a number of \"stuck robot\" situations that could have been easily avoided."
msgstr "如果提供了实际足迹，运动可行的规划器（例如Smac Hybrid-A*，Smac State Lattice）将使用SE2足迹进行碰撞检查，以创建运动可行的路径规划。截至2021年12月，所有的控制器插件都支持完整的足迹碰撞检查，以确保路径跟踪的安全性。如果您提供了机器人的足迹，它将被用于确保轨迹的有效性，建议您这样做。这将防止一些可能本可以轻松避免的\"卡住的机器人\"情况的发生。"


#: ../../tuning/index.rst:30
msgid "If your robot is truly circular, continue to use the ``robot_radius`` parameter. The three valid reasons for a non-circular robot to use the radius instead:"
msgstr "如果你的机器人确实是圆形的，请继续使用``robot_radius``参数。非圆形机器人使用半径而不是SE2足迹的三个有效原因："


#: ../../tuning/index.rst:32
msgid "The robot is very small relative to the environment (e.g. RC car in a warehouse)"
msgstr "相对于环境来说，机器人非常小（例如在仓库中的遥控车）"


#: ../../tuning/index.rst:33
msgid "The robot has such limited compute power, using SE2 footprint checking would add too much computational burden (e.g. embedded micro-processors)"
msgstr "机器人的计算能力非常有限，使用SE2足迹检查会增加太多的计算负担（例如嵌入式微处理器）。"


#: ../../tuning/index.rst:34
msgid "If you plan to use a holonomic planner (e.g. Theta\\*, Smac 2D-A\\*, or NavFn), you may continue to use the circular footprint, since these planners are not kinematically feasible and will not make use of the SE2 footprint anyway."
msgstr "如果您打算使用全向规划器（例如Theta*，Smac 2D-A*或NavFn），您可以继续使用圆形足迹，因为这些规划器不是运动可行的，也不会使用SE2足迹。"


#: ../../tuning/index.rst:38
msgid "Rotate in Place Behavior"
msgstr "就地旋转行为"


#: ../../tuning/index.rst:40
msgid "Using the :ref:`configuring_rotation_shim`, a robot will simply rotate in place before starting to track a holonomic path. This allows a developer to tune a controller plugin to be optimized for path tracking and give you clean rotations, out of the box."
msgstr "通过使用:ref:`configuring_rotation_shim`，机器人将在开始跟踪全向路径之前简单地原地旋转。这使开发人员可以调整控制器插件以优化路径跟踪并为您提供干净的旋转效果。"


#: ../../tuning/index.rst:42
msgid "This was added due to quirks in some existing controllers whereas tuning the controller for a task can make it rigid -- or the algorithm simply doesn't rotate in place when working with holonomic paths (if that's a desirable trait). The result is an awkward, stuttering, or whipping around behavior when your robot's initial and path heading's are significantly divergent. Giving a controller a better starting point to start tracking a path makes tuning the controllers significantly easier and creates more intuitive results for on-lookers (in one maintainer's opinion)."
msgstr "由于某些现有控制器存在问题，调整控制器以完成任务可能会使其僵硬，或者在使用全向路径时根本无法就地旋转（如果这是一种理想的特性）。结果是，当机器人的初始朝向和路径朝向明显不同时，会出现尴尬、抽搐或旋转行为。给控制器一个更好的起点来跟踪路径，可以大大简化控制器的调整，并为观察者创造更直观的结果（至少在某一维护人员的看法中是这样的）。"


#: ../../tuning/index.rst:44
msgid "Note: If using a non-holonomic, kinematically feasible planner (e.g. Smac Hybrid-A\\*, Smac State Lattice), this is not a necessary behavioral optimization. This class of planner will create plans that take into account the robot's starting heading, not requiring any rotation behaviors."
msgstr "注意：如果使用非全向的运动可行规划器（例如Smac Hybrid-A*，Smac State Lattice），这不是必要的行为优化。这类规划器将创建考虑到机器人起始朝向的路径规划，不需要任何旋转行为。"


#: ../../tuning/index.rst:46
msgid "This behavior is most optimially for:"
msgstr "此行为最适用于："


#: ../../tuning/index.rst:48
msgid "Robots that can rotate in place, such as differential and omnidirectional robots."
msgstr "能够原地旋转的机器人，如差分驱动和全向驱动机器人。"


#: ../../tuning/index.rst:49
msgid "Preference to rotate in place when starting to track a new path that is at a significantly different heading than the robot’s current heading – or when tuning your controller for its task makes tight rotations difficult."
msgstr "当开始跟踪一个与机器人当前朝向明显不同的新路径时，或者当调整控制器以完成任务时，紧密旋转变得困难时，首选就地旋转。"


#: ../../tuning/index.rst:52
msgid "Planner Plugin Selection"
msgstr "规划器插件选择"


#: ../../tuning/index.rst:54
msgid "Nav2 provides a number of planning plugins out of the box. For a first-time setup, see :ref:`select_algorithm` for a more verbose breakdown of algorithm styles within Nav2, and :ref:`plugins` for a full accounting of the current list of plugins available (which may be updated over time)."
msgstr "Nav2提供了许多规划插件。对于首次设置，请参阅:ref:`select_algorithm`以获取有关Nav2中算法风格的更详细说明，以及:ref:`plugins`以获取当前可用插件的完整列表（可能会随时间更新）。"


#: ../../tuning/index.rst:56
msgid "In general though, the following table is a good guide for the optimal planning plugin for different types of robot bases:"
msgstr "总的来说，下表是针对不同类型的机器人底盘的最佳规划插件的良好指南："


#: ../../tuning/index.rst:59 ../../tuning/index.rst:87
msgid "Plugin Name"
msgstr "插件名称"


#: ../../tuning/index.rst:59 ../../tuning/index.rst:87
msgid "Supported Robot Types"
msgstr "支持的机器人类型"


#: ../../tuning/index.rst:61
msgid "NavFn Planner"
msgstr "NavFn规划器"


#: ../../tuning/index.rst:61
msgid "Circular Differential, Circular Omnidirectional"
msgstr "圆形差分，圆形全向"


#: ../../tuning/index.rst:63
msgid "Smac Planner 2D"
msgstr "Smac 2D规划器"


#: ../../tuning/index.rst:65
msgid "Theta Star Planner"
msgstr "Theta Star Planner"


#: ../../tuning/index.rst:67
msgid "Smac Hybrid-A* Planner"
msgstr "Smac混合A*规划器"


#: ../../tuning/index.rst:67
msgid "Non-circular or Circular Ackermann, Non-circular or Circular Legged"
msgstr "非圆形或圆形阿克曼，非圆形或圆形腿式"


#: ../../tuning/index.rst:69
msgid "Smac Lattice Planner"
msgstr "Smac格栅规划器"


#: ../../tuning/index.rst:69
msgid "Non-circular Differential, Non-circular Omnidirectional, Arbitrary"
msgstr "非圆形差分，非圆形全向，任意"


#: ../../tuning/index.rst:72
msgid "If you are using a non-circular robot with very limited compute, it may be worth assessing the benefits of using one of the holonomic planners (e.g. particle assumption planners). It is the recommendation of the maintainers to start using one of the more advanced algorithms appropriate for your platform *first*, but to scale back the planner if need be. The run-time of the feasible planners are typically on par (or sometimes faster) than their holonomic counterparts, so don't let the more recent nature of them fool you."
msgstr "如果您使用的是非圆形机器人且计算能力非常有限，评估使用全向规划器（例如粒子假设规划器）的好处可能是值得的。维护者建议首先开始使用适合您的平台的更高级算法，但如果需要，可以缩小规划器。可行规划器的运行时间通常与它们的全向对应物相当（或有时更快），所以不要被它们较新的特性所迷惑。"


#: ../../tuning/index.rst:74
msgid "Since the planning problem is primarily driven by the robot type, the table accurately summarizes the advice to users by the maintainers. Within the circular robot regime, the choice of planning algorithm is dependent on application and desirable behavior. NavFn will typically make broad, sweeping curves; Theta\\* prefers straight lines and supports them at any angle; and Smac 2D is essentially a classical A\\* algorithm with cost-aware penalties."
msgstr "由于规划问题主要受机器人类型驱动，该表格准确总结了维护者向用户提供的建议。在圆形机器人领域内，规划算法的选择取决于应用和所需行为。NavFn通常会产生宽广的曲线；Theta\\*更偏好直线并支持任意角度；而Smac 2D本质上是一种具有成本感知惩罚的经典A\\*算法。"


#: ../../tuning/index.rst:77
msgid "These are simply the default and available plugins from the community. For a specific application / platform, you may also choose to use none of these and create your own, and that's the intention of the Nav2 framework. See the :ref:`writing_new_nav2planner_plugin` tutorial for more details. If you're willing to contribute this work back to the community, please file a ticket or contact a maintainer! They'd love to hear from you."
msgstr "这些只是社区提供的默认和可用插件。针对特定应用/平台，您也可以选择不使用这些插件并自己创建，这是Nav2框架的目的。有关详细信息，请参阅:ref:`writing_new_nav2planner_plugin`教程。如果您愿意将这项工作贡献给社区，请提交工单或联系维护者！他们会很乐意听取您的意见。"


#: ../../tuning/index.rst:80
msgid "Controller Plugin Selection"
msgstr "控制器插件选择"


#: ../../tuning/index.rst:82
msgid "Nav2 provides a number of controller plugins out of the box. For a first-time setup, see :ref:`select_algorithm` for a more verbose breakdown of algorithm styles within Nav2, and :ref:`plugins` for a full accounting of the current list of plugins available (which may be updated over time)."
msgstr "Nav2提供了一系列现成的控制器插件。对于首次设置，请参阅:ref:`select_algorithm`以获取有关Nav2中算法样式的更详细解释，以及:ref:`plugins`以获取当前可用插件的完整列表（可能会随时间更新）"


#: ../../tuning/index.rst:84
msgid "In general though, the following table is a good first-order description of the controller plugins available for different types of robot bases:"
msgstr "一般而言，下表是对不同类型机器人底盘可用的控制器插件的良好初步描述："


#: ../../tuning/index.rst:87
msgid "Task"
msgstr "任务"


#: ../../tuning/index.rst:89
msgid "DWB controller"
msgstr "DWB控制器"


#: ../../tuning/index.rst:89 ../../tuning/index.rst:95
msgid "Differential, Omnidirectional"
msgstr "差动、全向"


#: ../../tuning/index.rst:89 ../../tuning/index.rst:91
msgid "Dynamic obstacle avoidance"
msgstr "动态障碍物避免"


#: ../../tuning/index.rst:91
msgid "TEB Controller"
msgstr "TEB 控制器"


#: ../../tuning/index.rst:91
msgid "Differential, Omnidirectional, Ackermann, Legged"
msgstr "差动、全向、阿克曼、腿式"


#: ../../tuning/index.rst:93
msgid "RPP controller"
msgstr "RPP 控制器"


#: ../../tuning/index.rst:93
msgid "Differential, Ackermann, Legged"
msgstr "差动、阿克曼、腿式"


#: ../../tuning/index.rst:93
msgid "Exact path following"
msgstr "精确路径跟随"


#: ../../tuning/index.rst:95
msgid "Rotation Shim"
msgstr "旋转衬垫"


#: ../../tuning/index.rst:95
msgid "Rotate to rough heading"
msgstr "旋转至粗略方向"


#: ../../tuning/index.rst:98
msgid "All of the above controllers can handle both circular and arbitrary shaped robots in configuration."
msgstr "上述所有控制器都可以处理圆形和任意形状的机器人配置。"


#: ../../tuning/index.rst:100
msgid "Regulated Pure Pursuit is good for exact path following and is typically paired with one of the kinematically feasible planners (eg State Lattice, Hybrid-A\\*, etc) since those paths are known to be drivable given hard physical constraints. However, it can also be applied to differential drive robots who can easily pivot to match any holonomic path. This is the plugin of choice if you simply want your robot to follow the path, rather exactly, without any dynamic obstacle avoidance or deviation. It is simple and geometric, as well as slowing the robot in the presence of near-by obstacles *and* while making sharp turns."
msgstr "调整纯追踪（Regulated Pure Pursuit）适用于精确路径跟随，并通常与其中一个运动学可行的规划器（例如状态网格、混合A*等）配对使用，因为这些路径在给定严格物理约束的情况下可以行驶。然而，它也可以应用于差分驱动机器人，它们可以轻松转动以匹配任何全向路径。如果您只希望您的机器人按照路径行驶，而不需要任何动态障碍物避免或偏离，那么这就是首选插件。它简单而几何，同时在附近有障碍物 *并且* 进行急转弯时会减速机器人。"


#: ../../tuning/index.rst:102
msgid "DWB and TEB are both options that will track paths, but also diverge from the path if there are dynamic obstacles present (in order to avoid them). DWB does this through scoring multiple trajectories on a set of critics. These trajectories are also generated via plugins that can be replaced, but support out of the box Omni and Diff robot types within the valid velocity and acceleration restrictions. These critics are plugins that can be selected at run-time and contain weights that may be tuned to create the desired behavior, such as minimizing path distance, minimizing distance to the goal or headings, and other action penalties that can be designed. This does require a bit of tuning for a given platform, application, and desired behavior, but it is possible to tune DWB to do nearly any single thing well."
msgstr "DWB 和 TEB 都是可以追踪路径的选项，但是如果存在动态障碍物，它们也会偏离路径（以避免碰撞）。DWB 通过在一组评价器上对多条轨迹进行评分来实现这一点。这些轨迹也是通过可以替换的插件生成的，但支持开箱即用的 Omni 和 Diff 机器人类型，并遵守有效速度和加速度限制。这些评价器是可以在运行时选择的插件，并包含可以调节的权重，以创建所需的行为，例如最小化路径距离、最小化距离到目标或航向，以及其他可以设计的动作惩罚。对于特定的平台、应用和所需的行为，这需要进行一些调整，但可以调整 DWB 以实现几乎任何单一目标的良好表现。"


#: ../../tuning/index.rst:104
msgid "TEB on the other hand implements an optimization based approach, generating a graph-solving problem for path tracking in the presence of obstacles. TEB is pretty good at handling dynamic situations well with other moving agents in the scene, but at a much higher compute cost that makes it largely unsuitable for smaller compute platform robots (e.g. minimum i3 and running at 20hz). This typically works pretty well out of the box, but to tune for specific behaviors, you may have to modify optimization engine parameters which are not as intuitive or rooted in something physical as DWB, but have pretty decent defaults."
msgstr "另一方面，TEB 实现了一种基于优化的方法，为存在障碍物的路径跟踪生成了一个图解问题。TEB 在处理场景中存在其他移动代理时表现出色，但计算成本要高得多，因此它在较小的计算平台机器人（例如最低配置为i3，以20hz运行）上大部分不适用。通常情况下，这种方法的效果相当不错，但要调整特定行为，您可能需要修改优化引擎参数，这些参数不如DWB直观或根植于某种物理概念，但具有相当不错的默认值。"


#: ../../tuning/index.rst:106
msgid "Finally, the Rotation Shim Plugin helps assist plugins like TEB and DWB (among others) to rotate the robot in place towards a new path's heading before starting to track the path. This allows you to tune your local trajectory planner to operate with a desired behavior without having to worry about being able to rotate on a dime with a significant deviation in angular distance over a very small euclidean distance. Some controllers when heavily tuned for accurate path tracking are constrained in their actions and don't very cleanly rotate to a new heading. Other controllers have a 'spiral out' behavior because their sampling requires some translational velocity, preventing it from simply rotating in place. This helps alleviate that problem and makes the robot rotate in place very smoothly."
msgstr "最后，Rotation Shim 插件有助于辅助 TEB 和 DWB（以及其他插件）将机器人原地旋转到新路径的航向上，然后开始追踪路径。这样可以使您调整本地轨迹规划器以实现所需的行为，而不必担心能否在非常小的欧几里得距离上迅速旋转并在角度上产生显著偏差。有些控制器在进行准确路径追踪时，由于受到其动作限制，无法非常清晰地旋转到新的航向。其他控制器具有“螺旋外扩”的行为，因为它们的采样需要一定的平移速度，这使得它无法简单地原地旋转。这有助于缓解这个问题，使机器人能够平稳地原地旋转。"


#: ../../tuning/index.rst:109
msgid "These are simply the default and available plugins from the community. For a specific robot platform / company, you may also choose to use none of these and create your own. See the :ref:`writing_new_nav2controller_plugin` tutorial for more details. If you're willing to contribute this work back to the community, please file a ticket or contact a maintainer! They'd love to hear from you."
msgstr "这些只是社区中默认和可用的插件。对于特定的机器人平台/公司，您也可以选择不使用这些插件，而是创建自己的插件。有关更多详细信息，请参阅 :ref:`writing_new_nav2controller_plugin` 教程。如果您愿意将这项工作贡献给社区，请提交工单或联系维护人员！他们将非常乐意听取您的意见。"


#: ../../tuning/index.rst:112
msgid "Caching Obstacle Heuristic in Smac Planners"
msgstr "在 Smac 规划器中缓存障碍物启发式函数"


#, python-format
msgid "Smac's Hybrid-A* and State Lattice Planners provide an option, ``cache_obstacle_heuristic``. This can be used to cache the heuristic to use between replannings to the same goal pose, which can increase the speed of the planner **significantly** (40-300% depending on many factors). The obstacle heuristic is used to steer the robot into the middle of spaces, respecting costs, and drives the kinematically feasible search down the corridors towards a valid solution. Think of it like a 2D cost-aware search to \"prime\" the planner about where it should go when it needs to expend more effort in the fully feasible search / SE2 collision checking."
msgstr "Smac的混合A*和状态格规划器提供了一个选项，``cache_obstacle_heuristic``。这个选项可以用来在重新规划到相同目标位姿时缓存启发式函数，从而可以显著提高规划器的速度（取决于许多因素，速度提高了40-300%）。障碍启发式函数用于将机器人引导到空间中间，遵循成本，并沿着走廊进行运动学可行性搜索，朝着有效解决方案。可以将其视为一个二维成本感知搜索，用于在完全可行的搜索/ SE2碰撞检测中，为规划器提供关于需要在何处进行更多努力的提示。"


#: ../../tuning/index.rst:116
msgid "This is useful to speed up performance to achieve better replanning speeds. However, if you cache this heuristic, it will not be updated with the most current information in the costmap to steer search. During planning, the planner will still make use of the newest cost information for collision checking, *thusly this will not impact the safety of the path*. However, it may steer the search down newly blocked corridors or guide search towards areas that may have new dynamic obstacles in them, which can slow things down significantly if entire solution spaces are blocked."
msgstr "这有助于提高性能以实现更快的重规划速度。但是，如果缓存这个启发式函数，它将不会根据代价地图的最新信息进行更新以引导搜索。在规划过程中，规划器仍会使用最新的碰撞检查代价信息，*因此这不会影响路径的安全性*。然而，它可能会将搜索引导到新封闭的通道或可能存在新的动态障碍物的区域，如果整个解空间被阻塞，这可能会显著减慢速度。"


#: ../../tuning/index.rst:118
msgid "Therefore, it is the recommendation of the maintainers to enable this only when working in largely static (e.g. not many moving things or changes, not using live sensor updates in the global costmap, etc) environments when planning across large spaces to singular goals. Between goal changes to Nav2, this heuristic will be updated with the most current set of information, so it is not very helpful if you change goals very frequently."
msgstr "因此，维护者建议只在在大部分静态环境中工作（例如，没有太多移动物体或变化，在全局代价地图中不使用实时传感器更新等情况下），在规划跨越大空间到单一目标时启用此选项。在目标更改到Nav2时，这个启发式函数将会根据最新的信息进行更新，因此如果您频繁更改目标，它并不是非常有帮助。"


#: ../../tuning/index.rst:121
msgid "Nav2 Launch Options"
msgstr "Nav2 启动选项"


#: ../../tuning/index.rst:123
msgid "Nav2's launch files are made to be very configurable. Obviously for any serious application, a user should use ``nav2_bringup`` as the basis of their navigation launch system, but should be moved to a specific repository for a users' work. A typical thing to do is to have a ``<robot_name>_nav`` configuration package containing the launch and parameter files."
msgstr "Nav2的启动文件可以非常可配置。显然，对于任何严肃的应用程序，用户应该将``nav2_bringup``作为其导航启动系统的基础，但是应该将其移到一个特定的存储库中供用户使用。一个典型的做法是创建一个包含启动和参数文件的``<robot_name>_nav``配置包。"


#: ../../tuning/index.rst:125
msgid "Within ``nav2_bringup``, there is a main entryfile ``tb3_simulation_launch.py``. This is the main file used for simulating the robot and contains the following configurations:"
msgstr "在 ``nav2_brin"


#: ../../tuning/index.rst:127
msgid "``slam`` : Whether or not to use AMCL or SLAM Toolbox for localization and/or mapping. Default ``false`` to AMCL."
msgstr "``slam``：是否使用AMCL或SLAM Toolbox进行定位和/或建图。默认值为``false``，即使用AMCL。"


#: ../../tuning/index.rst:128
msgid "``map`` : The filepath to the map to use for navigation. Defaults to ``map.yaml`` in the package's ``maps/`` directory."
msgstr "``map`` : The filepath to the map to use for navigation. Defaults to ``map.yaml`` in the package's ``maps/`` directory."


#: ../../tuning/index.rst:129
msgid "``world`` : The filepath to the world file to use in simulation. Defaults to the ``worlds/`` directory in the package."
msgstr "``world``：仿真中使用的世界文件的文件路径。默认为包中的``worlds/``目录。"


#: ../../tuning/index.rst:130
msgid "``params_file`` : The main navigation configuration file. Defaults to ``nav2_params.yaml`` in the package's ``params/`` directory."
msgstr "``params_file`` : The main navigation configuration file. Defaults to ``nav2_params.yaml`` in the package's ``params/`` directory."


#: ../../tuning/index.rst:131
msgid "``autostart`` : Whether to autostart the navigation system's lifecycle management system. Defaults to ``true`` to transition up the Nav2 stack on creation to the activated state, ready for use."
msgstr "``autostart``：是否自动启动导航系统的生命周期管理系统。默认值为``true``，即在创建时将其上移至Nav2堆栈的激活状态，准备好使用。"


#: ../../tuning/index.rst:132
msgid "``use_composition`` : Whether to launch each Nav2 server into individual processes or in a single composed node, to leverage savings in CPU and memory. Default ``true`` to use single process Nav2."
msgstr "``use_composition`` : Whether to launch each Nav2 server into individual processes or in a single composed node, to leverage savings in CPU and memory. Default ``true`` to use single process Nav2."


#: ../../tuning/index.rst:133
msgid "``use_respawn`` : Whether to allow server that crash to automatically respawn. When also configured with the lifecycle manager, the manager will transition systems back up if already activated and went down due to a crash. Only works in non-composed bringup since all of the nodes are in the same process / container otherwise."
msgstr "``use_respawn``：是否允许服务器崩溃时自动重启。当与生命周期管理器一起配置时，如果已经激活并因崩溃而停机，管理器将重新启动系统。只适用于非组合启动，因为所有节点在同一个进程/容器中。"


#: ../../tuning/index.rst:134
msgid "``use_sim_time`` : Whether to set all the nodes to use simulation time, needed in simulation. Default ``true`` for simulation."
msgstr "``use_sim_time`` : Whether to set all the nodes to use simulation time, needed in simulation. Default ``true`` for simulation."


#: ../../tuning/index.rst:135
msgid "``rviz_config_file`` : The filepath to the rviz configuration file to use. Defaults to the ``rviz/`` directory's file."
msgstr "``rviz_config_file`` : The filepath to the rviz configuration file to use. Defaults to the ``rviz/`` directory's file."


#: ../../tuning/index.rst:136
msgid "``use_simulator`` : Whether or not to start the Gazebo simulator with the Nav2 stack. Defaults to ``true`` to launch Gazebo."
msgstr "``use_simulator`` : Whether or not to start the Gazebo simulator with the Nav2 stack. Defaults to ``true`` to launch Gazebo."


#: ../../tuning/index.rst:137
msgid "``use_robot_state_pub`` : Whether or not to start the robot state publisher to publish the robot's URDF transformations to TF2. Defaults to ``true`` to publish the robot's TF2 transformations."
msgstr "``use_robot_state_pub`` : Whether or not to start the robot state publisher to publish the robot's URDF transformations to TF2. Defaults to ``true`` to publish the robot's TF2 transformations."


#: ../../tuning/index.rst:138
msgid "``use_rviz`` : Whether or not to launch rviz for visualization. Defaults to ``true`` to show rviz."
msgstr "``use_rviz`` : Whether or not to launch rviz for visualization. Defaults to ``true`` to show rviz."


#: ../../tuning/index.rst:139
msgid "``headless`` : Whether or not to launch the Gazebo front-end alongside the background Gazebo simulation. Defaults to ``true`` to display the Gazebo window."
msgstr "``headless`` : Whether or not to launch the Gazebo front-end alongside the background Gazebo simulation. Defaults to ``true`` to display the Gazebo window."


#: ../../tuning/index.rst:140
msgid "``namespace`` : The namespace to launch robots into, if need be."
msgstr "``namespace`` : The namespace to launch robots into, if need be."


#: ../../tuning/index.rst:141
msgid "``use_namespace`` : Whether or not to launch robots into this namespace. Default ``false`` and uses global namespace for single robot."
msgstr "``use_namespace`` : Whether or not to launch robots into this namespace. Default ``false`` and uses global namespace for single robot."


#: ../../tuning/index.rst:142
msgid "``robot_name`` : The name of the robot to launch."
msgstr "``robot_name`` : The name of the robot to launch."


#: ../../tuning/index.rst:143
msgid "``robot_sdf`` : The filepath to the robot's gazebo configuration file containing the Gazebo plugins and setup to simulate the robot system."
msgstr "``robot_sdf`` : The filepath to the robot's gazebo configuration file containing the Gazebo plugins and setup to simulate the robot system."


#: ../../tuning/index.rst:144
msgid "``x_pose``, ``y_pose``, ``z_pose``, ``roll``, ``pitch``, ``yaw`` : Parameters to set the initial position of the robot in the simulation."
msgstr "``x_pose``, ``y_pose``, ``z_pose``, ``roll``, ``pitch``, ``yaw`` : Parameters to set the initial position of the robot in the simulation."


#: ../../tuning/index.rst:147
msgid "Other Pages We'd Love To Offer"
msgstr "Other Pages We'd Love To Offer"


#: ../../tuning/index.rst:149
msgid "If you are willing to chip in, some ideas are in https://github.com/ros-planning/navigation.ros.org/issues/204, but we'd be open to anything you think would be insightful!"
msgstr "If you are willing to chip in, some ideas are in https://github.com/ros-planning/navigation.ros.org/issues/204, but we'd be open to anything you think would be insightful!"

