# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020
# This file is distributed under the same license as the Navigation 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Navigation 2 latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-18 21:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"


#: ../../concepts/index.rst:4
msgid "Navigation Concepts"
msgstr "导航概念"


#: ../../concepts/index.rst:6
msgid "This page is to help familiarize new roboticists to the concepts of mobile robot navigation, in particular, with the concepts required to appreciating and working with this project."
msgstr "本页面旨在帮助新的机器人学家熟悉移动机器人导航的概念，特别是与理解和使用该项目所需的概念相关的内容。"


#: ../../concepts/index.rst:9
msgid "ROS 2"
msgstr "ROS 2"


#: ../../concepts/index.rst:11
msgid "ROS 2 is the core middleware used for Nav2. If you are unfamiliar with this, please visit `the ROS 2 documentation <https://docs.ros.org/en/rolling/>`_ before continuing."
msgstr "ROS 2是用于Nav2的核心中间件。如果您对此不熟悉，请在继续之前访问 `ROS 2文档 <https://docs.ros.org/en/rolling/>`_。"


#: ../../concepts/index.rst:14
msgid "Action Server"
msgstr "动作服务器"


#: ../../concepts/index.rst:16
msgid "Just as in ROS, action servers are a common way to control long running tasks like navigation. This stack makes more extensive use of actions, and in some cases, without an easy topic interface. It is more important to understand action servers as a developer in ROS 2. Some simple CLI examples can be found in the `ROS 2 documentation <https://docs.ros.org/en/rolling/Tutorials/Understanding-ROS2-Actions.html>`_."
msgstr "正如在ROS中一样，操作服务器是控制导航等长时间运行任务的常见方式。该堆栈更广泛地使用了操作，并且在某些情况下没有简单的主题接口。作为ROS 2中的开发人员，理解操作服务器更为重要。一些简单的CLI示例可以在 `ROS 2文档 <https://docs.ros.org/en/rolling/Tutorials/Understanding-ROS2-Actions.html>`_ 中找到。"


#: ../../concepts/index.rst:21
msgid "Action servers are similar to a canonical service server. A client will request some task to be completed, except, this task may take a long time. An example would be moving the shovel up from a bulldozer or ask a robot to travel 10 meters to the right."
msgstr "动作服务器类似于规范服务服务器。客户端将请求完成某些任务，但是这个任务可能需要很长时间。一个例子是将铲子从推土机上抬起，或者让机器人向右行驶10米。"


#: ../../concepts/index.rst:25
msgid "In this situation, action servers and clients allow us to call a long-running task in another process or thread and return a future to its result. It is permissible at this point to block until the action is complete, however, you may want to occasionally check if the action is complete and continue to process work in the client thread. Since it is long-running, action servers will also provide feedback to their clients. This feedback can be anything and is defined in the ROS ``.action`` along with the request and result types. In the bulldozer example, a request may be an angle, a feedback may be the angle remaining to be moved, and the result is a success or fail boolean with the end angle. In the navigation example, a request may be a position, a feedback may be the time its been navigating for and the distance to the goal, and the result a boolean for success."
msgstr "在这种情况下，操作服务器和客户端允许我们在另一个进程或线程中调用长时间运行的任务，并返回其结果的future。在这一点上，阻塞直到操作完成是允许的，但是您可能希望定期检查操作是否完成并继续在客户端线程中处理工作。由于它是长时间运行的，操作服务器还将向其客户端提供反馈。此反馈可以是任何内容，并在ROS ``.action`` 中与请求和结果类型一起定义。在推土机示例中，请求可以是一个角度，反馈可以是剩余要移动的角度，结果是一个成功或失败的布尔值以及最终角度。在导航示例中，请求可以是一个位置，反馈可以是导航所花费的时间和到目标的距离，结果是一个表示成功与否的布尔值。"


#: ../../concepts/index.rst:32
msgid "Feedback and results can be gathered synchronously by registering callbacks with the action client. They may also be gathered by asynchronously requesting information from the shared future objects. Both require spinning the client node to process callback groups."
msgstr "可以通过在动作客户端注册回调函数来同步获取反馈和结果。也可以通过异步请求共享的 future 对象来获取它们。这两种方法都需要在客户端节点中进行回调组处理。"


#: ../../concepts/index.rst:36
msgid "Action servers are used in this stack to communicate with the highest level Behavior Tree (BT) navigator through a ``NavigateToPose`` action message. They are also used for the BT navigator to communicate with the subsequent smaller action servers to compute plans, control efforts, and recoveries. Each will have their own unique ``.action`` type in ``nav2_msgs`` for interacting with the servers."
msgstr "此堆栈中使用操作服务器通过 ``NavigateToPose`` 操作消息与最高级别的行为树（BT）导航器进行通信。它们还用于BT导航器与后续的较小操作服务器进行计算规划、控制努力和恢复的通信。每个服务器与之交互的 ``.action`` 类型在 ``nav2_msgs`` 中具有自己的独特定义。"


#: ../../concepts/index.rst:41
msgid "Lifecycle Nodes and Bond"
msgstr "生命周期节点和 Bond"


#: ../../concepts/index.rst:43
msgid "Lifecycle (or Managed, more correctly) nodes are unique to ROS 2. More information can be `found here <https://design.ros2.org/articles/node_lifecycle.html>`_. They are nodes that contain state machine transitions for bringup and teardown of ROS 2 servers. This helps in deterministic behavior of ROS systems in startup and shutdown. It also helps users structure their programs in reasonable ways for commercial uses and debugging."
msgstr "生命周期（或管理）节点是ROS 2中特有的。更多信息可以在 `这里找到 <https://design.ros2.org/articles/node_lifecycle.html>`_。它们是包含用于启动和关闭ROS 2服务器的状态机转换的节点。这有助于确定性地处理ROS系统的启动和关闭行为。它还帮助用户以合理的方式组织他们的程序，以用于商业"


#: ../../concepts/index.rst:49
msgid "When a node is started, it is in the unconfigured state, only processing the node's constructor which should **not** contain any ROS networking setup or parameter reading. By the launch system, or the supplied lifecycle manager, the nodes need to be transitioned to inactive by configuring. After, it is possible to activate the node by transitioning through the activating stage."
msgstr "当节点启动时，它处于未配置状态，只处理节点的构造函数，该函数**不应**包含任何 ROS 网络设置或参数读取。通过启动系统或提供的生命周期管理器，需要将节点转换为非活动状态。然后，可以通过经历激活阶段来激活节点。"


#: ../../concepts/index.rst:53
msgid "This state will allow the node to process information and be fully setup to run. The configuration stage, triggering the ``on_configure()`` method, will setup all parameters, ROS networking interfaces, and for safety systems, all dynamically allocated memory. The activation stage, triggering the ``on_activate()`` method, will active the ROS networking interfaces and set any states in the program to start processing information."
msgstr "该状态将允许节点处理信息并完全设置运行环境。配置阶段触发``on_configure()``方法，将设置所有参数、ROS网络接口，并为安全系统分配所有动态分配的内存。激活阶段触发``on_activate()``方法，将激活ROS网络接口并设置程序中的任何状态以开始处理信息。"


#: ../../concepts/index.rst:57
msgid "To shutdown, we transition into deactivating, cleaning up, shutting down and end in the finalized state. The networking interfaces are deactivated and stop processing, deallocate memory, exit cleanly, in those stages, respectively."
msgstr "要关闭节点，我们需要经历非激活、清理、关闭阶段，并最终处于已完成状态。这些阶段分别是停用网络接口并停止处理、释放内存、正常退出。"


#: ../../concepts/index.rst:60
msgid "The lifecycle node framework is used extensively through out this project and all servers utilize it. It is best convention for all ROS systems to use lifecycle nodes if it is possible."
msgstr "生命周期节点框架在整个项目中被广泛使用，所有服务器都利用了该框架。如果可能的话，使用生命周期节点是所有ROS系统的最佳惯例。"


#: ../../concepts/index.rst:63
msgid "Within Nav2, we use a wrapper of LifecycleNodes, ``nav2_util LifecycleNode``. This wrapper wraps much of the complexities of LifecycleNodes for typical applications. It also includes a ``bond`` connection for the lifecycle manager to ensure that after a server transitions up, it also remains active. If a server crashes, it lets the lifecycle manager know and transition down the system to prevent a critical failure. See :ref:`eloquent_migration` for details."
msgstr "在 Nav2 中，我们使用了生命周期节点的包装器 ``nav2_util LifecycleNode``。这个包装器为典型的应用程序简化了生命周期节点的复杂性。它还包括一个 ``bond`` 连接，用于确保在服务器转换为上层后，它仍然保持活动状态。如果服务器崩溃，它会通知生命周期管理器并降级系统，以防止关键故障。有关详细信息，请参见 :ref:`eloquent_migration`。"


#: ../../concepts/index.rst:69
msgid "Behavior Trees"
msgstr "行为树"


#: ../../concepts/index.rst:71
msgid "Behavior trees (BT) are becoming increasingly common in complex robotics tasks. They are a tree structure of tasks to be completed. It creates a more scalable and human-understandable framework for defining multi-step or many state applications. This is opposed to a finite state machine (FSM) which may have dozens of states and hundreds of transitions. An example would be a soccer-playing robot. Embedding the logic of soccer game play into a FSM would be challenging and error prone with many possible states and rules. Additionally, modeling choices like to shoot at the goal from the left, right, or center, is particularly unclear. With a BT, basic primitives, like \"kick\", \"walk\", \"go to ball\", can be created and reused for many behaviors. More information can be found `in this book <https://arxiv.org/abs/1709.00084>`_. I **strongly** recommend reading chapters 1-3 to get a good understanding of the nomenclature and workflow. It should only take about 30 minutes."
msgstr "行为树（Behavior trees，BT）在复杂的机器人任务中越来越常见。它们是一种由任务构成的树状结构，用于完成任务。它为定义多步骤或多状态应用程序提供了一个更具可扩展性和可理解性的框架。这与有数十个状态和数百个转换的有限状态机（FSM）相反。一个例子是踢足球的机器人。将足球比赛的逻辑嵌入到有限状态机中将会具有挑战性，并且容易出错，因为存在许多可能的状态和规则。此外，像从左、右或中间射门这样的建模选择尤其不清楚。通过使用行为树，可以创建和重用基本的原语，如“踢球”，“行走”，“走向球”，以实现多种行为。有关更多信息，请参阅 `本书 <https://arxiv.org/abs/1709.00084>`_ 的第1-3章。我**强烈**建议阅读这些章"


#: ../../concepts/index.rst:83
msgid "Behavior Trees provide a formal structure for navigation logic which can be both used to create complex systems but also be verifiable and validated as provenly correct using advanced tools. Having the application logic centralized in the behavior tree and with independent task servers (which only communicate data over the tree) allows for formal analysis."
msgstr "行为树为导航逻辑提供了一种形式化结构，既可以用于创建复杂系统，又可以使用先进的工具进行验证和验证其正确性。将应用逻辑集中在行为树中，并使用独立的任务服务器（仅通过树进行数据通信），可以进行形式化分析。"


#: ../../concepts/index.rst:85
msgid "For this project, we use `BehaviorTree CPP V3 <https://www.behaviortree.dev/>`_ as the behavior tree library. We create node plugins which can be constructed into a tree, inside the ``BT Navigator``. The node plugins are loaded into the BT and when the XML file of the tree is parsed, the registered names are associated. At this point, we can march through the behavior tree to navigate."
msgstr "在这个项目中，我们使用 `BehaviorTree CPP V3 <https://www.behaviortree.dev/>`_ 作为行为树库。我们创建可以构建成树的节点插件，放置在 ``BT Navigator`` 中。节点插件会加载到行为树中，并在解析树的XML文件时与注册的名称关联起来。此时，我们可以通过行为树进行导航。"


#: ../../concepts/index.rst:90
msgid "One reason this library is used is its ability to load subtrees. This means that the Nav2 behavior tree can be loaded into another higher-level BT to use this project as node plugin. An example would be in soccer play, using the Nav2 behavior tree as the \"go to ball\" node with a ball detection as part of a larger task. Additionally, we supply a ``NavigateToPoseAction`` plugin (among others) for BT so the Nav2 stack can be called from a client application through the usual action interface."
msgstr "使用此库的一个原因是它能够加载子树。这意味着Nav2行为树可以加载到另一个更高级别的行为树中，以将该项目用作节点插件。例如，在足球比赛中，可以将Nav2行为树作为\"去球\"节点，并作为更大任务的一部分进行球检测。此外，我们还为行为树提供了``NavigateToPoseAction``插件（以及其他插件），以便可以通过通常的操作接口从客户端应用程序调用Nav2堆栈。"


#: ../../concepts/index.rst:94
msgid "Other systems could be used to design complex autonomous behavior, namely Hierarchical FSMs (HFSM). Behavior Trees were selected due to popularity across the robotics and related industries and by largely user demand. However, due to the independent task server nature of Nav2, it is not difficult to offer a ``nav2_hfsm_navigator`` package in the future, pending interest and contribution."
msgstr "其他系统也可以用于设计复杂的自主行为，例如分层有限状态机（HFSM）。选择行为树是因为它在机器人和相关行业中很受欢迎，并且用户需求较大。然而，由于Nav2具有独立的任务服务器特性，未来很容易提供一个 ``nav2_hfsm_navigator`` 包，具体取决于兴趣和贡献的情况。"


#: ../../concepts/index.rst:99
msgid "Navigation Servers"
msgstr "导航服务器"


#: ../../concepts/index.rst:101
msgid "Planners and controllers are at the heart of a navigation task. Recoveries are used to get the robot out of a bad situation or attempt to deal with various forms of issues to make the system fault-tolerant. Smoothers can be used for additional quality improvements of the planned path. In this section, the general concepts around them and their uses in this project are analyzed."
msgstr "规划器和控制器是导航任务的核心。恢复机制用于将机器人从困境中解救出来，或者尝试解决各种问题，使系统具有容错性。平滑器可用于对规划路径进行额外的质量改进。本节将分析这些概念以及它们在该项目中的用途。"


#: ../../concepts/index.rst:107
msgid "Planner, Controller, Smoother and Recovery Servers"
msgstr "规划器、控制器、平滑器和恢复服务器"


#: ../../concepts/index.rst:108
msgid "Four of the action servers in this project are the planner, behavior, smoother and controller servers."
msgstr "该项目中有四个动作服务器，包括规划器、行为器、平滑器和控制器服务器。"


#: ../../concepts/index.rst:110
msgid "These action servers are used to host a map of algorithm plugins to complete various tasks. They also host the environmental representation used by the algorithm plugins to compute their outputs."
msgstr "这些动作服务器用于托管算法插件的映射，以完成各种任务。它们还托管算法插件使用的环境表示，用于计算它们的输出。"


#: ../../concepts/index.rst:113
msgid "The planner, smoother and controller servers will be configured at runtime with the names (aliases) and types of algorithms to use. These types are the pluginlib names that have been registered and the names are the aliases for the task. An example would be the DWB controller used with name ``FollowPath``, as it follows a reference path. In this case, then all parameters for DWB would be placed in that namespace, e.g. ``FollowPath.<param>``."
msgstr "规划器、平滑器和控制器服务器将在运行时配置算法的名称（别名）和类型。这些类型是已注册的插件库名称，而名称则是任务的别名。一个例子是使用名称 ``FollowPath`` 的DWB控制器，因为它遵循一个参考路径。在这种情况下，所有DWB的参数将放置在该命名空间中，例如 ``FollowPath.<param>``。"


#: ../../concepts/index.rst:118
msgid "These three servers then expose an action interface corresponding to their task. When the behavior tree ticks the corresponding BT node, it will call the action server to process its task. The action server callback inside the server will call the chosen algorithm by its name (e.g. ``FollowPath``) that maps to a specific algorithm. This allows a user to abstract the algorithm used in the behavior tree to classes of algorithms. For instance, you can have ``N`` plugin controllers to follow paths, dock with charger, avoid dynamic obstacles, or interface with a tool. Having all of these plugins in the same server allows the user to make use of a single environmental representation object, which is costly to duplicate."
msgstr "这三个服务器会公开与其任务相对应的动作接口。当行为树触发相应的行为树节点时，它将调用动作服务器来处理其任务。服务器内的动作服务器回调将根据其名称（例如 ``FollowPath``）调用所选择的算法，该名称映射到特定的算法。这使用户可以将行为树中使用的算法抽象为算法类。例如，您可以拥有 ``N`` 个插件控制器来跟踪路径、对接充电器、避免动态障碍物或与工具进行接口交互。将所有这些插件放在同一个服务器上使用户能够使用单个环境表示对象，这样做会很昂贵。"


#: ../../concepts/index.rst:125
msgid "For the behavior server, each of the behaviors also contains their own name, however, each plugin will also expose its own special action server. This is done because of the wide variety of behavior actions that may be created which cannot have a single simple interface to share. The behavior server also contains a costmap subscriber to the local costmap, receiving real-time updates from the controller server, to compute its tasks. We do this to avoid having multiple instances of the local costmap which are computationally expensive to duplicate."
msgstr "对于行为服务器，每个行为也有自己的名称，然而，每个插件还会公开自己的特殊动作服务器。这是因为可能会创建各种各样的行为动作，无法共享单个简单的接口。行为服务器还包含一个用于接收控制器服务器的本地代价地图的代价地图订阅者，以计算其任务。我们这样做是为了避免多个代价地图实例的重复计算，这会消耗大量计算资源。"


#: ../../concepts/index.rst:130
msgid "Alternatively, since the BT nodes are trivial plugins calling an action, new BT nodes can be created to call other action servers with other action types. It is advisable to use the provided servers if possible at all times. If, due to the plugin or action interfaces, a new server is needed, that can be sustained with the framework. The new server should use the new type and plugin interface, similar to the provided servers. A new BT node plugin will need to be created to call the new action server -- however no forking or modification is required in the Nav2 repo itself by making extensive use of servers and plugins."
msgstr "另外，由于行为树节点是调用动作的简单插件，因此可以创建新的行为树节点来调用其他具有不同动作类型的动作服务器。建议尽可能使用提供的服务器。如果由于插件或动作接口的原因需要新服务器，则可以使用该框架来支持。新服务器应该使用新类型和插件接口，类似于提供的服务器。需要创建新的行为树节点插件来调用新的动作服务器-然而，通过广泛使用服务器和插件，不需要对Nav2 repo本身进行分叉或修改。"


#: ../../concepts/index.rst:136
msgid "If you find that you require a new interface to the pluginlib definition or action type, please file a ticket and see if we can rectify that in the same interfaces."
msgstr "如果您发现需要一个新的插件库定义或动作类型的接口，请提交工单，看看我们能否在同一接口中进行修复。"


#: ../../concepts/index.rst:139
msgid "Planners"
msgstr "规划器"


#: ../../concepts/index.rst:141
msgid "The task of a planner is to compute a path to complete some objective function. The path can also be known as a route, depending on the nomenclature and algorithm selected. Two canonical examples are computing a plan to a goal (e.g. from current position to a goal) or complete coverage (e.g. plan to cover all free space). The planner will have access to a global environmental representation and sensor data buffered into it. Planners can be written to:"
msgstr "规划器的任务是计算完成某个目标函数的路径。路径也可以根据术语和所选算法称为路线。两个典型的例子是计算到目标的路径（例如从当前位置到目标）或完成覆盖（例如规划以覆盖所有自由空间）。规划器将可以访问全局环境表示以及缓冲到其中的传感器数据。规划器可以编写为："


#: ../../concepts/index.rst:147
msgid "Compute shortest path"
msgstr "计算最短路径"


#: ../../concepts/index.rst:148
msgid "Compute complete coverage path"
msgstr "计算完整覆盖路径"


#: ../../concepts/index.rst:149
msgid "Compute paths along sparse or predefined routes"
msgstr "计算稀疏或预定义路径上的路径"


#: ../../concepts/index.rst:151
msgid "The general task in Nav2 for the planner is to compute a valid, and potentially optimal, path from the current pose to a goal pose. However, many classes of plans and routes exist which are supported."
msgstr "Nav2中规划器的一般任务是从当前位姿到目标位姿计算有效且可能最优的路径。然而，支持许多类别的计划和路径存在。"


#: ../../concepts/index.rst:155
msgid "Controllers"
msgstr "控制器"


#: ../../concepts/index.rst:157
msgid "Controllers, also known as local planners in ROS 1, are the way we follow the globally computed path or complete a local task. The controller will have access to a local environment representation to attempt to compute feasible control efforts for the base to follow. Many controller will project the robot forward in space and compute a locally feasible path at each update iteration. Controllers can be written to:"
msgstr "控制器，在ROS 1中也被称为局部规划器，是我们遵循全局计算路径或完成局部任务的方式。控制器将能够访问局部环境表示，以尝试计算用于底盘跟随的可行控制力。许多控制器会将机器人在空间中向前推进，并在"


#: ../../concepts/index.rst:162
msgid "Follow a path"
msgstr "沿路径前进"


#: ../../concepts/index.rst:163
msgid "Dock with a charging station using detectors in the odometric frame"
msgstr "使用测距仪在里程计框架中与充电站对接"


#: ../../concepts/index.rst:164
msgid "Board an elevator"
msgstr "进入电梯"


#: ../../concepts/index.rst:165
msgid "Interface with a tool"
msgstr "与工具进行接口连接"


#: ../../concepts/index.rst:167
msgid "The general task in Nav2 for a controller is to compute a valid control effort to follow the global plan. However, many classes of controllers and local planners exist. It is the goal of this project that all controller algorithms can be plugins in this server for common research and industrial tasks."
msgstr "Nav2控制器的一般任务是计算有效的控制力以跟随全局计划。然而，存在许多类别的控制器和局部规划器。该项目的目标是使所有控制器算法能够作为此服务器中的常见研究和工业任务的插件。"


#: ../../concepts/index.rst:172
msgid "Behaviors"
msgstr "行为"


#: ../../concepts/index.rst:174
msgid "Recovery behaviors are a mainstay of fault-tolerant systems. The goal of recoveries are to deal with unknown or failure conditions of the system and autonomously handle them. Examples may include faults in the perception system resulting in the environmental representation being full of fake obstacles. The clear costmap recovery would then be triggered to allow the robot to move."
msgstr "恢复行为是容错系统的重要组成部分。恢复的目标是处理系统的未知或故障条件，并自主处理它们。例如，可能会出现感知系统故障导致环境表示充满虚假障碍物的情况。然后会触发清除代价地图恢复以允许机器人移动。"


#: ../../concepts/index.rst:179
msgid "Another example would be if the robot was stuck due to dynamic obstacles or poor control. Backing up or spinning in place, if permissible, allow the robot to move from a poor location into free space it may navigate successfully."
msgstr "另一个例子是，如果机器人由于动态障碍物或控制不良而被卡住。如果允许的话，倒退或原地旋转可以使机器人从糟糕的位置移动到可以成功导航的自由空间。"


#: ../../concepts/index.rst:182
msgid "Finally, in the case of a total failure, a recovery may be implemented to call an operator's attention for help. This can be done via email, SMS, Slack, Matrix, etc."
msgstr "最后，在发生总故障的情况下，可以实施恢复操作来请求操作员的帮助。这可以通过电子邮件、短信、Slack、Matrix等方式完成。"


#: ../../concepts/index.rst:185
msgid "It is important to note that the behavior server can hold any behavior to share access to expensive resources like costmaps or TF buffers, not just recovery behaviors. Each may have its own API."
msgstr "重要的是要注意，行为服务器可以保存任何行为，以共享对昂贵资源（如代价地图或TF缓冲区）的访问，不仅仅是恢复行为。每个行为可能都有自己的API。"


#: ../../concepts/index.rst:188
msgid "Smoothers"
msgstr "平滑器"


#: ../../concepts/index.rst:190
msgid "As criteria for optimality of the path searched by a planner are usually reduced compared to reality, additional path refinement is often beneficial. Smoothers have been introduced for this purpose, typically responsible for reducing path raggedness and smoothing abrupt rotations, but also for increasing distance from obstacles and high-cost areas as the smoothers have access to a global environmental representation."
msgstr "通常，与规划器搜索的路径的最佳性标准相比，路径的额外细化通常是有益的。为此引入了平滑器，通常负责减少路径的不平整和平滑突然的旋转，同时增加与障碍物和高代价区域的距离，因为平滑器可以访问全局环境表示。"


#: ../../concepts/index.rst:194
msgid "Use of a separate smoother over one that is included as part of a planner is advantageous when combining different planners with different smoothers or when a specific control over smoothing is required, e.g. smoothing only a specific part of the path."
msgstr "在将不同的规划器与不同的平滑器结合或需要对平滑进行特定控制时，使用独立的平滑器而不是作为规划器的一部分的平滑器具有优势，例如仅对路径的特定部分进行平滑。"


#: ../../concepts/index.rst:196
msgid "The general task in Nav2 for a smoother is to receive a path and return its improved version. However, for different input paths, criteria of the improvements and methods of acquiring them exist, creating space for a multitude of smoothers that can be registered in this server."
msgstr "Nav2中平滑器的一般任务是接收路径并返回其改进版本。然而，对于不同的输入路径，改进的标准和获取方法也存在，因此可以在该服务器中注册多种平滑器。"


#: ../../concepts/index.rst:200
msgid "Waypoint Following"
msgstr "路径点跟随"


#: ../../concepts/index.rst:202
msgid "Waypoint following is a basic feature of a navigation system. It tells our system how to use navigation to get to multiple destinations."
msgstr "路径点跟踪是导航系统的基本功能之一。它告诉我们的系统如何使用导航来到达多个目的地。"


#: ../../concepts/index.rst:204
msgid "The ``nav2_waypoint_follower`` contains a waypoint following program with a plugin interface for specific task executors. This is useful if you need to go to a given location and complete a specific task like take a picture, pick up a box, or wait for user input. It is a nice demo application for how to use Nav2 in a sample application."
msgstr "``nav2_waypoint_follower``包含一个路径点跟随程序，具有特定任务执行器的插件接口。如果您需要前往指定位置并完成特定任务，例如拍照、拾起盒子或等待用户输入，这将非常有用。这是一个演示如何在示例应用中使用Nav2的好的应用程序。"


#: ../../concepts/index.rst:208
msgid "However, it could be used for more than just a sample application. There are 2 schools of thoughts for fleet managers / dispatchers:"
msgstr "然而，它可以用于不仅仅是一个示例应用程序。对于车队管理人员/调度员来说，有两种思路："


#: ../../concepts/index.rst:211
msgid "Dumb robot; smart centralized dispatcher"
msgstr "愚蠢的机器人；智能集中调度程序"


#: ../../concepts/index.rst:212
msgid "Smart robot; dumb centralized dispatcher"
msgstr "智能机器人；愚蠢的集中调度员"


#: ../../concepts/index.rst:214
msgid "In the first, the ``nav2_waypoint_follower`` is fully sufficient to create a production-grade on-robot solution. Since the autonomy system / dispatcher is taking into account things like the robot's pose, battery level, current task, and more when assigning tasks, the application on the robot just needs to worry about the task at hand and not the other complexities of the system to complete the requested task. In this situation, you should think of a request to the waypoint follower as 1 unit of work (e.g. 1 pick in a warehouse, 1 security patrole loop, 1 aisle, etc) to do a task and then return to the dispatcher for the next task or request to recharge. In this school of thought, the waypoint following application is just one step above navigation and below the system autonomy application."
msgstr "首先，``nav2_waypoint_follower``完全足够创建一个面向生产的机器人解决方案。由于自治系统/调度程序在分配任务时考虑了诸如机器人姿态、电池电量、当前任务等因素，因此机器人上的应用程序只需要关注当前任务而不必担心系统的其他复杂性来完成所请求的任务。在这种情况下，您应该将路径点跟随程序的请求视为一项工作单元（例如在仓库中拣选一个物品，执行一次安全巡逻，遍历一条通道等）来执行任务，然后返回给调度程序以获取下一个任务或充电请求。在这种思路中，路径点跟随应用程序只是导航的上一步，在系统自治应用程序之下。"


#: ../../concepts/index.rst:216
msgid "In the second, the ``nav2_waypoint_follower`` is a nice sample application / proof of concept, but you really need your waypoint following / autonomy system on the robot to carry more weight in making a robust solution. In this case, you should use the ``nav2_behavior_tree`` package to create a custom application-level behavior tree using navigation to complete the task. This can include subtrees like checking for the charge status mid-task for returning to dock or handling more than 1 unit of work in a more complex task. Soon, there will be a ``nav2_bt_waypoint_follower`` (name subject to adjustment) that will allow you to create this application more easily. In this school of thought, the waypoint following application is more closely tied to the system autonomy, or in many cases, is the system autonomy."
msgstr "在第二种思路中，``nav2_waypoint_follower`` 是一个很好的示例应用程序/概念验证，但是你真正需要的是机器人上的航路点跟踪/自主系统来更好地解决问题。在这种情况下，你应该使用 ``nav2_behavior_tree`` 包来创建一个使用导航完成任务的自定义应用程序级行为树。这可以包括检查任务进行到一半时的充电状态以返回到码头，或者处理更复杂任务中超过1个工作单元的子树。很快，将会有一个``nav2_bt_waypoint_follower``（名称可能会有所调整），它将使您更容易创建这个应用程序。在这种思路中，航路点跟踪应用程序与系统自主性更为密切相关，或者在许多情况下，就是系统自主性本身。"


#: ../../concepts/index.rst:218
msgid "Neither is better than the other, it highly depends on the tasks your robot(s) are completing, in what type of environment, and with what cloud resources available. Often this distinction is very clear for a given business case."
msgstr "两者并没有优劣之分，它非常依赖于机器人所完成的任务类型、环境类型以及可用的云资源。对于特定的业务案例，通常这种区别非常明确。"


#: ../../concepts/index.rst:221
msgid "State Estimation"
msgstr "状态估计"


#: ../../concepts/index.rst:223
msgid "Within the navigation project, there are 2 major transformations that need to be provided, according to community standards. The ``map`` to ``odom`` transform is provided by a positioning system (localization, mapping, SLAM) and ``odom`` to ``base_link`` by an odometry system."
msgstr "在导航项目中，根据社区标准需要提供两个主要的转换。``map``到``odom``的转换由定位系统（定位、地图构建、SLAM）提供，``odom``到``base_link``的转换由里程计系统提供。"


#: ../../concepts/index.rst:228
msgid "There is **no** requirement on using a LIDAR on your robot to use the navigation system. There is no requirement to use lidar-based collision avoidance, localization, or SLAM. However, we do provide instructions and support tried and true implementations of these things using lidars. You can be equally as successful using a vision or depth based positioning system and using other sensors for collision avoidance. The only requirement is that you follow the standards below with your choice of implementation."
msgstr "使用导航系统并不需要在机器人上使用激光雷达。也没有使用基于激光雷达的避障、定位或SLAM的要求。但是，我们提供了使用激光雷达的这些功能的指导和支持。您同样可以使用视觉或基于深度的定位系统，并使用其他传感器进行避障。唯一的要求是您必须按照下面的标准选择实现。"


#: ../../concepts/index.rst:234
msgid "Standards"
msgstr "标准"


#: ../../concepts/index.rst:236
msgid "`REP 105 <https://www.ros.org/reps/rep-0105.html>`_ defines the frames and conventions required for navigation and the larger ROS ecosystem. These conventions should be followed at all times to make use of the rich positioning, odometry, and SLAM projects available in the community."
msgstr "``REP 105 <https://www.ros.org/reps/rep-0105.html>`` 定义了导航和更大的ROS生态系统所需的坐标系和约定。为了利用社区中丰富的定位、里程计和SLAM项目，应始终遵循这些约定。"


#: ../../concepts/index.rst:239
msgid "In a nutshell, REP-105 says that you must, at minimum, build a TF tree that contains a full ``map`` -> ``odom`` -> ``base_link`` -> ``[sensor frames]`` for your robot. TF2 is the time-variant transformation library in ROS 2 we use to represent and obtain time synchronized transformations. It is the job of the global positioning system (GPS, SLAM, Motion Capture) to, at minimum, provide the ``map`` -> ``odom`` transformation. It is then the role of the odometry system to provide the ``odom`` -> ``base_link`` transformation. The remainder of the transformations relative to ``base_link`` should be static and defined in your `URDF <http://wiki.ros.org/urdf>`_."
msgstr "简而言之，REP-105 规定你至少需要构建一个包含完整 ``map`` -> ``odom`` -> ``base_link`` -> ``[sensor frames]`` 的 TF 树来表示你的机器人。TF2 是 ROS 2 中用于表示和获取时间同步转换的时变转换库。全局定位系统（GPS、SLAM、动作捕捉）的任务是至少提供 ``map`` -> ``odom`` 转换。然后里程计系统的任务是提供 ``odom`` -> ``base_link`` 转换。相对于 ``base_link`` 的其余转换应该是静态的，并在你的 `URDF <http://wiki.ros.org/urdf>`_ 中定义。"


#: ../../concepts/index.rst:246
msgid "Global Positioning: Localization and SLAM"
msgstr "全局定位：定位和SLAM"


#: ../../concepts/index.rst:248
msgid "It is the job of the global positioning system (GPS, SLAM, Motion Capture) to, at minimum, provide the ``map`` -> ``odom`` transformation. We provide ``amcl`` which is an Adaptive Monte-Carlo Localization technique based on a particle filter for localization in a static map. We also provide SLAM Toolbox as the default SLAM algorithm for use to position and generate a static map."
msgstr "全局定位系统（GPS、SLAM、动作捕捉）的任务是至少提供 ``map`` -> ``odom`` 转换。我们提供了 ``amcl``，它是一种基于粒子滤波器的自适应蒙特卡洛定位技术，用于在静态地图中进行定位。我们还提供 SLAM 工具箱作为默认的 SLAM 算法，用于定位和生成静态地图。"


#: ../../concepts/index.rst:252
msgid "These methods may also produce other output including position topics, maps, or other metadata, but they must provide that transformation to be valid. Multiple positioning methods can be fused together using robot localization, discussed more below."
msgstr "These methods may also produce other output including position topics, maps, or other metadata, but they must provide that transformation to be valid. Multiple positioning methods can be fused together using robot localization, discussed more below."


#: ../../concepts/index.rst:257
msgid "Odometry"
msgstr "里程计"


#: ../../concepts/index.rst:259
msgid "It is the role of the odometry system to provide the ``odom`` -> ``base_link`` transformation. Odometry can come from many sources including LIDAR, RADAR, wheel encoders, VIO, and IMUs. The goal of the odometry is to provide a smooth and continuous local frame based on robot motion. The global positioning system will update the transformation relative to the global frame to account for the odometric drift."
msgstr "It is the role of the odometry system to provide the ``odom`` -> ``base_link`` transformation. Odometry can come from many sources including LIDAR, RADAR, wheel encoders, VIO, and IMUs. The goal of the odometry is to provide a smooth and continuous local frame based on robot motion. The global positioning system will update the transformation relative to the global frame to account for the odometric drift."


#: ../../concepts/index.rst:264
msgid "`Robot Localization <https://github.com/cra-ros-pkg/robot_localization/>`_ is typically used for this fusion. It will take in ``N`` sensors of various types and provide a continuous and smooth odometry to TF and to a topic. A typical mobile robotics setup may have odometry from wheel encoders, IMUs, and vision fused in this manner."
msgstr "`机器人定位 <https://github.com/cra-ros-pkg/robot_localization/>`_ 通常用于此融合。它会接收各种类型的 ``N`` 个传感器，并为 TF 和一个话题提供连续平滑的里程计。一个典型的移动机器人设置可能会以此方式融合来自轮式编码器、IMU 和视觉的里程计信息。"


#: ../../concepts/index.rst:268
msgid "The smooth output can be used then for dead-reckoning for precise motion and updating the position of the robot accurately between global position updates."
msgstr "The smooth output can be used then for dead-reckoning for precise motion and updating the position of the robot accurately between global position updates."


#: ../../concepts/index.rst:273
msgid "Environmental Representation"
msgstr "环境表示"


#: ../../concepts/index.rst:275
msgid "The environmental representation is the way the robot perceives its environment. It also acts as the central localization for various algorithms and data sources to combine their information into a single space. This space is then used by the controllers, planners, and recoveries to compute their tasks safely and efficiently."
msgstr "The environmental representation is the way the robot perceives its environment. It also acts as the central localization for various algorithms and data sources to combine their information into a single space. This space is then used by the controllers, planners, and recoveries to compute their tasks safely and efficiently."


#: ../../concepts/index.rst:280
msgid "Costmaps and Layers"
msgstr "代价地图和层"


#: ../../concepts/index.rst:282
msgid "The current environmental representation is a costmap. A costmap is a regular 2D grid of cells containing a cost from unknown, free, occupied, or inflated cost. This costmap is then searched to compute a global plan or sampled to compute local control efforts."
msgstr "The current environmental representation is a costmap. A costmap is a regular 2D grid of cells containing a cost from unknown, free, occupied, or inflated cost. This costmap is then searched to compute a global plan or sampled to compute local control efforts."


#: ../../concepts/index.rst:286
msgid "Various costmap layers are implemented as pluginlib plugins to buffer information into the costmap. This includes information from LIDAR, RADAR, sonar, depth images, etc. It may be wise to process sensor data before inputting it into the costmap layer, but that is up to the developer."
msgstr "Various costmap layers are implemented as pluginlib plugins to buffer information into the costmap. This includes information from LIDAR, RADAR, sonar, depth images, etc. It may be wise to process sensor data before inputting it into the costmap layer, but that is up to the developer."


#: ../../concepts/index.rst:290
msgid "Costmap layers can be created to detect and track obstacles in the scene for collision avoidance using camera or depth sensors. Additionally, layers can be created to algorithmically change the underlying costmap based on some rule or heuristic. Finally, they may be used to buffer live data into the 2D or 3D world for binary obstacle marking."
msgstr "Costmap layers can be created to detect and track obstacles in the scene for collision avoidance using camera or depth sensors. Additionally, layers can be created to algorithmically change the underlying costmap based on some rule or heuristic. Finally, they may be used to buffer live data into the 2D or 3D world for binary obstacle marking."


#: ../../concepts/index.rst:295
msgid "Costmap Filters"
msgstr "代价地图过滤器"


#: ../../concepts/index.rst:297
msgid "Imagine, you're annotating a map file (or any image file) in order to have a specific action occur based on the location in the annotated map. Examples of marking/annotating might be keep out zones to avoid planning inside, or have pixels belong to maximum speeds in marked areas. This annotated map is called \"filter mask\". Just like a mask overlaid on a surface, it can or cannot be same size, pose and scale as a main map. The main goal of filter mask - is to provide the ability of marking areas on maps with some additional features or behavioral changes."
msgstr "Imagine, you're annotating a map file (or any image file) in order to have a specific action occur based on the location in the annotated map. Examples of marking/annotating might be keep out zones to avoid planning inside, or have pixels belong to maximum speeds in marked areas. This annotated map is called \"filter mask\". Just like a mask overlaid on a surface, it can or cannot be same size, pose and scale as a main map. The main goal of filter mask - is to provide the ability of marking areas on maps with some additional features or behavioral changes."


#: ../../concepts/index.rst:299
msgid "Costmap filters are a costmap layer-based approach of applying spatial-dependent behavioral changes, annotated in filter masks, into the Nav2 stack. Costmap filters are implemented as costmap plugins. These plugins are called \"filters\" as they are filtering a costmap by spatial annotations marked on filter masks. In order to make a filtered costmap and change a robot's behavior in annotated areas, the filter plugin reads the data coming from the filter mask. This data is being linearly transformed into a feature map in a filter space. Having this transformed feature map along with a map/costmap, any sensor data and current robot coordinate filters can update the underlying costmap and change the behavior of the robot depending on where it is. For example, the following functionality could be made by use of costmap filters:"
msgstr "Costmap filters are a costmap layer-based approach of applying spatial-dependent behavioral changes, annotated in filter masks, into the Nav2 stack. Costmap filters are implemented as costmap plugins. These plugins are called \"filters\" as they are filtering a costmap by spatial annotations marked on filter masks. In order to make a filtered costmap and change a robot's behavior in annotated areas, the filter plugin reads the data coming from the filter mask. This data is being linearly transformed into a feature map in a filter space. Having this transformed feature map along with a map/costmap, any sensor data and current robot coordinate filters can update the underlying costmap and change the behavior of the robot depending on where it is. For example, the following functionality could be made by use of costmap filters:"


#: ../../concepts/index.rst:307
msgid "Keep-out/safety zones where robots will never enter."
msgstr "Keep-out/safety zones where robots will never enter."


#: ../../concepts/index.rst:308
msgid "Speed restriction areas. Maximum speed of robots going inside those areas will be limited."
msgstr "Speed restriction areas. Maximum speed of robots going inside those areas will be limited."


#: ../../concepts/index.rst:309
msgid "Preferred lanes for robots moving in industrial environments and warehouses."
msgstr "Preferred lanes for robots moving in industrial environments and warehouses."


#: ../../concepts/index.rst:312
msgid "Other Forms"
msgstr "Other Forms"


#: ../../concepts/index.rst:314
msgid "Various other forms of environmental representations exist. These include:"
msgstr "Various other forms of environmental representations exist. These include:"


#: ../../concepts/index.rst:317
msgid "gradient maps, which are similar to costmaps but represent surface gradients to check traversibility over"
msgstr "gradient maps, which are similar to costmaps but represent surface gradients to check traversibility over"


#: ../../concepts/index.rst:318
msgid "3D costmaps, which represent the space in 3D, but then also requires 3D planning and collision checking"
msgstr "3D costmaps, which represent the space in 3D, but then also requires 3D planning and collision checking"


#: ../../concepts/index.rst:319
msgid "Mesh maps, which are similar to gradient maps but with surface meshes at many angles"
msgstr "Mesh maps, which are similar to gradient maps but with surface meshes at many angles"


#: ../../concepts/index.rst:320
msgid "\"Vector space\", taking in sensor information and using machine learning to detect individual items and locations to track rather than buffering discrete points."
msgstr "\"Vector space\", taking in sensor information and using machine learning to detect individual items and locations to track rather than buffering discrete points."


#: ../../concepts/index.rst:323
msgid "Nav2 Academic Overview"
msgstr "Nav2 Academic Overview"

